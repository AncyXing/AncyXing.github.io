<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2022/10/25/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a class="link"   href="https://hexo.io/" >Hexo<i class="fas fa-external-link-alt"></i></a>! This is your very first post. Check <a class="link"   href="https://hexo.io/docs/" >documentation<i class="fas fa-external-link-alt"></i></a> for more info. If you get any problems when using Hexo, you can find the answer in <a class="link"   href="https://hexo.io/docs/troubleshooting.html" >troubleshooting<i class="fas fa-external-link-alt"></i></a> or you can ask me on <a class="link"   href="https://github.com/hexojs/hexo/issues" >GitHub<i class="fas fa-external-link-alt"></i></a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a class="link"   href="https://hexo.io/docs/writing.html" >Writing<i class="fas fa-external-link-alt"></i></a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a class="link"   href="https://hexo.io/docs/server.html" >Server<i class="fas fa-external-link-alt"></i></a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a class="link"   href="https://hexo.io/docs/generating.html" >Generating<i class="fas fa-external-link-alt"></i></a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a class="link"   href="https://hexo.io/docs/one-command-deployment.html" >Deployment<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>ES测试分词结果</title>
    <url>/2023/08/06/ES/ES%E6%B5%8B%E8%AF%95%E5%88%86%E8%AF%8D%E7%BB%93%E6%9E%9C/</url>
    <content><![CDATA[<p>es提供了一个测试分词的api接口，方便验证分词效果，endpoint是_analyze</p>
<h2 id="直接指定analyzer进行测试"><a href="#直接指定analyzer进行测试" class="headerlink" title="直接指定analyzer进行测试"></a>直接指定analyzer进行测试</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST _analyze</span><br><span class="line">&#123;</span><br><span class="line">    &quot;analyzer&quot;: &quot;standard&quot;,</span><br><span class="line">    &quot;text&quot;: &quot;hello world&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>analyzer表示指定的分词器，这里使用es自带的分词器standard，text用来指定待分词的文本</p>
<h2 id="指定索引中的字段进行测试"><a href="#指定索引中的字段进行测试" class="headerlink" title="指定索引中的字段进行测试"></a>指定索引中的字段进行测试</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST text_index/_analyze</span><br><span class="line">&#123;</span><br><span class="line">  &quot;field&quot;: &quot;username&quot;,</span><br><span class="line">  &quot;text&quot;: &quot;hello world&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当没有指定分词器的时候默认使用standard</p>
<h2 id="预定义的分词器"><a href="#预定义的分词器" class="headerlink" title="预定义的分词器"></a>预定义的分词器</h2><p>es自带有以下的预定义分词器，可以直接使用：standard，默认分词器，具有<strong>按词切分、支持多语言、小写处理</strong>的特点。<br>standerd将stopword默认关闭了，也就是这些词还是会在分词后保留。stopword就是例如and、the、or这种词，可以通过配置将它打开。其实搜索引擎应该将这些stop word过滤掉，这样可以减少压力的同时保证搜索的准确性。</p>
]]></content>
      <tags>
        <tag>es</tag>
      </tags>
  </entry>
  <entry>
    <title>ES查询时排序</title>
    <url>/2023/08/06/ES/ES%E6%9F%A5%E8%AF%A2%E6%97%B6%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>排序很简单，默认是按照查询文档的相关度来排序的，即（_score 字段）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET books/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;term&quot;: &#123;</span><br><span class="line">      &quot;name&quot;: &#123;</span><br><span class="line">        &quot;value&quot;: &quot;java&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>等价于：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET books/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;term&quot;: &#123;</span><br><span class="line">      &quot;name&quot;: &#123;</span><br><span class="line">        &quot;value&quot;: &quot;java&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;sort&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;_score&quot;: &#123;</span><br><span class="line">        &quot;order&quot;: &quot;desc&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>match_all 查询只是返回所有文档，不评分，<strong>默认按照添加顺序返回</strong>，可以通过 _doc 字段对其进行排序：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET books/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match_all&quot;: &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;sort&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;_doc&quot;: &#123;</span><br><span class="line">        &quot;order&quot;: &quot;desc&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  &quot;size&quot;: 20</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>es 同时也支持多字段排序。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET books/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match_all&quot;: &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;sort&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;price&quot;: &#123;</span><br><span class="line">        &quot;order&quot;: &quot;asc&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;_doc&quot;: &#123;</span><br><span class="line">        &quot;order&quot;: &quot;desc&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  &quot;size&quot;: 20</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>按时间倒序排序</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET xxindex/_search</span><br><span class="line">&#123;</span><br><span class="line">    &quot;sort&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;wtime&quot;: &#123;</span><br><span class="line">        &quot;order&quot;: &quot;desc&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>es</tag>
      </tags>
  </entry>
  <entry>
    <title>elasticsearch添加字段</title>
    <url>/2023/08/06/ES/elasticsearch%E6%B7%BB%E5%8A%A0%E5%AD%97%E6%AE%B5/</url>
    <content><![CDATA[<h2 id="elasticsearch添加字段（es7后推荐）"><a href="#elasticsearch添加字段（es7后推荐）" class="headerlink" title="elasticsearch添加字段（es7后推荐）"></a>elasticsearch添加字段（es7后推荐）</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PUT /索引名/_mapping</span><br><span class="line">&#123;</span><br><span class="line">  &quot;properties&quot;: &#123;</span><br><span class="line">    &quot;字段1&quot;: &#123;</span><br><span class="line">      &quot;type&quot;: &quot;float&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;字段2&quot;: &#123;</span><br><span class="line">      &quot;type&quot;: &quot;keyword&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;字段3&quot;: &#123;</span><br><span class="line">      &quot;type&quot;: &quot;text&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="Elasticsearch-Mapping增加一个新字段"><a href="#Elasticsearch-Mapping增加一个新字段" class="headerlink" title="Elasticsearch Mapping增加一个新字段"></a>Elasticsearch Mapping增加一个新字段</h2><p>在已经存有大量数据的ES索引中，向一个type中添加一个新字段。<br>说明，uploadusagestats是index，usagestats是type</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PUT http://host/uploadusagestats/_mapping/usagestats</span><br><span class="line">&#123;</span><br><span class="line">    &quot;properties&quot;:&#123;</span><br><span class="line">       &quot;last_time_used&quot;:&#123;</span><br><span class="line">            &quot;type&quot; : &quot;date&quot;, </span><br><span class="line">            &quot;format&quot;: &quot;yyyy-MM-dd HH:mm:ss||yyyy-MM-dd||epoch_millis&quot;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="note"><a href="#note" class="headerlink" title="note"></a>note</h2><blockquote>
<p>Before 7.0.0, the mappings definition used to include a type name. Although specifying types in requests is now deprecated, a type can still be provided if the request parameter include_type_name is set. For more details, please see Removal of mapping types.</p>
</blockquote>
]]></content>
      <tags>
        <tag>es</tag>
      </tags>
  </entry>
  <entry>
    <title>pretty的作用</title>
    <url>/2023/08/06/ES/pretty%E7%9A%84%E4%BD%9C%E7%94%A8/</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -XPOST &#x27;localhost:9200/bank/account/_bulk?pretty&#x27; </span><br></pre></td></tr></table></figure>
<p>pretty是将返回的信息以可读的JSON形式返回。</p>
]]></content>
      <tags>
        <tag>es</tag>
      </tags>
  </entry>
  <entry>
    <title>ES常用查询</title>
    <url>/2023/08/06/ES/ES%E5%B8%B8%E7%94%A8%E6%9F%A5%E8%AF%A2/</url>
    <content><![CDATA[<h2 id="1-全文级别查询"><a href="#1-全文级别查询" class="headerlink" title="1.全文级别查询"></a>1.全文级别查询</h2><p>match 是一个标准查询，传给match查询的词条将被建立索引时相同的分析器处理，可以查询文本、数字、日期格式的数据。match 查询的一个主要用途是全文检索。ES 5.X 以上的版本默认使用BM25算法进行相似度的计算。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /_search</span><br><span class="line">&#123;</span><br><span class="line">    &quot;query&quot;: &#123;</span><br><span class="line">        &quot;match&quot; : &#123;</span><br><span class="line">            &quot;message&quot; : &quot;hello world&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>match_phrase 与match查询不同，它是精确匹配</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /_search</span><br><span class="line">&#123;</span><br><span class="line">    &quot;query&quot;: &#123;</span><br><span class="line">        &quot;match_phrase&quot; : &#123;</span><br><span class="line">            &quot;message&quot; : &quot;this is a test&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>multi_match 允许在做match 查询的基础上查询多个字段</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /_search</span><br><span class="line">&#123;</span><br><span class="line">    &quot;query&quot;:&#123;</span><br><span class="line">         &quot;multi_match&quot;: &#123;</span><br><span class="line">            &quot;query&quot;:    &quot;full text search&quot;,</span><br><span class="line">            &quot;fields&quot;:   [ &quot;title&quot;, &quot;body&quot; ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-词条级别查询"><a href="#2-词条级别查询" class="headerlink" title="2.词条级别查询"></a>2.词条级别查询</h2><p>term 用于精确值的查询，代表完全匹配，不进行分词器分析。使用boost参数可以提高指定字段的分数。boost的默认值为1。</p>
<p>string类型的数据在ES中可以使用text或者keyword的类型来存储。++<strong>ES存储text类型的数据时会自动分词，然后建立索引。keyword存储数据时，不会分词，直接建立索引</strong>++。如果需要对string数据进行精确查询，应该使用keyword的类型来存储数据。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /_search</span><br><span class="line">&#123;</span><br><span class="line">    &quot;query&quot;:&#123;</span><br><span class="line">        &quot;bool&quot;:&#123;</span><br><span class="line">            &quot;should&quot;:[</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;term&quot;:&#123;</span><br><span class="line">                        &quot;status&quot;:&#123;</span><br><span class="line">                            &quot;value&quot;:&quot;urgent&quot;,</span><br><span class="line">                            &quot;boost&quot;:2</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;term&quot;:&#123;</span><br><span class="line">                        &quot;status&quot;:&quot;normal&quot;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>terms 可以指定一个字段的多个精确值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /_search</span><br><span class="line">&#123;</span><br><span class="line">    &quot;query&quot;: &#123;</span><br><span class="line">        &quot;constant_score&quot; : &#123;</span><br><span class="line">            &quot;filter&quot; : &#123;</span><br><span class="line">                &quot;terms&quot; : &#123; &quot;user&quot; : [&quot;kimchy&quot;, &quot;elasticsearch&quot;]&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>range 用于需要查询指定范围的内容。range 的常用参数有gte (greater-than or equal to), gt (greater-than) ,lte (less-than or equal to) 和 lt (less-than)。ES 的date类型的数值也可以使用range查询。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /_search</span><br><span class="line">&#123;</span><br><span class="line">    &quot;query&quot;: &#123;</span><br><span class="line">        &quot;range&quot; : &#123;</span><br><span class="line">            &quot;age&quot; : &#123;</span><br><span class="line">                &quot;gte&quot; : 10,</span><br><span class="line">                &quot;lte&quot; : 20,</span><br><span class="line">                &quot;boost&quot; : 2.0</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>exists 返回字段非空值的文档(至少一个)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /_search</span><br><span class="line">&#123;</span><br><span class="line">    &quot;query&quot;: &#123;</span><br><span class="line">        &quot;exists&quot; : &#123; &quot;field&quot; : &quot;user&quot; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>prefix 前缀查询</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /_search</span><br><span class="line">&#123;</span><br><span class="line">    &quot;query&quot;: &#123;</span><br><span class="line">        &quot;prefix&quot;: &#123;</span><br><span class="line">            &quot;postcode&quot;: &quot;W1&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>全文级别相当于全局搜索，类似于数据库的逐条记录匹配。词条级别相当于在字段上添加了筛选条件进行过滤。</p>
<h2 id="3-复合查询"><a href="#3-复合查询" class="headerlink" title="3.复合查询"></a>3.复合查询</h2><p>bool 查询可以合并多个过滤条件查询的结果。bool 查询可由 must, should, must not, filter 组合完成</p>
<ul>
<li>must 检索到的文档必须要包含查询的内容，并且会计算文档匹配的相关度</li>
<li>filter 检索到的文档必须要包含查询的内容。与must不同，filter中的查询条件不会参与评分。++<strong>filter对查询的数据有缓存功能。filter效率会比must高一些，一般，除了需要计算相关度的查询，一般使用filter</strong>++</li>
<li>should 至少有一个查询条件匹配，相当于 or</li>
<li>must_mot 多个查询条件的相反匹配，相当于 not</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /_search</span><br><span class="line">&#123;</span><br><span class="line">    &quot;query&quot;:&#123;</span><br><span class="line">        &quot;bool&quot;:&#123;</span><br><span class="line">            &quot;must&quot;:&#123;</span><br><span class="line">                &quot;term&quot;:&#123;</span><br><span class="line">                    &quot;user&quot;:&quot;kimchy&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;filter&quot;:&#123;</span><br><span class="line">                &quot;term&quot;:&#123;</span><br><span class="line">                    &quot;tag&quot;:&quot;tech&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;must_not&quot;:&#123;</span><br><span class="line">                &quot;range&quot;:&#123;</span><br><span class="line">                    &quot;age&quot;:&#123;</span><br><span class="line">                        &quot;gte&quot;:10,</span><br><span class="line">                        &quot;lte&quot;:20</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;should&quot;:[</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;term&quot;:&#123;</span><br><span class="line">                        &quot;tag&quot;:&quot;wow&quot;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;term&quot;:&#123;</span><br><span class="line">                        &quot;tag&quot;:&quot;elasticsearch&quot;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>es</tag>
      </tags>
  </entry>
  <entry>
    <title>查看ES集群所有索引</title>
    <url>/2023/08/06/ES/%E6%9F%A5%E7%9C%8BES%E9%9B%86%E7%BE%A4%E6%89%80%E6%9C%89%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<p>使用命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET _cat/indices?v&amp;pretty</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>es</tag>
      </tags>
  </entry>
  <entry>
    <title>进行修改操作时ES日期格式保存报错</title>
    <url>/2023/08/06/ES/%E8%BF%9B%E8%A1%8C%E4%BF%AE%E6%94%B9%E6%93%8D%E4%BD%9C%E6%97%B6ES%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F%E4%BF%9D%E5%AD%98%E6%8A%A5%E9%94%99/</url>
    <content><![CDATA[<h2 id="报错信息如下"><a href="#报错信息如下" class="headerlink" title="报错信息如下"></a>报错信息如下</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[MapperParsingException[failed to parse [lastmodifytime]]; nested: IllegalArgumentException[Invalid format: &quot;2021-01-04T01:23:27.052Z&quot; is malformed at &quot;T01:23:27.052Z&quot;]</span><br></pre></td></tr></table></figure>
<h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>日期格式与ES mapping中的不同，若ES中设置了format则需要按照format指定的格式存储。</p>
<h2 id="ES-mapping的设置如下"><a href="#ES-mapping的设置如下" class="headerlink" title="ES mapping的设置如下"></a>ES mapping的设置如下</h2><p><img  
                     lazyload
                     alt="image"
                     data-src="https://note.youdao.com/yws/res/1798/EC98AA71D8B540099DB278BD1FD46033"
                      alt="image"
                ></p>
<h2 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h2><p>在进行更新操作时，将日期类型字段对应的值先格式化为mapping中配置的格式后再更新。<br><img  
                     lazyload
                     alt="image"
                     data-src="https://note.youdao.com/yws/res/1808/2256FE21CCB14AC4A6B7BD98EE90856B"
                      alt="image"
                ></p>
]]></content>
      <tags>
        <tag>es</tag>
      </tags>
  </entry>
  <entry>
    <title>Collector.toMap出现的Duplicatekey问题</title>
    <url>/2023/08/06/Java%E5%9F%BA%E7%A1%80/Collector.toMap%E5%87%BA%E7%8E%B0%E7%9A%84Duplicatekey%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>当键值重复时会抛出异常：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java.lang.IllegalStateException: Duplicate key ...</span><br></pre></td></tr></table></figure>

<p>原因是默认的解决key重复的方法是抛出异常</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; BinaryOperator&lt;T&gt; <span class="title function_">throwingMerger</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (u,v) -&gt; &#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(String.format(<span class="string">&quot;Duplicate key %s&quot;</span>, u)); &#125;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a><strong>解决方法</strong></h1><p>自定义键冲突解决方法如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collectors.toMap(item -&gt; item, item -&gt; item, (oldVal, newVal) -&gt; newVal);</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>ConcurrentHashMapget方法空指针异常</title>
    <url>/2023/08/06/Java%E5%9F%BA%E7%A1%80/ConcurrentHashMapget%E6%96%B9%E6%B3%95%E7%A9%BA%E6%8C%87%E9%92%88%E5%BC%82%E5%B8%B8/</url>
    <content><![CDATA[<ol>
<li>原因：ConcurrentHashMap不允许null key和null value。</li>
<li>补充：hashMap和linkedhashMap都允许null key和null value，treeMap不允许null key，但允许null value，而ConcurrentHashMap既不允许null key也不允许null value</li>
</ol>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Optional的使用</title>
    <url>/2023/08/06/Java%E5%9F%BA%E7%A1%80/Optional%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="使用目的"><a href="#使用目的" class="headerlink" title="使用目的"></a>使用目的</h1><p>减少if空判断</p>
<h1 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Optional.ofNullable(变量).ifPresent(lambda表达式)</span><br></pre></td></tr></table></figure>
<h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>一条语句完成，感觉也可以使用三元运算符。虽然if大多数时候可以被替换掉，但是一下情况还是使用if比较方便</p>
<ul>
<li>在函数return结束方法,或return返回值等时，if不可被optional替换。</li>
<li>在有异常需要捕获处理时，使用lambda表达式会把异常信息给隐藏掉，外层获取不到</li>
</ul>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>关于ES路由的一些思考</title>
    <url>/2023/08/06/ES/%E5%85%B3%E4%BA%8EES%E8%B7%AF%E7%94%B1%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/</url>
    <content><![CDATA[<h1 id="为什么使用默认的路由规则时，分片数量不要改变？"><a href="#为什么使用默认的路由规则时，分片数量不要改变？" class="headerlink" title="为什么使用默认的路由规则时，分片数量不要改变？"></a>为什么使用默认的路由规则时，分片数量不要改变？</h1><p>路由算法为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shard = hash(routing) % number_of_primary_shards</span><br></pre></td></tr></table></figure>
<p>routing默认为文档_id，number_of_primary_shards为主分片数<br>若增加主分片数，<strong>在_id确定的情况下，计算出的分片位置会发生变化</strong>，从而导致读取失败。</p>
<h1 id="为什么使用默认的路由规则时，检索时无法知道文档存储在哪个分片上？"><a href="#为什么使用默认的路由规则时，检索时无法知道文档存储在哪个分片上？" class="headerlink" title="为什么使用默认的路由规则时，检索时无法知道文档存储在哪个分片上？"></a>为什么使用默认的路由规则时，检索时无法知道文档存储在哪个分片上？</h1><p>查询时<strong>不使用_id</strong>进行查询，那么就无法知道数据存储在哪个分片上，需要广播到所有分片上查询，若使用_id查询那么应该可以知道存储数据的分片位置，直接在那个分片上查询即可，可以提升查询效率</p>
]]></content>
      <tags>
        <tag>es</tag>
      </tags>
  </entry>
  <entry>
    <title>finally和return</title>
    <url>/2023/08/06/Java%E5%9F%BA%E7%A1%80/finally%E5%92%8Creturn/</url>
    <content><![CDATA[<ol>
<li>当 try 代码块和 catch 代码块中有 return 语句时，finally 仍然会被执行。</li>
<li><strong>执行 try 代码块或 catch 代码块中的 return 语句之前，都会先执行 finally 语句</strong>。</li>
<li><strong>无论在 finally 代码块中是否修改返回值，返回值都不会改变，仍然是执行 finally 代码块之前的值</strong>。</li>
<li>finally 代码块中的 return 语句一定会执行。</li>
</ol>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>int与null比较</title>
    <url>/2023/08/06/Java%E5%9F%BA%E7%A1%80/int%E4%B8%8Enull%E6%AF%94%E8%BE%83/</url>
    <content><![CDATA[<p>int与null比较会报错<br><br><br>可以使用Integer进行比较</p>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>java读取一行数据</title>
    <url>/2023/08/06/Java%E5%9F%BA%E7%A1%80/java%E8%AF%BB%E5%8F%96%E4%B8%80%E8%A1%8C%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<h1 id="StringReader"><a href="#StringReader" class="headerlink" title="StringReader"></a>StringReader</h1><p>首先构建一个StringReader对象</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">StringReader stringReader = new StringReader(&quot;key=Hello\nvalue=world&quot;);</span><br></pre></td></tr></table></figure>
<h1 id="BufferedReader"><a href="#BufferedReader" class="headerlink" title="BufferedReader"></a>BufferedReader</h1><p>使用StringReader对象构建BufferedReader对象</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BufferedReader bufferedReader = new BufferedReader(stringReader);</span><br></pre></td></tr></table></figure>
<h1 id="调用bufferedReader-readLine"><a href="#调用bufferedReader-readLine" class="headerlink" title="调用bufferedReader.readLine()"></a>调用bufferedReader.readLine()</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String line = &quot;&quot;;</span><br><span class="line">while ((line = bufferedReader.readLine()) != null) &#123;</span><br><span class="line">	System.out.println(line);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><p>readline方法读取到\n后会认为该行结束。</p>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>java获取当年第一天及最后一天</title>
    <url>/2023/08/06/Java%E5%9F%BA%E7%A1%80/java%E8%8E%B7%E5%8F%96%E5%BD%93%E5%B9%B4%E7%AC%AC%E4%B8%80%E5%A4%A9%E5%8F%8A%E6%9C%80%E5%90%8E%E4%B8%80%E5%A4%A9/</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 取得当年第一天凌晨0:00时间</span><br><span class="line"> *</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public static Date getThisYearFirst() &#123;</span><br><span class="line">	Calendar cal = Calendar.getInstance();</span><br><span class="line">	Calendar calFirstDay = new GregorianCalendar(cal.get(Calendar.YEAR), 0, 1);</span><br><span class="line">	return calFirstDay.getTime();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 取得当年最后一天23:59:59时间</span><br><span class="line"> *</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public static Date getThisYearLast() &#123;</span><br><span class="line">	Calendar cal = Calendar.getInstance();</span><br><span class="line">	Calendar calLastDay = new GregorianCalendar(cal.get(Calendar.YEAR), 11, 31);</span><br><span class="line">	calLastDay.set(Calendar.HOUR_OF_DAY, 23);</span><br><span class="line">	calLastDay.set(Calendar.MINUTE, 59);</span><br><span class="line">	calLastDay.set(Calendar.SECOND, 59);</span><br><span class="line">	return calLastDay.getTime();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>list转成map</title>
    <url>/2023/08/06/Java%E5%9F%BA%E7%A1%80/list%E8%BD%AC%E6%88%90map/</url>
    <content><![CDATA[<h1 id="使用java8中的stream"><a href="#使用java8中的stream" class="headerlink" title="使用java8中的stream"></a>使用java8中的stream</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Map&lt;String, MaterialInfoVo&gt; materialInfoVoMap = materialInfoVos.stream()</span><br><span class="line">					.collect(Collectors.toMap(MaterialInfoVo::getMaterialId, materialInfoVo -&gt; materialInfoVo));</span><br></pre></td></tr></table></figure>
<p>toMap()中的两个参数，<strong>第一个用于指定key,第二个用于指定value</strong>。这种方式的好处是代码简洁，一行代码即可代替遍历循环。</p>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>stream的map、flatmap</title>
    <url>/2023/08/06/Java%E5%9F%BA%E7%A1%80/stream%E7%9A%84map%E3%80%81flatmap/</url>
    <content><![CDATA[<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">List&lt;Employee&gt; maped = employees.stream()</span><br><span class="line">            .map(e -&gt; &#123;</span><br><span class="line">                e.setAge(e.getAge() + 1);</span><br><span class="line">                e.setGender(e.getGender().equals(&quot;M&quot;)?&quot;male&quot;:&quot;female&quot;);</span><br><span class="line">                return e;</span><br><span class="line">            &#125;).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">List&lt;Employee&gt; maped = employees.stream()</span><br><span class="line">        .peek(e -&gt; &#123;</span><br><span class="line">            e.setAge(e.getAge() + 1);</span><br><span class="line">            e.setGender(e.getGender().equals(&quot;M&quot;)?&quot;male&quot;:&quot;female&quot;);</span><br><span class="line">        &#125;).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">System.out.println(maped);</span><br></pre></td></tr></table></figure>




<p>由于map的参数e就是返回值，所以可以用peek函数。peek函数是一种特殊的map函数，<strong>当函数没有返回值或者参数就是返回值的时候可以使用peek函数</strong>。</p>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>使用完对象后要手动置为空吗</title>
    <url>/2023/08/06/Java%E5%9F%BA%E7%A1%80/%E4%BD%BF%E7%94%A8%E5%AE%8C%E5%AF%B9%E8%B1%A1%E5%90%8E%E8%A6%81%E6%89%8B%E5%8A%A8%E7%BD%AE%E4%B8%BA%E7%A9%BA%E5%90%97/</url>
    <content><![CDATA[<h1 id="声明的局部变量在使用完后需要手动置为null吗？"><a href="#声明的局部变量在使用完后需要手动置为null吗？" class="headerlink" title="声明的局部变量在使用完后需要手动置为null吗？"></a>声明的局部变量在使用完后需要手动置为null吗？</h1><p>对象使用之后手动设为null，感觉多此一举，使得代码没有之前简洁，会增加一些非业务代码。</p>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>局部变量在方法结束时，对象占用的内存就会被释放。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a class="link"   href="https://note.youdao.com/" >java中 obj&#x3D;null对垃圾回收有用吗<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>如何生成一个唯一数</title>
    <url>/2023/08/06/Java%E5%9F%BA%E7%A1%80/%E5%A6%82%E4%BD%95%E7%94%9F%E6%88%90%E4%B8%80%E4%B8%AA%E5%94%AF%E4%B8%80%E6%95%B0/</url>
    <content><![CDATA[<h1 id="生成系统中的唯一数（单机-）"><a href="#生成系统中的唯一数（单机-）" class="headerlink" title="生成系统中的唯一数（单机~）"></a>生成系统中的唯一数（单机~）</h1><h2 id="方式1"><a href="#方式1" class="headerlink" title="方式1"></a>方式1</h2><p>生成String类型的唯一值使用UUID</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 返回32位的唯一值，用到了 MAC、时间戳、随机数等因素生成</span><br><span class="line">UUID.randomUUID().toString().replace(&quot;-&quot;, &quot;&quot;)</span><br></pre></td></tr></table></figure>
<h2 id="方式2"><a href="#方式2" class="headerlink" title="方式2"></a>方式2</h2><p>生成long类型的唯一值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 获取long型唯一ID</span><br><span class="line"> */</span><br><span class="line">public class UniqueGenerator &#123;</span><br><span class="line"></span><br><span class="line">	private static long tmpID = 0;</span><br><span class="line"></span><br><span class="line">	private static boolean tmpIDLocked = false;</span><br><span class="line"></span><br><span class="line">	public static long getId() &#123;</span><br><span class="line">		long time = 0;</span><br><span class="line">		while (true) &#123;</span><br><span class="line">			if (!tmpIDLocked) &#123;</span><br><span class="line">				tmpIDLocked = true;</span><br><span class="line">				// 当前：（年、月、日、时、分、秒、毫秒）*10000,位数为19位</span><br><span class="line">				time = Long.parseLong(new SimpleDateFormat(&quot;yyMMddhhmmssSSS&quot;).format(new Date())) * 10000;</span><br><span class="line">				if (tmpID &lt; time) &#123;</span><br><span class="line">					tmpID = time;</span><br><span class="line">				&#125; else &#123;</span><br><span class="line">					tmpID = tmpID + 1;</span><br><span class="line">					time = tmpID;</span><br><span class="line">				&#125;</span><br><span class="line">				tmpIDLocked = false;</span><br><span class="line">				return time;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="方式3"><a href="#方式3" class="headerlink" title="方式3"></a>方式3</h2><p>使用对象的hashcode方法，返回一个int类型的唯一值，有出现负数的可能。</p>
<h2 id="Remark"><a href="#Remark" class="headerlink" title="Remark"></a>Remark</h2><h3 id="SimpleDateFormat存在多线程安全问题，多线程环境要额外考虑"><a href="#SimpleDateFormat存在多线程安全问题，多线程环境要额外考虑" class="headerlink" title="SimpleDateFormat存在多线程安全问题，多线程环境要额外考虑"></a>SimpleDateFormat存在多线程安全问题，多线程环境要额外考虑</h3>]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>对集合进行排序</title>
    <url>/2023/08/06/Java%E5%9F%BA%E7%A1%80/%E5%AF%B9%E9%9B%86%E5%90%88%E8%BF%9B%E8%A1%8C%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="jdk默认的排序"><a href="#jdk默认的排序" class="headerlink" title="jdk默认的排序"></a>jdk默认的排序</h1><p>默认为升序</p>
<h1 id="Comparable"><a href="#Comparable" class="headerlink" title="Comparable"></a>Comparable</h1><p>a1,a2两数比较，若a1 &lt; a2则返回-1；若a1 &#x3D; a2，则返回0；若a1 &gt; a2，则返回1</p>
<h2 id="升序排列"><a href="#升序排列" class="headerlink" title="升序排列"></a>升序排列</h2><ol>
<li>a1 &lt; a2，return -1</li>
<li>a1 &#x3D; a2，return 0</li>
<li>a1 &gt; a2，return 1</li>
</ol>
<h2 id="降序排列"><a href="#降序排列" class="headerlink" title="降序排列"></a>降序排列</h2><ol>
<li>a1 &lt; a2，return 1</li>
<li>a1 &#x3D; a2，return 0</li>
<li>a1 &gt; a2，return -1</li>
</ol>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>枚举的使用</title>
    <url>/2023/08/06/Java%E5%9F%BA%E7%A1%80/%E6%9E%9A%E4%B8%BE%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="Enum的特征如下："><a href="#Enum的特征如下：" class="headerlink" title="Enum的特征如下："></a>Enum的特征如下：</h1><ol>
<li>它不能有public的构造函数，这样做可以保证客户代码没有办法新建一个enum的实例。</li>
<li>所有枚举值都是public , static , final的。注意这一点只是针对于枚举值，</li>
<li>我们可以和在普通类里面定义变量一样定义其它任何类型的非枚举变量，这些变量可以用任何你想用的修饰符。</li>
<li>Enum默认实现了java.lang.Comparable接口。<br>1．Enum覆载了了toString方法，因此我们如果<strong>调用Color.Blue.toString()默认返回字符串”Blue”</strong>.</li>
<li><strong>Enum提供了一个valueOf方法，这个方法和toString方法是相对应的。调用valueOf(“Blue”)将返回Color.Blue</strong>.因此我们在自己重写toString方法的时候就要注意到这一点，一把来说应该相对应地重写valueOf方法。</li>
<li>Enum还提供了values方法，这个方法使你能够方便的遍历所有的枚举值。</li>
<li>Enum还有一个oridinal的方法，这个方法返回枚举值在枚举类种的顺序，这个顺序根据枚举值声明的顺序而定，这里Color.Red.ordinal()返回0。</li>
</ol>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>线程中注入服务</title>
    <url>/2023/08/06/Java%E5%9F%BA%E7%A1%80/%E7%BA%BF%E7%A8%8B%E4%B8%AD%E6%B3%A8%E5%85%A5%E6%9C%8D%E5%8A%A1/</url>
    <content><![CDATA[<p>不直接使用@Autowired方式进行注入，使用setter方式进行注入</p>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>线程结束问题</title>
    <url>/2023/08/06/Java%E5%9F%BA%E7%A1%80/%E7%BA%BF%E7%A8%8B%E7%BB%93%E6%9D%9F%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; <span class="number">10</span>; i ++ ) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我是&quot;</span> + i);</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">5</span> ) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;我退出了...&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果在循环中return了，那么线程将会结束</p>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>读取resource文件夹下的文件</title>
    <url>/2023/08/06/Java%E5%9F%BA%E7%A1%80/%E8%AF%BB%E5%8F%96resource%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%8B%E7%9A%84%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="通过ClassLoader读取文件"><a href="#通过ClassLoader读取文件" class="headerlink" title="通过ClassLoader读取文件"></a>通过ClassLoader读取文件</h2><h3 id="ClassLoader-getResourceAsStream-获取文件输入流"><a href="#ClassLoader-getResourceAsStream-获取文件输入流" class="headerlink" title="ClassLoader.getResourceAsStream()获取文件输入流"></a>ClassLoader.getResourceAsStream()获取文件输入流</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.getClass().getClassLoader().getResourceAsStream(<span class="string">&quot;conf.properties&quot;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="ClassLoader-getResourceAsStream-获取文件的URL"><a href="#ClassLoader-getResourceAsStream-获取文件的URL" class="headerlink" title="ClassLoader.getResourceAsStream()获取文件的URL"></a>ClassLoader.getResourceAsStream()获取文件的URL</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取文件的URL</span></span><br><span class="line"><span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> <span class="built_in">this</span>.getClass().getClassLoader().getResource(<span class="string">&quot;json/city_code.json&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> FileUtils.readFileToString(<span class="keyword">new</span> <span class="title class_">File</span>(url.getPath()), StandardCharsets.UTF_8);</span><br></pre></td></tr></table></figure>
<h2 id="通过Class读取文件"><a href="#通过Class读取文件" class="headerlink" title="通过Class读取文件"></a>通过Class读取文件</h2><h3 id="Class-getResourceAsStream-获取文件的输入流"><a href="#Class-getResourceAsStream-获取文件的输入流" class="headerlink" title="Class.getResourceAsStream()获取文件的输入流"></a>Class.getResourceAsStream()获取文件的输入流</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.getClass().getResourceAsStream(<span class="string">&quot;/conf.properties&quot;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="Class-getResourceAsStream-获取文件的URL"><a href="#Class-getResourceAsStream-获取文件的URL" class="headerlink" title="Class.getResourceAsStream()获取文件的URL"></a>Class.getResourceAsStream()获取文件的URL</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> <span class="built_in">this</span>.getClass().getResource(<span class="string">&quot;/json/city_code.json&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> FileUtils.readFileToString(<span class="keyword">new</span> <span class="title class_">File</span>(url.getPath()), StandardCharsets.UTF_8);</span><br></pre></td></tr></table></figure>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><blockquote>
<p>Class.getResourceAsStream() 和 ClassLoader.getResourceAsStream()有一个显著的区别，那就是前者加载的时候需要在文件路径前加一个 “&#x2F;“。</p>
</blockquote>
<h2 id="如何区分要不要加”-“"><a href="#如何区分要不要加”-“" class="headerlink" title="如何区分要不要加”&#x2F;“"></a>如何区分要不要加”&#x2F;“</h2><p>如果通过Class来读取文件，那么路径需要以”&#x2F;“开始。通过ClassLoader或者Spring提供的工具类读取文件其实都不需要在路径前加”&#x2F;“。</p>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>容器中拷贝文件</title>
    <url>/2023/08/06/docker/%E5%AE%B9%E5%99%A8%E4%B8%AD%E6%8B%B7%E8%B4%9D%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="拷贝文件"><a href="#拷贝文件" class="headerlink" title="拷贝文件"></a>拷贝文件</h2><ol>
<li>如何将服务器中的文件复制道容器中，命令是什么</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker cp [OPTIONS] [DEST_PATH] [CONTAINER_ID]:[SRC_PATH] </span><br></pre></td></tr></table></figure>
<ol start="2">
<li>从容器中拷贝文件到宿主机中</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker cp [OPTIONS] [CONTAINER_ID]:[SRC_PATH] [DEST_PATH]</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Git工作区、暂存区和版本库（1）</title>
    <url>/2023/08/06/git/Git%E5%B7%A5%E4%BD%9C%E5%8C%BA%E3%80%81%E6%9A%82%E5%AD%98%E5%8C%BA%E5%92%8C%E7%89%88%E6%9C%AC%E5%BA%93%EF%BC%881%EF%BC%89/</url>
    <content><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>我们先来理解下 Git 工作区、暂存区和版本库概念：</p>
<ul>
<li>工作区：就是你在电脑里能看到的目录。</li>
<li>暂存区：英文叫 stage 或 index。一般存放在 .git 目录下的 index 文件（.git&#x2F;index）中，所以我们把暂存区有时也叫作索引（index）。</li>
<li>版本库：工作区有一个隐藏目录 .git，这个不算工作区，而是 Git 的版本库。<br>下面这个图展示了工作区、版本库中的暂存区和版本库之间的关系：</li>
</ul>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://note.youdao.com/yws/res/4261/166FC6158862462AAC86786D1A7999AD"
                      alt="image"
                ></p>
<ul>
<li><p>图中左侧为工作区，右侧为版本库。在版本库中标记为 “index” 的区域是暂存区（stage&#x2F;index），标记为 “master” 的是 master 分支所代表的目录树。</p>
</li>
<li><p>图中我们可以看出此时 “HEAD” 实际是指向 master 分支的一个”游标”。所以图示的命令中出现 HEAD 的地方可以用 master 来替换。</p>
</li>
<li><p>图中的 objects 标识的区域为 Git 的对象库，实际位于 “.git&#x2F;objects” 目录下，里面包含了创建的各种对象及内容。</p>
</li>
<li><p>当对工作区修改（或新增）的文件执行 git add 命令时，暂存区的目录树被更新，同时工作区修改（或新增）的文件内容被写入到对象库中的一个新的对象中，而该对象的ID被记录在暂存区的文件索引中。</p>
</li>
<li><p>当执行提交操作（git commit）时，暂存区的目录树写到版本库（对象库）中，master 分支会做相应的更新。即 master 指向的目录树就是提交时暂存区的目录树。</p>
</li>
<li><p>当执行 git reset HEAD 命令时，暂存区的目录树会被重写，被 master 分支指向的目录树所替换，但是工作区不受影响。</p>
</li>
<li><p>当执行 git rm –cached <file> 命令时，会直接从暂存区删除文件，工作区则不做出改变。</p>
</li>
<li><p>当执行 git checkout . 或者 git checkout – <file> 命令时，会用暂存区全部或指定的文件替换工作区的文件。这个操作很危险，会清除工作区中未添加到暂存区的改动。</p>
</li>
<li><p>当执行 git checkout HEAD . 或者 git checkout HEAD <file> 命令时，会用 HEAD 指向的 master 分支中的全部或者部分文件替换暂存区和以及工作区中的文件。这个命令也是极具危险性的，因为不但会清除工作区中未提交的改动，也会清除暂存区中未提交的改动。</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Git工作区、暂存区和版本库（2）</title>
    <url>/2023/08/06/git/Git%E5%B7%A5%E4%BD%9C%E5%8C%BA%E3%80%81%E6%9A%82%E5%AD%98%E5%8C%BA%E5%92%8C%E7%89%88%E6%9C%AC%E5%BA%93%EF%BC%882%EF%BC%89/</url>
    <content><![CDATA[<h2 id="四个工作区域"><a href="#四个工作区域" class="headerlink" title="四个工作区域"></a>四个工作区域</h2><p>Git本地有四个工作区域：</p>
<ol>
<li>工作目录（Working Directory）</li>
<li>暂存区(Stage&#x2F;Index)</li>
<li>资源库(Repository或Git Directory)</li>
<li>git仓库(Remote Directory)</li>
</ol>
<p>文件在这四个区域之间的转换关系如下：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://note.youdao.com/yws/res/4280/D762EDD5F2144D889C5CAB2985490F7D"
                      alt="image"
                ></p>
<ul>
<li>Workspace： 工作区，就是你平时存放项目代码的地方</li>
<li>Index &#x2F; Stage： 暂存区，用于临时存放你的改动，事实上它只是一个文件，保存即将提交到文件列表信息</li>
<li>Repository： 仓库区（或版本库），就是安全存放数据的位置，这里面有你提交到所有版本的数据。其中HEAD指向最新放入仓库的版本</li>
<li>Remote： 远程仓库，托管代码的服务器，可以简单的认为是你项目组中的一台电脑用于远程数据交换</li>
</ul>
<h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><p>git的工作流程一般是这样的：</p>
<ol>
<li>在工作目录中添加、修改文件</li>
<li>将需要进行版本管理的文件放入暂存区域</li>
<li>将暂存区域的文件提交到git仓库</li>
</ol>
<p>因此，git管理的文件有三种状态：已修改（modified）,已暂存（staged）,已提交(committed)</p>
<h2 id="文件的四种状态"><a href="#文件的四种状态" class="headerlink" title="文件的四种状态"></a>文件的四种状态</h2><p>版本控制就是对文件的版本控制，要对文件进行修改、提交等操作，首先要知道文件当前在什么状态，不然可能会提交了现在还不想提交的文件，或者要提交的文件没提交上。</p>
<p>git不关心文件两个版本之间的具体差别，而是关心文件的整体是否有改变，若文件被改变，在添加提交时就生成文件新版本的快照，而判断文件整体是否改变的方法就是用SHA-1算法计算文件的校验和。<br><img  
                     lazyload
                     alt="image"
                     data-src="https://note.youdao.com/yws/res/4299/CC593AB22D564164A2A0D1214D73E395"
                      alt="image"
                ></p>
<ul>
<li>Untracked: 未跟踪, 此文件在文件夹中, 但并没有加入到git库, 不参与版本控制. 通过git add 状态变为Staged.</li>
<li>Unmodify: 文件已经入库, 未修改, 即版本库中的文件快照内容与文件夹中完全一致. 这种类型的文件有两种去处, 如果它被修改, 而变为Modified.如果使用git rm移出版本库, 则成为Untracked文件</li>
<li>Modified: 文件已修改, 仅仅是修改, 并没有进行其他的操作. 这个文件也有两个去处, 通过git add可进入暂存staged状态, 使用git checkout 则丢弃修改过,返回到unmodify状态, 这个git checkout即从库中取出文件, 覆盖当前修改</li>
<li>Staged: 暂存状态. 执行git commit则将修改同步到库中, 这时库中的文件和本地文件又变为一致, 文件为Unmodify状态. 执行git reset HEAD filename取消暂存,文件状态为Modified</li>
</ul>
<p> 下面的图很好的解释了这四种状态的转变：<br> <img  
                     lazyload
                     alt="image"
                     data-src="https://note.youdao.com/yws/res/4303/D874BB0F795F4F28BE026EE396318AC1"
                      alt="image"
                ></p>
<ul>
<li>新建文件—&gt;Untracked</li>
<li>使用add命令将新建的文件加入到暂存区—&gt;Staged</li>
<li>使用commit命令将暂存区的文件提交到本地仓库—&gt;Unmodified</li>
<li>如果对Unmodified状态的文件进行修改—&gt; modified</li>
<li>如果对Unmodified状态的文件进行remove操作—&gt;Untracked</li>
</ul>
]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>git修改用户名等配置</title>
    <url>/2023/08/06/git/git%E4%BF%AE%E6%94%B9%E7%94%A8%E6%88%B7%E5%90%8D%E7%AD%89%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="查看git全局配置"><a href="#查看git全局配置" class="headerlink" title="查看git全局配置"></a>查看git全局配置</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config --global --list</span><br></pre></td></tr></table></figure>
<h2 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config --global user.name 你的目标用户名;</span><br><span class="line">git config --global user.email 你的目标邮箱名;</span><br></pre></td></tr></table></figure>
<h2 id="删除全局配置项"><a href="#删除全局配置项" class="headerlink" title="删除全局配置项"></a>删除全局配置项</h2><p>例如：<br><code>git config --global --unset user.name</code></p>
]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>git功能开发流程</title>
    <url>/2023/08/06/git/git%E5%8A%9F%E8%83%BD%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="功能或BUG修复流程"><a href="#功能或BUG修复流程" class="headerlink" title="功能或BUG修复流程"></a>功能或BUG修复流程</h2><p><img  
                     lazyload
                     alt="image"
                     data-src="https://note.youdao.com/yws/res/4206/06FB5ACB60EF4D40B30BA733C5169A05"
                      alt="image"
                ></p>
]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>git常用命令</title>
    <url>/2023/08/07/git/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="新建代码库"><a href="#新建代码库" class="headerlink" title="新建代码库"></a>新建代码库</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 在当前目录新建一个Git代码库</span><br><span class="line">git init</span><br><span class="line"># 新建一个目录，将其初始化为Git代码库</span><br><span class="line">git init [project-name]</span><br><span class="line"># 下载一个项目和它的整个代码历史</span><br><span class="line">git clone [url]</span><br></pre></td></tr></table></figure>
<h2 id="查看文件状态"><a href="#查看文件状态" class="headerlink" title="查看文件状态"></a>查看文件状态</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 查看指定文件状态</span><br><span class="line">git status [filename]</span><br><span class="line"># 查看所有文件状态</span><br><span class="line">git status</span><br></pre></td></tr></table></figure>
<h2 id="工作区暂存区"><a href="#工作区暂存区" class="headerlink" title="工作区&lt;–&gt;暂存区"></a>工作区&lt;–&gt;暂存区</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 添加指定文件到暂存区</span><br><span class="line">git add [file1] [file2] ...</span><br><span class="line"># 添加指定目录到暂存区，包括子目录</span><br><span class="line">git add [dir]</span><br><span class="line"># 添加当前目录的所有文件到暂存区</span><br><span class="line">git add .</span><br><span class="line">#当我们需要删除暂存区或分支上的文件, 同时工作区也不需要这个文件了, 可以使用（⚠️）</span><br><span class="line">git rm file_path</span><br><span class="line">#当我们需要删除暂存区或分支上的文件, 但本地又需要使用, 这个时候直接push那边这个文件就没有，如果push之前重新add那么还是会有。</span><br><span class="line">git rm --cached file_path</span><br><span class="line">#直接加文件名   从暂存区将文件恢复到工作区，如果工作区已经有该文件，则会选择覆盖</span><br><span class="line">#加了【分支名】 +文件名  则表示从分支名为所写的分支名中拉取文件 并覆盖工作区里的文件</span><br><span class="line">git checkout</span><br></pre></td></tr></table></figure>
<h2 id="工作区资源库（版本库）"><a href="#工作区资源库（版本库）" class="headerlink" title="工作区&lt;–&gt;资源库（版本库）"></a>工作区&lt;–&gt;资源库（版本库）</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#将暂存区--&gt;资源库（版本库）</span><br><span class="line">git commit -m &#x27;该次提交说明&#x27;</span><br><span class="line">#如果出现:将不必要的文件commit或者上次提交觉得是错的或者不想改变暂存区内容，</span><br><span class="line">#只是想调整提交的信息，移除不必要的添加到暂存区的文件</span><br><span class="line">git reset HEAD 文件名</span><br><span class="line">#去掉上一次的提交（会直接变成add之前状态）   </span><br><span class="line">git reset HEAD^ </span><br><span class="line">#去掉上一次的提交（变成add之后，commit之前状态） </span><br><span class="line">git reset --soft  HEAD^</span><br></pre></td></tr></table></figure>
<h1 id="远程操作"><a href="#远程操作" class="headerlink" title="远程操作"></a>远程操作</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 取回远程仓库的变化，并与本地分支合并</span><br><span class="line">git pull</span><br><span class="line"># 上传本地指定分支到远程仓库</span><br><span class="line">git push</span><br></pre></td></tr></table></figure>
<h2 id="其他常用命令"><a href="#其他常用命令" class="headerlink" title="其他常用命令"></a>其他常用命令</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 显示当前的Git配置</span><br><span class="line">git config --list</span><br><span class="line"># 编辑Git配置文件</span><br><span class="line">git config -e [--global]</span><br><span class="line">#初次commit之前，需要配置用户邮箱及用户名，使用以下命令：</span><br><span class="line">git config --global user.email &quot;you@example.com&quot;</span><br><span class="line">git config --global user.name &quot;Your Name&quot;</span><br><span class="line">#调出Git的帮助文档</span><br><span class="line">git --help</span><br><span class="line">#查看某个具体命令的帮助文档</span><br><span class="line">git +命令 --help</span><br><span class="line">#查看git的版本</span><br><span class="line">git --version</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>撤回不想push的commit</title>
    <url>/2023/08/07/git/%E6%92%A4%E5%9B%9E%E4%B8%8D%E6%83%B3push%E7%9A%84commit/</url>
    <content><![CDATA[<ol>
<li>使用git log查看提交历史</li>
<li>获取到commitId</li>
<li>使用命令如下命令</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git reset --hard commitId</span><br></pre></td></tr></table></figure>

<p>之后git log中不再有上次不想提交的commit记录</p>
]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>新增的空文件夹无法提交问题</title>
    <url>/2023/08/07/git/%E6%96%B0%E5%A2%9E%E7%9A%84%E7%A9%BA%E6%96%87%E4%BB%B6%E5%A4%B9%E6%97%A0%E6%B3%95%E6%8F%90%E4%BA%A4%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>git管理的是文件，新建文件夹git肯定扫描不到变化的。在文件夹里面新增一个文件，就可以了。</p>
]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>注意事项</title>
    <url>/2023/08/07/git/%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</url>
    <content><![CDATA[<ol>
<li><strong>多人共同开发同一个任务需求时</strong>，由其中一人打好功能分支上传至远程仓库供他人下载，所有开发这个需求的开发人员都使用这个功能分支进行开发，功能开发完成 代码上传完成后 <strong>再由其中一人提交合并请求即可</strong>。</li>
<li>假设现在没有打realse分支，然后功能分支上开发的代码已经合并到master上了，现在自测后发现代码有问题需要修改，要基于master重新建一个bug修复分支。如果本地无法自测，则提交到master上后再测试。</li>
<li>公共包的版本格式 <strong>1+计划号+加数字</strong>，每次修改加1 例如：1.10.1，1.10.2。</li>
<li>功能分支和BUG分支名称最好让人一眼看出是什么功能，属于哪个任务，例如 feature&#x2F;add-user-1523，其中1523为禅道任务ID。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">功能分支：feature/</span><br><span class="line">BUG修复分支：bugfix/</span><br><span class="line">版本上线之后的BUG修复分支:hotfix/</span><br><span class="line">发布分支:release/</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>版本号的分配规则</title>
    <url>/2023/09/07/git/%E7%89%88%E6%9C%AC%E5%8F%B7%E7%9A%84%E5%88%86%E9%85%8D%E8%A7%84%E5%88%99/</url>
    <content><![CDATA[<h2 id="版本号的分配规则"><a href="#版本号的分配规则" class="headerlink" title="版本号的分配规则"></a>版本号的分配规则</h2><p>版本号的分配规则</p>
<p>版本控制策略规定了软件版本号的分配规则，因此指定该策略时应当尽量简单易懂。<br>比如在用x.y.z格式进行版本管理时的规则如下所示：</p>
<ul>
<li>x在重大功能变更或新版本不向下兼容时加1，此时y与z的数字归0</li>
<li>y在添加新功能或者删除已有功能时加1，此时z的数字归0（版本发布，对应计划号）</li>
<li>z只在进行内部修改后加1</li>
</ul>
<p>示例：</p>
<ul>
<li>1.0.0：最初发布的版本</li>
<li>1.0.1：修正了轻微的BUG</li>
<li>1.0.2：修复漏洞</li>
<li>1.1.0：新版本发布</li>
<li>2.0.0：更新整体UI或者重构</li>
</ul>
]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Param注解</title>
    <url>/2023/09/06/mybatis/@Param%E6%B3%A8%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>当方法有多个参数时，这个注解可以用来为每一个参数指定一个名字。否则，多个参数将会以他们的顺序位置被命名，默认为#{param1}、#{param2}等，使用@Param(“person”),参数应该被命名为 #{person}</p>
<h2 id="单个参数可以不使用该注解"><a href="#单个参数可以不使用该注解" class="headerlink" title="单个参数可以不使用该注解"></a>单个参数可以不使用该注解</h2>]]></content>
      <tags>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>mybatis-plus分页查询</title>
    <url>/2023/09/06/mybatis/mybatis-plus%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2/</url>
    <content><![CDATA[<p>在mapper接口中定义IPage参数即可</p>
]]></content>
      <tags>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>mybatis打印sql</title>
    <url>/2023/09/06/mybatis/mybatis%E6%89%93%E5%8D%B0sql/</url>
    <content><![CDATA[<p>在application.properties中添加如下配置</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># mybatis-plus配置控制台打印完整带参数SQL语句</span></span><br><span class="line"><span class="string">mybatis-plus.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>mybatis的xml文件中使用比较符</title>
    <url>/2023/09/06/mybatis/mybatis%E7%9A%84xml%E6%96%87%E4%BB%B6%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%AF%94%E8%BE%83%E7%AC%A6/</url>
    <content><![CDATA[<p>在通过mybatis的xml格式处理sql语句时，经常会用到&lt; ，&lt;&#x3D;，&gt;，&gt;&#x3D;等符号，但是很容易引起xml格式的错误，这样会导致后台将xml字符串转换为xml文档时报错，从而导致程序错误。</p>
<p>这时由于在xml中有时会将&lt;，&gt;符号作为xml中的格式解析，其实很简单，我们只需作如下替换即可避免上述的错误，转义：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&amp;lt; &lt; 小于号</span><br><span class="line">&amp;gt; &gt; 大于号</span><br><span class="line">&amp;amp; &amp; 和</span><br><span class="line">&amp;apos; &#x27; 单引号</span><br><span class="line">&amp;quot; &quot; 双引号</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql查询某年的数据</title>
    <url>/2023/09/06/mybatis/mysql%E6%9F%A5%E8%AF%A2%E6%9F%90%E5%B9%B4%E7%9A%84%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<p>在Mapper接口方法上加上查询注解</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Select(&quot;SELECT count(*) FROM ctc_rcs_material &quot; +</span><br><span class="line">        &quot;WHERE bcustid = #&#123;customerId&#125; &quot; +</span><br><span class="line">        &quot;and chatbotid = #&#123;chatbotId&#125; &quot; +</span><br><span class="line">        &quot;and deletestatus = 0 &quot; +</span><br><span class="line">        &quot;and DATE_FORMAT(wtime,&#x27;%Y&#x27;) = #&#123;year&#125;&quot;)</span><br></pre></td></tr></table></figure>
<p>直接使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DATE_FORMAT(wtime,&#x27;%Y&#x27;)</span><br></pre></td></tr></table></figure>
<p>字段中的年份</p>
]]></content>
      <tags>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>使用queryWrapper进行条件查询</title>
    <url>/2023/09/06/mybatis/%E4%BD%BF%E7%94%A8queryWrapper%E8%BF%9B%E8%A1%8C%E6%9D%A1%E4%BB%B6%E6%9F%A5%E8%AF%A2/</url>
    <content><![CDATA[<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">queryWrapper.and(query -&gt; query.isNull(<span class="string">&quot;userId&quot;</span>)</span><br><span class="line">.or()</span><br><span class="line">.eq(<span class="string">&quot;userId&quot;</span>, getOnlineUser().getUserId()));</span><br></pre></td></tr></table></figure>
<p>对于复杂的查询条件拼接可以使用lambda表达式进行编写</p>
]]></content>
      <tags>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis的使用场景.md</title>
    <url>/2024/11/19/redis/Redis%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/</url>
    <content><![CDATA[<h2 id="会话存储"><a href="#会话存储" class="headerlink" title="会话存储"></a>会话存储</h2><p>分布式系统、集群中存储用户的token、session信息</p>
<h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><p>在数据量不大且不想引入消息中间件时，可以使用Redis的list结构作为消息队列</p>
<h2 id="排行榜"><a href="#排行榜" class="headerlink" title="排行榜"></a>排行榜</h2><p>寻找top数据，使用Zset，统计访问次数</p>
<h2 id="实时显示在线用户数量"><a href="#实时显示在线用户数量" class="headerlink" title="实时显示在线用户数量"></a>实时显示在线用户数量</h2><p>基于内存进行操作，计算速度快</p>
<h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><p>setnx命令实现分布式锁，确保同一时间只有一个实例在执行任务</p>
<h2 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h2><p>基于bitmap实现，判断数据是否存在</p>
<h2 id="计数器"><a href="#计数器" class="headerlink" title="计数器"></a>计数器</h2><p>用于限制请求的访问频率</p>
<h2 id="购物车数据"><a href="#购物车数据" class="headerlink" title="购物车数据"></a>购物车数据</h2><p>需要频繁的查询和更新，减少数据库的压力、支持高并发、临时数据存储可以过期删除、提供更快的响应及更好的用户体验</p>
]]></content>
  </entry>
  <entry>
    <title>Redis的部署架构有哪些.md</title>
    <url>/2024/11/19/redis/Redis%E7%9A%84%E9%83%A8%E7%BD%B2%E6%9E%B6%E6%9E%84%E6%9C%89%E5%93%AA%E4%BA%9B/</url>
    <content><![CDATA[<h2 id="单实例"><a href="#单实例" class="headerlink" title="单实例"></a>单实例</h2><p>这是最简单的部署方式，适用于小型应用或服务的初期阶段。它易于设置和运行，但如果实例失败或不可用，所有对Redis的客户端调用都会失败，影响系统的整体性能和速度</p>
<h2 id="主从模式-哨兵"><a href="#主从模式-哨兵" class="headerlink" title="主从模式+哨兵"></a>主从模式+哨兵</h2><p>这种部署包括一个主节点和多个从节点，从节点持续复制主节点的数据。这种架构可以扩展读能力，并在主节点不可用时提供故障转移机制。高可用系统避免了单点故障，允许在主从节点之间平滑过渡，而不会丢失数据，并具有自动故障检测和恢复功能</p>
<h2 id="集群模式"><a href="#集群模式" class="headerlink" title="集群模式"></a>集群模式</h2><p>允许通过数据分片在多个Redis节点上水平扩展。它的关键特性包括数据自动分割、高可用性、线性可扩展性和去中心化。Redis Cluster通过哈希槽机制在多个主节点间自动分割数据，每个主节点可以有一个或多个从节点以实现故障容忍</p>
<h2 id="主从模式和集群模式的区别"><a href="#主从模式和集群模式的区别" class="headerlink" title="主从模式和集群模式的区别"></a>主从模式和集群模式的区别</h2><h3 id="数据分片（Sharding）："><a href="#数据分片（Sharding）：" class="headerlink" title="数据分片（Sharding）："></a>数据分片（Sharding）：</h3><ul>
<li><strong>Redis集群</strong>：支持数据分片，数据自动分布到多个节点上，每个节点负责处理一部分数据。这使得Redis集群可以水平扩展，处理更大的数据集和更高的并发请求。</li>
<li><strong>主从模式</strong>：不支持数据分片，所有数据都存储在主节点上，从节点仅用于读取操作和故障转移。这限制了主从模式处理大规模数据和高并发的能力。</li>
</ul>
<h3 id="故障转移（Failover）："><a href="#故障转移（Failover）：" class="headerlink" title="故障转移（Failover）："></a>故障转移（Failover）：</h3><ul>
<li>Redis集群：具有自动故障转移机制，当主节点发生故障时，集群会自动选举新的主节点，无需人工干预。</li>
<li>主从模式：需要手动配置故障转移，通常使用哨兵（Sentinel）系统来监控主节点的状态，并在主节点故障时进行自动故障转移。</li>
</ul>
<h3 id="性能和扩展性："><a href="#性能和扩展性：" class="headerlink" title="性能和扩展性："></a>性能和扩展性：</h3><ul>
<li>Redis集群：由于数据分片，读和写操作可以分散到多个节点上，提高了性能和吞吐量。适合需要水平扩展的场景。</li>
<li>主从模式：所有写操作都在主节点上执行，可能会成为性能瓶颈。读操作可以在从节点上执行，但仍然受限于单个主节点的处理能力。</li>
</ul>
<h3 id="可用性和冗余："><a href="#可用性和冗余：" class="headerlink" title="可用性和冗余："></a>可用性和冗余：</h3><ul>
<li>Redis集群：每个节点都有多个副本，提高了数据的可用性和冗余性。即使某个节点发生故障，数据仍然可以从其他节点访问。</li>
<li>主从模式：主节点是单点故障源，如果主节点发生故障，需要等待故障转移完成后才能恢复服务。从节点通常不参与写操作，因此不提供写操作的冗余。</li>
</ul>
<h3 id="复杂性和管理："><a href="#复杂性和管理：" class="headerlink" title="复杂性和管理："></a>复杂性和管理：</h3><ul>
<li>Redis集群：配置和管理相对复杂，需要处理节点的自动发现、故障转移和数据迁移等问题。</li>
<li>主从模式：配置和管理相对简单，尤其是在使用哨兵系统时，可以自动处理故障转移。</li>
</ul>
<h3 id="数据一致性："><a href="#数据一致性：" class="headerlink" title="数据一致性："></a>数据一致性：</h3><ul>
<li>Redis集群：由于数据分片，不同节点间的数据一致性需要通过复制协议来保证，可能会有短暂的延迟。</li>
<li>主从模式：数据一致性通过主从复制来保证，从节点的数据是主节点数据的副本，通常延迟较低。</li>
</ul>
<h3 id="成本："><a href="#成本：" class="headerlink" title="成本："></a>成本：</h3><ul>
<li>Redis集群：需要更多的服务器来部署多个节点，增加了硬件和运维成本。</li>
<li>主从模式：通常需要较少的服务器，成本较低，但牺牲了扩展性和容错能力。</li>
</ul>
]]></content>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>centos7查看防火墙</title>
    <url>/2023/09/07/linux/centos7%E6%9F%A5%E7%9C%8B%E9%98%B2%E7%81%AB%E5%A2%99/</url>
    <content><![CDATA[<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 设置开机启用防火墙：</span></span></span><br><span class="line">systemctl enable firewalld.service</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 设置开机禁用防火墙：</span></span></span><br><span class="line">systemctl disable firewalld.service</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 启动防火墙：</span></span></span><br><span class="line">systemctl start firewalld</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 关闭防火墙：</span></span></span><br><span class="line">systemctl stop firewalld</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 检查防火墙状态：</span></span></span><br><span class="line">systemctl status firewalld</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>linux的链接</title>
    <url>/2023/09/07/linux/linux%E7%9A%84%E9%93%BE%E6%8E%A5/</url>
    <content><![CDATA[<ol>
<li>建立软链接<br><code>ln -s 源文件 目标文件</code></li>
<li>查看建立的软连接<br><code>ls -il</code></li>
<li>删除链接<br><code>rm -rf 目标文件</code></li>
</ol>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>linux往文件追加和覆盖内容</title>
    <url>/2023/09/07/linux/linux%E5%BE%80%E6%96%87%E4%BB%B6%E8%BF%BD%E5%8A%A0%E5%92%8C%E8%A6%86%E7%9B%96%E5%86%85%E5%AE%B9/</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt; 是追加内容</span><br><span class="line"></span><br><span class="line">&gt; 是覆盖原有内容</span><br><span class="line"></span><br><span class="line">&lt; 是默认从键盘获得的输入，改成从文件，或者其它打开文件以及设备输入</span><br></pre></td></tr></table></figure>
<p>大于号：将一条命令执行结果（标准输出，或者错误输出，本来都要打印到屏幕上面的）重定向其它输出设备（文件，打开文件操作符，或打印机等等）</p>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>后台运行与不挂起操作</title>
    <url>/2023/09/07/linux/%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C%E4%B8%8E%E4%B8%8D%E6%8C%82%E8%B5%B7%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&amp;：后台运行，当用户退出或关闭终端，则程序会被关闭</span><br><span class="line">nohup：不挂断运行，关闭终端或者用户退出都不会影响，可以一直运行，但是关闭xshell后，就不能够再接收任何输入了</span><br></pre></td></tr></table></figure>
<p>使用Ctrl + C发送SIGINT信号，&amp;后台运行的进程不受影响，nohup运行的进程会被关闭</p>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>1、使用&amp;后台运行程序：</p>
<p>1）结果会输出到终端</p>
<p>2）使用Ctrl + C发送SIGINT信号，程序免疫</p>
<p>3）关闭session发送SIGHUP信号，程序关闭</p>
<p>2、使用nohup运行程序：</p>
<p>1）结果默认会输出到nohup.out</p>
<p>2）使用Ctrl + C发送SIGINT信号，程序关闭</p>
<p>3）关闭session发送SIGHUP信号，程序免疫</p>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>安装vim</title>
    <url>/2023/09/07/linux/%E5%AE%89%E8%A3%85vim/</url>
    <content><![CDATA[<p>1.查看是否安装</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rpm -qa|grep vim</span><br></pre></td></tr></table></figure>
<p>正确安装会返回3条结果</p>
<p>2.如果少了其中的某一条,比如 vim-enhanced的<br>就用命令来安装:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum -y install vim-enhanced </span><br></pre></td></tr></table></figure>

<p>3.如果上面的三条都沒有返回, 可以直接用 命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum -y install vim*</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>找出CPU占用最高的线程</title>
    <url>/2023/09/07/linux/%E6%89%BE%E5%87%BACPU%E5%8D%A0%E7%94%A8%E6%9C%80%E9%AB%98%E7%9A%84%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<p>1.找到进程pid</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jps或者使用ps</span><br></pre></td></tr></table></figure>
<p>2.找出该进程内最耗费CPU的线程</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">top -Hp pid</span><br></pre></td></tr></table></figure>
<p>3.将线程ID转化为16进制</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">printf &quot;%x\n&quot;  线程ID</span><br></pre></td></tr></table></figure>
<p>4.jstack输出进程的堆栈信息</p>
<p>注意：</p>
<ol>
<li>死锁，Deadlock（重点关注）</li>
<li>执行中，Runnable  </li>
<li>等待资源，Waiting on condition（重点关注，等待什么资源）</li>
<li>等待获取监视器，Waiting on monitor entry（重点关注）</li>
<li>暂停，Suspended</li>
<li>对象等待中，Object.wait() 或 TIMED_WAITING</li>
<li>阻塞，Blocked（重点关注） </li>
<li>停止，Parked</li>
</ol>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>虚拟机重启后网络不可用</title>
    <url>/2023/09/07/linux/%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%87%8D%E5%90%AF%E5%90%8E%E7%BD%91%E7%BB%9C%E4%B8%8D%E5%8F%AF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="使用service-network-restart命令报错"><a href="#使用service-network-restart命令报错" class="headerlink" title="使用service network restart命令报错,"></a>使用service network restart命令报错,</h2><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>和 NetworkManager 服务有冲突，这个好解决，直接关闭 NetworkManger 服务就好了</p>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">service NetworkManager stop</span><br><span class="line">## 并且禁止开机启动</span><br><span class="line">chkconfig NetworkManager off </span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>常用命令</title>
    <url>/2023/09/07/linux/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="怎么查询IO磁盘占用了多少？"><a href="#怎么查询IO磁盘占用了多少？" class="headerlink" title="怎么查询IO磁盘占用了多少？"></a>怎么查询IO磁盘占用了多少？</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">top命令、vmstat命令、iostat命令、iotop命令、pt-ioprofile命令</span><br></pre></td></tr></table></figure>

<h1 id="怎么查询内存占用多少？"><a href="#怎么查询内存占用多少？" class="headerlink" title="怎么查询内存占用多少？"></a>怎么查询内存占用多少？</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">free</span><br></pre></td></tr></table></figure>

<h1 id="查看磁盘使用率"><a href="#查看磁盘使用率" class="headerlink" title="查看磁盘使用率"></a>查看磁盘使用率</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">df -h</span><br></pre></td></tr></table></figure>

<h1 id="怎么查询CPU占用？"><a href="#怎么查询CPU占用？" class="headerlink" title="怎么查询CPU占用？"></a>怎么查询CPU占用？</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">top</span><br></pre></td></tr></table></figure>

<h1 id="怎么查询网络连接占用多少？"><a href="#怎么查询网络连接占用多少？" class="headerlink" title="怎么查询网络连接占用多少？"></a>怎么查询网络连接占用多少？</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">netstat -anp</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL的主从同步</title>
    <url>/2024/11/19/mysql/MySQL%E7%9A%84%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5/</url>
    <content><![CDATA[<h2 id="查看binlog配置"><a href="#查看binlog配置" class="headerlink" title="查看binlog配置"></a>查看binlog配置</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show variables like &#x27;log_bin&#x27;</span><br></pre></td></tr></table></figure>
<h2 id="开启binlog配置"><a href="#开启binlog配置" class="headerlink" title="开启binlog配置"></a>开启binlog配置</h2><ol>
<li>修改my.cnf配置文件</li>
<li>重启mysql</li>
</ol>
<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol>
<li>master将数据变更写入二进制日志（binary log），内容记录为binary log events</li>
<li>slave将master的binary log events拷贝到relay log</li>
<li>slave重放relay log中的事件，将数据变更反映到从库中</li>
</ol>
]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>group by在myql与oracle中的异同</title>
    <url>/2023/11/16/mysql/group%20by%E5%9C%A8myql%E4%B8%8Eoracle%E4%B8%AD%E7%9A%84%E5%BC%82%E5%90%8C/</url>
    <content><![CDATA[<h2 id="oracle"><a href="#oracle" class="headerlink" title="oracle"></a>oracle</h2><p>oracle要求查询的字段必须在group by分组后，若查询字段中有group by中没有的字段则查询会报错。</p>
<h2 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h2><p>mysql需要根据sql_mode进行判断，若配置了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ONLY_FULL_GROUP_BY</span><br></pre></td></tr></table></figure>
<p>则与oracle相同，查询字段需为group by中的字段。否则查询列表中的字段没有要求，可以出现group by后没有的字段，查询结果显示分组中的第一条数据。</p>
]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>三大范式.md</title>
    <url>/2024/12/02/mysql/%E4%B8%89%E5%A4%A7%E8%8C%83%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="第一范式"><a href="#第一范式" class="headerlink" title="第一范式"></a>第一范式</h2><p>列要有原子性，不可再分</p>
<h2 id="第二范式"><a href="#第二范式" class="headerlink" title="第二范式"></a>第二范式</h2><p>在第一范式的基础上，要求每一行数据具有唯一性，并且非主键字段完全依赖主键字段；<br>部分依赖指的是非主键字段只依赖主键（复合主键）的一部分</p>
<h2 id="第三范式"><a href="#第三范式" class="headerlink" title="第三范式"></a>第三范式</h2><p>在满足第二范式的基础上，不能存在非主键字段的传递依赖</p>
<h2 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h2><p>防止了数据重复冗余</p>
<h2 id="反模式设计"><a href="#反模式设计" class="headerlink" title="反模式设计"></a>反模式设计</h2><p>适当增加冗余，从而提升查询效率</p>
<h2 id="表设计原则"><a href="#表设计原则" class="headerlink" title="表设计原则"></a>表设计原则</h2><ol>
<li>字段少而精，建议20个左右，过大可以进行拆分（常用字段放在一起，不常用字段独立出去，大字段独立出去）</li>
<li>尽量选用小型字段</li>
<li>避免使用允许为null的字段（a.查询不好优化 b.索引需要额外空间）</li>
<li>合理平衡范式与冗余</li>
<li>如果数据量非常大，可以考虑分库分表</li>
</ol>
]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>如何进行性能优化.md</title>
    <url>/2024/12/02/mysql/%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>数据库如何进行性能优化</p>
<h2 id="可以从哪些方面入手"><a href="#可以从哪些方面入手" class="headerlink" title="可以从哪些方面入手"></a>可以从哪些方面入手</h2><ol>
<li>硬件（硬盘、内存、cpu、网卡）</li>
<li>数据库参数设置（join buffer、sort buffer 设置合理的性能参数）</li>
<li>表结构优化（设计良好的表结构） </li>
<li>sql及索引（编写良好的sql,创建足够高效的索引） </li>
<li>系统架构（读写分离？高可用？实例个数？分库分表？用什么数据库关系型还是非关系型） </li>
<li>业务需求（sql特别复杂，如需要实现同比和环比这些，数据在不断变化，需要实时统计获得）</li>
</ol>
]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>忘记root密码</title>
    <url>/2023/11/16/mysql/%E5%BF%98%E8%AE%B0root%E5%AF%86%E7%A0%81/</url>
    <content><![CDATA[<h2 id="修改数据库配置文件"><a href="#修改数据库配置文件" class="headerlink" title="修改数据库配置文件"></a>修改数据库配置文件</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim  /etc/my.cnf</span><br><span class="line">--  添加如下参数</span><br><span class="line">skip_grant_tables</span><br></pre></td></tr></table></figure>
<h2 id="重启数据库"><a href="#重启数据库" class="headerlink" title="重启数据库"></a>重启数据库</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/* centos 7 */</span><br><span class="line">sudo systemctl start mysql</span><br></pre></td></tr></table></figure>

<h2 id="修改密码"><a href="#修改密码" class="headerlink" title="修改密码"></a>修改密码</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/* MySQL5.7 中修改密码 */</span><br><span class="line">update mysql.user set authentication_string=password(&#x27;123456&#x27;) where user=&#x27;root&#x27; and host=&#x27;localhost&#x27;;</span><br><span class="line">/* 刷新 */</span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure>
<h2 id="还原配置文件"><a href="#还原配置文件" class="headerlink" title="还原配置文件"></a>还原配置文件</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim  /etc/my.cnf</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">skip_grant_tables /* 注释掉该参数*/</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>日期字段类型的比较</title>
    <url>/2023/11/16/mysql/%E6%97%A5%E6%9C%9F%E5%AD%97%E6%AE%B5%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%AF%94%E8%BE%83/</url>
    <content><![CDATA[<p>当将日期类型字段与字符串型日期进行&lt;，&gt;，&gt;&#x3D;，&lt;&#x3D;，between比较的时候，Mysql会将字符串类型日期转换成长整型数字进行比较，从而加快查询速度。</p>
<p>下面三种情况除外：</p>
<ol>
<li>两个表的字段的对比； </li>
<li>日期类型字段与表达式对比； </li>
<li>使用表达式对日期类型字段进行对比</li>
</ol>
<p>原因：对于以上三种情况，mysql会将日期转换为字符串进行比较。</p>
]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>求和两列数据，其中一列可能包含null值</title>
    <url>/2023/11/16/mysql/%E6%B1%82%E5%92%8C%E4%B8%A4%E5%88%97%E6%95%B0%E6%8D%AE%EF%BC%8C%E5%85%B6%E4%B8%AD%E4%B8%80%E5%88%97%E5%8F%AF%E8%83%BD%E5%8C%85%E5%90%ABnull%E5%80%BC/</url>
    <content><![CDATA[<h2 id="现状"><a href="#现状" class="headerlink" title="现状"></a>现状</h2><p>非空值加null值得到的是null</p>
<h2 id="期望"><a href="#期望" class="headerlink" title="期望"></a>期望</h2><p>希望12加上null得到12，而不是null，为此需要将null转换为0值，在MySQL中可以<strong>使用IFNULL()函数</strong>，该函数也是MySQL独有的，它接收两个参数，语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IFNULL(expression, alt_value)</span><br></pre></td></tr></table></figure>

<p>这两个参数都是必传的，其中expression是被用来判断值是否为null的表达式，若为null则返回第二个参数alt_value的值，若不为null则返回expression的值。<br>在上面求和的SQL中使用ifnull()函数，再次做查询操作：</p>
]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>事务的传播行为.md</title>
    <url>/2024/12/02/spring/%E4%BA%8B%E5%8A%A1%E7%9A%84%E4%BC%A0%E6%92%AD%E8%A1%8C%E4%B8%BA/</url>
    <content><![CDATA[<h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><p>Spring框架中定义了七种事务传播行为，这些行为描述了当一个事务方法被另一个事务方法调用时，事务应该如何被处理</p>
<h2 id="七种事务传播行为"><a href="#七种事务传播行为" class="headerlink" title="七种事务传播行为"></a>七种事务传播行为</h2><ol>
<li>REQUIRED：默认值，如果当前存在事务，则加入该事务；如果当前没有事务，就新建一个事务</li>
<li>SUPPORTS：支持当前事务，如果当前存在事务，就加入该事务；如果当前不存在事务，就以非事务方式执行</li>
<li>MANDATORY：支持当前事务，如果当前存在事务，就加入该事务；如果当前不存在事务，则抛出异常</li>
<li>REQUIRES_NEW：创建一个新的事务，无论当前是否存在事务，都创建新事务。如果当前存在事务，把当前事务挂起</li>
<li>NOT_SUPPORTED：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起</li>
<li>NEVER：以非事务方式执行，如果当前存在事务，则抛出异常</li>
<li>NESTED：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则新建一个事务</li>
</ol>
<h2 id="使用事项"><a href="#使用事项" class="headerlink" title="使用事项"></a>使用事项</h2><p>单独记忆NESTED，其他都有对应，如：REQUIRED对REQUIRES_NEW，SUPPORTS对NOT_SUPPORTED，MANDATORY对NEVER</p>
<h2 id="不同传播行为对外层事务的影响"><a href="#不同传播行为对外层事务的影响" class="headerlink" title="不同传播行为对外层事务的影响"></a>不同传播行为对外层事务的影响</h2><h3 id="REQUIRED"><a href="#REQUIRED" class="headerlink" title="REQUIRED"></a>REQUIRED</h3><p>意味着所有调用的方法都会共享同一个事务，如果任何一个方法抛出异常，整个事务（包括内外部事务）都会回滚</p>
<h3 id="SUPPORTS"><a href="#SUPPORTS" class="headerlink" title="SUPPORTS"></a>SUPPORTS</h3><p>如果外部有事务，内部方法会加入；如果外部没有事务，内部方法将独立执行，不创建事务</p>
<h3 id="MANDATORY"><a href="#MANDATORY" class="headerlink" title="MANDATORY"></a>MANDATORY</h3><p>强制要求当前存在事务，如果当前没有事务，则抛出异常。这种传播行为确保了方法总是运行在事务中，如果外部事务不存在，则会抛出异常，不会执行方法</p>
<h3 id="NOT-SUPPORTED"><a href="#NOT-SUPPORTED" class="headerlink" title="NOT_SUPPORTED"></a>NOT_SUPPORTED</h3><p>外部事务在执行此方法时被挂起，内部以非事务方式独立运行，不会有回滚</p>
<h3 id="NEVER"><a href="#NEVER" class="headerlink" title="NEVER"></a>NEVER</h3><p>如果外部事务存在，则会抛出异常</p>
<h3 id="NESTED"><a href="#NESTED" class="headerlink" title="NESTED"></a>NESTED</h3><p>嵌套事务有自己的回滚点，可以独立回滚;但是外部事务回滚时，内部嵌套事务也会回滚。内部事务可以单独回滚，而不影响外部事务</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>综上，只有REQUIRED、SUPPORTS、MANDATORY才对外部事务有回滚的影响，NESTED可用单独回滚不影响外部事务，但是外部事务的回滚会影响嵌套事务的回滚。<br>一般情况下都是使用的默认值即REQUIED，被调用的方法会加入到外部事务中，同外部事务一起回滚。</p>
]]></content>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>类的关系</title>
    <url>/2023/09/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%B1%BB%E7%9A%84%E5%85%B3%E7%B3%BB/</url>
    <content><![CDATA[<h1 id="类的关系"><a href="#类的关系" class="headerlink" title="类的关系"></a>类的关系</h1><h2 id="六种关系"><a href="#六种关系" class="headerlink" title="六种关系"></a>六种关系</h2><p><img  
                     lazyload
                     alt="image"
                     data-src="https://jsd.cdn.zzko.cn/gh/AncyXing/picx-images-hosting@master/20230923/image.47175wtj4cs0.webp"
                      alt="image"
                ></p>
<h2 id="组合与聚合的区别"><a href="#组合与聚合的区别" class="headerlink" title="组合与聚合的区别"></a>组合与聚合的区别</h2><p><img  
                     lazyload
                     alt="image"
                     data-src="https://jsd.cdn.zzko.cn/gh/AncyXing/picx-images-hosting@master/20230923/image.chempfasc7c.webp"
                      alt="image"
                ></p>
<h2 id="关联和聚合的区别"><a href="#关联和聚合的区别" class="headerlink" title="关联和聚合的区别"></a>关联和聚合的区别</h2><p><img  
                     lazyload
                     alt="image"
                     data-src="https://jsd.cdn.zzko.cn/gh/AncyXing/picx-images-hosting@master/20230923/image.4hs2b1n5ghs0.webp"
                      alt="image"
                ></p>
<h2 id="依赖和关联的区别"><a href="#依赖和关联的区别" class="headerlink" title="依赖和关联的区别"></a>依赖和关联的区别</h2><p><img  
                     lazyload
                     alt="image"
                     data-src="https://jsd.cdn.zzko.cn/gh/AncyXing/picx-images-hosting@master/20230923/image.20ffwtg53340.webp"
                      alt="image"
                ></p>
]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>windows查看端口号</title>
    <url>/2023/08/06/windows%E6%9F%A5%E7%9C%8B%E7%AB%AF%E5%8F%A3%E5%8F%B7/index/</url>
    <content><![CDATA[<h2 id="查看端口号占用"><a href="#查看端口号占用" class="headerlink" title="查看端口号占用"></a>查看端口号占用</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">netstat -ano | findstr &quot;端口号&quot;</span><br></pre></td></tr></table></figure>

<h2 id="结束进程"><a href="#结束进程" class="headerlink" title="结束进程"></a>结束进程</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">taskkill -T -F -PID 进程号</span><br></pre></td></tr></table></figure>

<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>在启动应用时，发现端口被占用需要重新启动。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><img  
                     lazyload
                     alt="image"
                     data-src="/images/image-20230806113259568.png"
                      alt="image-20230806113259568"
                ></p>
]]></content>
  </entry>
  <entry>
    <title>桶聚合（bucket）</title>
    <url>/2023/08/06/ES/%E8%81%9A%E5%90%88%E5%88%86%E6%9E%90/%E6%A1%B6%E8%81%9A%E5%90%88%EF%BC%88bucket%EF%BC%89/</url>
    <content><![CDATA[<h2 id="Terms-Aggregation"><a href="#Terms-Aggregation" class="headerlink" title="Terms Aggregation"></a>Terms Aggregation</h2><p>Terms Aggregation 用于分组聚合，例如，统计各个出版社出版的图书总数量:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET books/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;aggs&quot;: &#123;</span><br><span class="line">    &quot;NAME&quot;: &#123;</span><br><span class="line">      &quot;terms&quot;: &#123;</span><br><span class="line">        &quot;field&quot;: &quot;publish&quot;,</span><br><span class="line">        &quot;size&quot;: 20</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>统计结果如下：<br><img  
                     lazyload
                     alt="image"
                     data-src="https://note.youdao.com/yws/res/3880/EDD86C0385664C4A978D6BFF396010BD"
                      alt="image"
                ></p>
<p>在 terms 分桶的基础上，还可以对每个桶进行指标聚合。</p>
<p>统计不同出版社所出版的图书的平均价格：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET books/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;aggs&quot;: &#123;</span><br><span class="line">    &quot;NAME&quot;: &#123;</span><br><span class="line">      &quot;terms&quot;: &#123;</span><br><span class="line">        &quot;field&quot;: &quot;publish&quot;,</span><br><span class="line">        &quot;size&quot;: 20</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;aggs&quot;: &#123;</span><br><span class="line">        &quot;avg_price&quot;: &#123;</span><br><span class="line">          &quot;avg&quot;: &#123;</span><br><span class="line">            &quot;field&quot;: &quot;price&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>统计结果如下：<br><img  
                     lazyload
                     alt="image"
                     data-src="https://note.youdao.com/yws/res/3886/57A79E42D79A408F93889F1C93ADC610"
                      alt="image"
                ></p>
<h2 id="Filter-Aggregation"><a href="#Filter-Aggregation" class="headerlink" title="Filter Aggregation"></a>Filter Aggregation</h2><p>过滤器聚合。可以将符合过滤器中条件的文档分到一个桶中，然后可以求其平均值。</p>
<p>例如查询书名中包含 java 的图书的平均价格：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET books/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;aggs&quot;: &#123;</span><br><span class="line">    &quot;NAME&quot;: &#123;</span><br><span class="line">      &quot;filters&quot;: &#123;</span><br><span class="line">        &quot;filters&quot;: [</span><br><span class="line">          &#123;</span><br><span class="line">            &quot;term&quot;:&#123;</span><br><span class="line">              &quot;name&quot;:&quot;java&quot;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,&#123;</span><br><span class="line">            &quot;term&quot;:&#123;</span><br><span class="line">              &quot;name&quot;:&quot;office&quot;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          ]</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;aggs&quot;: &#123;</span><br><span class="line">        &quot;avg_price&quot;: &#123;</span><br><span class="line">          &quot;avg&quot;: &#123;</span><br><span class="line">            &quot;field&quot;: &quot;price&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Range-Aggregation"><a href="#Range-Aggregation" class="headerlink" title="Range Aggregation"></a>Range Aggregation</h2><p>按照范围聚合，在某一个范围内的文档数统计。<br>例如统计图书价格在 0-50、50-100、100-150、150以上的图书数量：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET books/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;aggs&quot;: &#123;</span><br><span class="line">    &quot;NAME&quot;: &#123;</span><br><span class="line">      &quot;range&quot;: &#123;</span><br><span class="line">        &quot;field&quot;: &quot;price&quot;,</span><br><span class="line">        &quot;ranges&quot;: [</span><br><span class="line">          &#123;</span><br><span class="line">            &quot;to&quot;: 50</span><br><span class="line">          &#125;,&#123;</span><br><span class="line">            &quot;from&quot;: 50,</span><br><span class="line">            &quot;to&quot;: 100</span><br><span class="line">          &#125;,&#123;</span><br><span class="line">            &quot;from&quot;: 100,</span><br><span class="line">            &quot;to&quot;: 150</span><br><span class="line">          &#125;,&#123;</span><br><span class="line">            &quot;from&quot;: 150</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Date-Range-Aggregation"><a href="#Date-Range-Aggregation" class="headerlink" title="Date Range Aggregation"></a>Date Range Aggregation</h2><p>Range Aggregation 也可以用来统计日期，但是也可以使用 Date Range Aggregation，后者的优势在于可以使用日期表达式。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PUT blog/_doc/1</span><br><span class="line">&#123;</span><br><span class="line">  &quot;title&quot;:&quot;java&quot;,</span><br><span class="line">  &quot;date&quot;:&quot;2018-12-30&quot;</span><br><span class="line">&#125;</span><br><span class="line">PUT blog/_doc/2</span><br><span class="line">&#123;</span><br><span class="line">  &quot;title&quot;:&quot;java&quot;,</span><br><span class="line">  &quot;date&quot;:&quot;2020-12-30&quot;</span><br><span class="line">&#125;</span><br><span class="line">PUT blog/_doc/3</span><br><span class="line">&#123;</span><br><span class="line">  &quot;title&quot;:&quot;java&quot;,</span><br><span class="line">  &quot;date&quot;:&quot;2022-10-30&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>统计一年前到一年后的博客数量：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET blog/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;aggs&quot;: &#123;</span><br><span class="line">    &quot;NAME&quot;: &#123;</span><br><span class="line">      &quot;date_range&quot;: &#123;</span><br><span class="line">        &quot;field&quot;: &quot;date&quot;,</span><br><span class="line">        &quot;ranges&quot;: [</span><br><span class="line">          &#123;</span><br><span class="line">            &quot;from&quot;: &quot;now-12M/M&quot;,</span><br><span class="line">            &quot;to&quot;: &quot;now+1y/y&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>12M&#x2F;M 表示 12 个月。</li>
<li>1y&#x2F;y 表示 1年。</li>
<li>d 表示天</li>
</ol>
<h2 id="Date-Histogram-Aggregation"><a href="#Date-Histogram-Aggregation" class="headerlink" title="Date Histogram Aggregation"></a>Date Histogram Aggregation</h2><p>时间直方图聚合。</p>
<p>例如统计各个月份的博客数量</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET blog/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;aggs&quot;: &#123;</span><br><span class="line">    &quot;NAME&quot;: &#123;</span><br><span class="line">      &quot;date_histogram&quot;: &#123;</span><br><span class="line">        &quot;field&quot;: &quot;date&quot;,</span><br><span class="line">        &quot;calendar_interval&quot;: &quot;month&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Missing-Aggregation"><a href="#Missing-Aggregation" class="headerlink" title="Missing Aggregation"></a>Missing Aggregation</h2><p>空值聚合。</p>
<p>统计所有没有 price 字段的文档：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET books/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;aggs&quot;: &#123;</span><br><span class="line">    &quot;NAME&quot;: &#123;</span><br><span class="line">      &quot;missing&quot;: &#123;</span><br><span class="line">        &quot;field&quot;: &quot;price&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Children-Aggregation"><a href="#Children-Aggregation" class="headerlink" title="Children Aggregation"></a>Children Aggregation</h2><p>可以根据父子文档关系进行分桶。</p>
<p><strong>有点云里雾里？</strong></p>
<p>查询子类型为 student 的文档数量：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET stu_class/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;aggs&quot;: &#123;</span><br><span class="line">    &quot;NAME&quot;: &#123;</span><br><span class="line">      &quot;children&quot;: &#123;</span><br><span class="line">        &quot;type&quot;: &quot;student&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Geo-Distance-Aggregation"><a href="#Geo-Distance-Aggregation" class="headerlink" title="Geo Distance Aggregation"></a>Geo Distance Aggregation</h2><p>对地理位置数据做统计。</p>
<p>例如查询(34.288991865037524,108.9404296875)坐标方圆 600KM 和 超过 600KM 的城市数量。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET geo/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;aggs&quot;: &#123;</span><br><span class="line">    &quot;NAME&quot;: &#123;</span><br><span class="line">      &quot;geo_distance&quot;: &#123;</span><br><span class="line">        &quot;field&quot;: &quot;location&quot;,</span><br><span class="line">        &quot;origin&quot;: &quot;34.288991865037524,108.9404296875&quot;,</span><br><span class="line">        &quot;unit&quot;: &quot;km&quot;, </span><br><span class="line">        &quot;ranges&quot;: [</span><br><span class="line">          &#123;</span><br><span class="line">            &quot;to&quot;: 600</span><br><span class="line">          &#125;,&#123;</span><br><span class="line">            &quot;from&quot;: 600</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="IP-Range-Aggregation"><a href="#IP-Range-Aggregation" class="headerlink" title="IP Range Aggregation"></a>IP Range Aggregation</h2><p>IP 地址范围查询。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET blog/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;aggs&quot;: &#123;</span><br><span class="line">    &quot;NAME&quot;: &#123;</span><br><span class="line">      &quot;ip_range&quot;: &#123;</span><br><span class="line">        &quot;field&quot;: &quot;ip&quot;,</span><br><span class="line">        &quot;ranges&quot;: [</span><br><span class="line">          &#123;</span><br><span class="line">            &quot;from&quot;: &quot;127.0.0.5&quot;,</span><br><span class="line">            &quot;to&quot;: &quot;127.0.0.11&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>es</tag>
      </tags>
  </entry>
  <entry>
    <title>管道聚合</title>
    <url>/2023/08/06/ES/%E8%81%9A%E5%90%88%E5%88%86%E6%9E%90/%E7%AE%A1%E9%81%93%E8%81%9A%E5%90%88/</url>
    <content><![CDATA[<p>管道聚合相当于在之前聚合的基础上，再次聚合。</p>
<h2 id="Avg-Bucket-Aggregation"><a href="#Avg-Bucket-Aggregation" class="headerlink" title="Avg Bucket Aggregation"></a>Avg Bucket Aggregation</h2><p> 计算聚合平均值。例如，统计每个出版社所出版图书的平均值，然后再统计所有出版社的平均值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET books/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;aggs&quot;: &#123;</span><br><span class="line">    &quot;book_count&quot;: &#123;</span><br><span class="line">      &quot;terms&quot;: &#123;</span><br><span class="line">        &quot;field&quot;: &quot;publish&quot;,</span><br><span class="line">        &quot;size&quot;: 3</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;aggs&quot;: &#123;</span><br><span class="line">        &quot;book_avg&quot;: &#123;</span><br><span class="line">          &quot;avg&quot;: &#123;</span><br><span class="line">            &quot;field&quot;: &quot;price&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;avg_book&quot;:&#123;</span><br><span class="line">      &quot;avg_bucket&quot;: &#123;</span><br><span class="line">        &quot;buckets_path&quot;: &quot;book_count&gt;book_avg&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Max-Bucket-Aggregation"><a href="#Max-Bucket-Aggregation" class="headerlink" title="Max Bucket Aggregation"></a>Max Bucket Aggregation</h2><p>统计每个出版社所出版图书的平均值，然后再统计平均值中的最大值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET books/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;aggs&quot;: &#123;</span><br><span class="line">    &quot;book_count&quot;: &#123;</span><br><span class="line">      &quot;terms&quot;: &#123;</span><br><span class="line">        &quot;field&quot;: &quot;publish&quot;,</span><br><span class="line">        &quot;size&quot;: 3</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;aggs&quot;: &#123;</span><br><span class="line">        &quot;book_avg&quot;: &#123;</span><br><span class="line">          &quot;avg&quot;: &#123;</span><br><span class="line">            &quot;field&quot;: &quot;price&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;avg_book&quot;:&#123;</span><br><span class="line">      &quot;max_bucket&quot;: &#123;</span><br><span class="line">        &quot;buckets_path&quot;: &quot;book_count&gt;book_avg&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Min-Bucket-Aggregation"><a href="#Min-Bucket-Aggregation" class="headerlink" title="Min Bucket Aggregation"></a>Min Bucket Aggregation</h2><p>统计每个出版社所出版图书的平均值，然后再统计平均值中的最小值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET books/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;aggs&quot;: &#123;</span><br><span class="line">    &quot;book_count&quot;: &#123;</span><br><span class="line">      &quot;terms&quot;: &#123;</span><br><span class="line">        &quot;field&quot;: &quot;publish&quot;,</span><br><span class="line">        &quot;size&quot;: 3</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;aggs&quot;: &#123;</span><br><span class="line">        &quot;book_avg&quot;: &#123;</span><br><span class="line">          &quot;avg&quot;: &#123;</span><br><span class="line">            &quot;field&quot;: &quot;price&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;avg_book&quot;:&#123;</span><br><span class="line">      &quot;min_bucket&quot;: &#123;</span><br><span class="line">        &quot;buckets_path&quot;: &quot;book_count&gt;book_avg&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Sum-Bucket-Aggregation"><a href="#Sum-Bucket-Aggregation" class="headerlink" title="Sum Bucket Aggregation"></a>Sum Bucket Aggregation</h2><p>统计每个出版社所出版图书的平均值，然后再统计平均值之和：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET books/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;aggs&quot;: &#123;</span><br><span class="line">    &quot;book_count&quot;: &#123;</span><br><span class="line">      &quot;terms&quot;: &#123;</span><br><span class="line">        &quot;field&quot;: &quot;publish&quot;,</span><br><span class="line">        &quot;size&quot;: 3</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;aggs&quot;: &#123;</span><br><span class="line">        &quot;book_avg&quot;: &#123;</span><br><span class="line">          &quot;avg&quot;: &#123;</span><br><span class="line">            &quot;field&quot;: &quot;price&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;avg_book&quot;:&#123;</span><br><span class="line">      &quot;sum_bucket&quot;: &#123;</span><br><span class="line">        &quot;buckets_path&quot;: &quot;book_count&gt;book_avg&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Stats-Bucket-Aggregation"><a href="#Stats-Bucket-Aggregation" class="headerlink" title="Stats Bucket Aggregation"></a>Stats Bucket Aggregation</h2><p>统计每个出版社所出版图书的平均值，然后再统计平均值的各种数据：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET books/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;aggs&quot;: &#123;</span><br><span class="line">    &quot;book_count&quot;: &#123;</span><br><span class="line">      &quot;terms&quot;: &#123;</span><br><span class="line">        &quot;field&quot;: &quot;publish&quot;,</span><br><span class="line">        &quot;size&quot;: 3</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;aggs&quot;: &#123;</span><br><span class="line">        &quot;book_avg&quot;: &#123;</span><br><span class="line">          &quot;avg&quot;: &#123;</span><br><span class="line">            &quot;field&quot;: &quot;price&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;avg_book&quot;:&#123;</span><br><span class="line">      &quot;stats_bucket&quot;: &#123;</span><br><span class="line">        &quot;buckets_path&quot;: &quot;book_count&gt;book_avg&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Extended-Stats-Bucket-Aggregation"><a href="#Extended-Stats-Bucket-Aggregation" class="headerlink" title="Extended Stats Bucket Aggregation"></a>Extended Stats Bucket Aggregation</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET books/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;aggs&quot;: &#123;</span><br><span class="line">    &quot;book_count&quot;: &#123;</span><br><span class="line">      &quot;terms&quot;: &#123;</span><br><span class="line">        &quot;field&quot;: &quot;publish&quot;,</span><br><span class="line">        &quot;size&quot;: 3</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;aggs&quot;: &#123;</span><br><span class="line">        &quot;book_avg&quot;: &#123;</span><br><span class="line">          &quot;avg&quot;: &#123;</span><br><span class="line">            &quot;field&quot;: &quot;price&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;avg_book&quot;:&#123;</span><br><span class="line">      &quot;extended_stats_bucket&quot;: &#123;</span><br><span class="line">        &quot;buckets_path&quot;: &quot;book_count&gt;book_avg&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Percentiles-Bucket-Aggregation"><a href="#Percentiles-Bucket-Aggregation" class="headerlink" title="Percentiles Bucket Aggregation"></a>Percentiles Bucket Aggregation</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET books/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;aggs&quot;: &#123;</span><br><span class="line">    &quot;book_count&quot;: &#123;</span><br><span class="line">      &quot;terms&quot;: &#123;</span><br><span class="line">        &quot;field&quot;: &quot;publish&quot;,</span><br><span class="line">        &quot;size&quot;: 3</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;aggs&quot;: &#123;</span><br><span class="line">        &quot;book_avg&quot;: &#123;</span><br><span class="line">          &quot;avg&quot;: &#123;</span><br><span class="line">            &quot;field&quot;: &quot;price&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;avg_book&quot;:&#123;</span><br><span class="line">      &quot;percentiles_bucket&quot;: &#123;</span><br><span class="line">        &quot;buckets_path&quot;: &quot;book_count&gt;book_avg&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>es</tag>
      </tags>
  </entry>
  <entry>
    <title>指标聚合</title>
    <url>/2023/08/06/ES/%E8%81%9A%E5%90%88%E5%88%86%E6%9E%90/%E6%8C%87%E6%A0%87%E8%81%9A%E5%90%88/</url>
    <content><![CDATA[<h1 id="Max-Aggregation"><a href="#Max-Aggregation" class="headerlink" title="Max Aggregation"></a>Max Aggregation</h1><p>统计最大值。例如查询价格最高的书：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET books/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;aggs&quot;: &#123;</span><br><span class="line">    &quot;max_price&quot;: &#123;</span><br><span class="line">      &quot;max&quot;: &#123;</span><br><span class="line">        &quot;field&quot;: &quot;price&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查询结果如下：<br><img  
                     lazyload
                     alt="image"
                     data-src="https://note.youdao.com/yws/res/3813/FDABF921B1C4464FA4B5D85E0575A3F2"
                      alt="image"
                ></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET books/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;aggs&quot;: &#123;</span><br><span class="line">    &quot;max_price&quot;: &#123;</span><br><span class="line">      &quot;max&quot;: &#123;</span><br><span class="line">        &quot;field&quot;: &quot;price&quot;,</span><br><span class="line">        &quot;missing&quot;: 1000</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果某个文档中缺少 price 字段，则设置该字段的值为 1000。</p>
<p>也可以通过脚本来查询最大值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET books/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;aggs&quot;: &#123;</span><br><span class="line">    &quot;max_price&quot;: &#123;</span><br><span class="line">      &quot;max&quot;: &#123;</span><br><span class="line">        &quot;script&quot;: &#123;</span><br><span class="line">          &quot;source&quot;: &quot;if(doc[&#x27;price&#x27;].size()!=0)&#123;doc.price.value&#125;&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用脚本时，可以先通过 doc[‘price’].size()!&#x3D;0 去判断文档是否有对应的属性。</p>
<h2 id="Min-Aggregation"><a href="#Min-Aggregation" class="headerlink" title="Min Aggregation"></a>Min Aggregation</h2><p>统计最小值，用法和 Max Aggregation 基本一致：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET books/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;aggs&quot;: &#123;</span><br><span class="line">    &quot;min_price&quot;: &#123;</span><br><span class="line">      &quot;min&quot;: &#123;</span><br><span class="line">        &quot;field&quot;: &quot;price&quot;,</span><br><span class="line">        &quot;missing&quot;: 1000</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>脚本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET books/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;aggs&quot;: &#123;</span><br><span class="line">    &quot;min_price&quot;: &#123;</span><br><span class="line">      &quot;min&quot;: &#123;</span><br><span class="line">        &quot;script&quot;: &#123;</span><br><span class="line">          &quot;source&quot;: &quot;if(doc[&#x27;price&#x27;].size()!=0)&#123;doc.price.value&#125;&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Avg-Aggregation"><a href="#Avg-Aggregation" class="headerlink" title="Avg Aggregation"></a>Avg Aggregation</h2><p>统计平均值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET books/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;aggs&quot;: &#123;</span><br><span class="line">    &quot;avg_price&quot;: &#123;</span><br><span class="line">      &quot;avg&quot;: &#123;</span><br><span class="line">        &quot;field&quot;: &quot;price&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GET books/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;aggs&quot;: &#123;</span><br><span class="line">    &quot;avg_price&quot;: &#123;</span><br><span class="line">      &quot;avg&quot;: &#123;</span><br><span class="line">        &quot;script&quot;: &#123;</span><br><span class="line">          &quot;source&quot;: &quot;if(doc[&#x27;price&#x27;].size()!=0)&#123;doc.price.value&#125;&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Sum-Aggregation"><a href="#Sum-Aggregation" class="headerlink" title="Sum Aggregation"></a>Sum Aggregation</h2><p> 求和：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET books/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;aggs&quot;: &#123;</span><br><span class="line">    &quot;sum_price&quot;: &#123;</span><br><span class="line">      &quot;sum&quot;: &#123;</span><br><span class="line">        &quot;field&quot;: &quot;price&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GET books/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;aggs&quot;: &#123;</span><br><span class="line">    &quot;sum_price&quot;: &#123;</span><br><span class="line">      &quot;sum&quot;: &#123;</span><br><span class="line">        &quot;script&quot;: &#123;</span><br><span class="line">          &quot;source&quot;: &quot;if(doc[&#x27;price&#x27;].size()!=0)&#123;doc.price.value&#125;&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Cardinality-Aggregation"><a href="#Cardinality-Aggregation" class="headerlink" title="Cardinality Aggregation"></a>Cardinality Aggregation</h2><p>cardinality aggregation 用于基数统计。类似于 SQL 中的 distinct count(0)：</p>
<p>text 类型是分析型类型，默认是不允许进行聚合操作的，如果相对 text 类型进行聚合操作，<strong>需要设置其 fielddata 属性为 true，这种方式虽然可以使 text 类型进行聚合操作</strong>，但是无法满足精准聚合，如果需要精准聚合，可以设置字段的子域为 keyword。</p>
<h3 id="方式一："><a href="#方式一：" class="headerlink" title="方式一："></a>方式一：</h3><p>重新定义 books 索引：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PUT books</span><br><span class="line">&#123;</span><br><span class="line">  &quot;mappings&quot;: &#123;</span><br><span class="line">    &quot;properties&quot;: &#123;</span><br><span class="line">      &quot;name&quot;:&#123;</span><br><span class="line">        &quot;type&quot;: &quot;text&quot;,</span><br><span class="line">        &quot;analyzer&quot;: &quot;ik_max_word&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;publish&quot;:&#123;</span><br><span class="line">        &quot;type&quot;: &quot;text&quot;,</span><br><span class="line">        &quot;analyzer&quot;: &quot;ik_max_word&quot;,</span><br><span class="line">        &quot;fielddata&quot;: true</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;type&quot;:&#123;</span><br><span class="line">        &quot;type&quot;: &quot;text&quot;,</span><br><span class="line">        &quot;analyzer&quot;: &quot;ik_max_word&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;author&quot;:&#123;</span><br><span class="line">        &quot;type&quot;: &quot;keyword&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;info&quot;:&#123;</span><br><span class="line">        &quot;type&quot;: &quot;text&quot;,</span><br><span class="line">        &quot;analyzer&quot;: &quot;ik_max_word&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;price&quot;:&#123;</span><br><span class="line">        &quot;type&quot;: &quot;double&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义完成后，重新插入数据（参考之前的视频）。</p>
<p>接下来就可以查询出版社的总数量：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET books/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;aggs&quot;: &#123;</span><br><span class="line">    &quot;publish_count&quot;: &#123;</span><br><span class="line">      &quot;cardinality&quot;: &#123;</span><br><span class="line">        &quot;field&quot;: &quot;publish&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查询结果如下：<br><img  
                     lazyload
                     alt="image"
                     data-src="https://note.youdao.com/yws/res/3844/015BDD9CD143425BADAB71B6FCC88CDD"
                      alt="image"
                ></p>
<p>这种聚合方式可能会不准确。可以将 publish 设置为 keyword 类型或者设置子域为 keyword。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PUT books</span><br><span class="line">&#123;</span><br><span class="line">  &quot;mappings&quot;: &#123;</span><br><span class="line">    &quot;properties&quot;: &#123;</span><br><span class="line">      &quot;name&quot;:&#123;</span><br><span class="line">        &quot;type&quot;: &quot;text&quot;,</span><br><span class="line">        &quot;analyzer&quot;: &quot;ik_max_word&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;publish&quot;:&#123;</span><br><span class="line">        &quot;type&quot;: &quot;keyword&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;type&quot;:&#123;</span><br><span class="line">        &quot;type&quot;: &quot;text&quot;,</span><br><span class="line">        &quot;analyzer&quot;: &quot;ik_max_word&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;author&quot;:&#123;</span><br><span class="line">        &quot;type&quot;: &quot;keyword&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;info&quot;:&#123;</span><br><span class="line">        &quot;type&quot;: &quot;text&quot;,</span><br><span class="line">        &quot;analyzer&quot;: &quot;ik_max_word&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;price&quot;:&#123;</span><br><span class="line">        &quot;type&quot;: &quot;double&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查询结果如下：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://note.youdao.com/yws/res/3849/7F424B3418DF4F07A96ABBD2DCA48676"
                      alt="image"
                ></p>
<p>对比查询结果可知，使用 fileddata 的方式，查询结果不准确。</p>
<h2 id="Stats-Aggregation"><a href="#Stats-Aggregation" class="headerlink" title="Stats Aggregation"></a>Stats Aggregation</h2><p>基本统计，一次性返回 count、max、min、avg、sum：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET books/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;aggs&quot;: &#123;</span><br><span class="line">    &quot;stats_query&quot;: &#123;</span><br><span class="line">      &quot;stats&quot;: &#123;</span><br><span class="line">        &quot;field&quot;: &quot;price&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://note.youdao.com/yws/res/3858/AF9D5C38FC914C34B65857F9CED65F3C"
                      alt="image"
                ></p>
<h2 id="Extends-Stats-Aggregation"><a href="#Extends-Stats-Aggregation" class="headerlink" title="Extends Stats Aggregation"></a>Extends Stats Aggregation</h2><p>高级统计，比 stats 多出来：平方和、方差、标准差、平均值加减两个标准差的区间：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET books/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;aggs&quot;: &#123;</span><br><span class="line">    &quot;es&quot;: &#123;</span><br><span class="line">      &quot;extended_stats&quot;: &#123;</span><br><span class="line">        &quot;field&quot;: &quot;price&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Percentiles-Aggregation"><a href="#Percentiles-Aggregation" class="headerlink" title="Percentiles Aggregation"></a>Percentiles Aggregation</h2><p>百分位统计。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET books/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;aggs&quot;: &#123;</span><br><span class="line">    &quot;p&quot;: &#123;</span><br><span class="line">      &quot;percentiles&quot;: &#123;</span><br><span class="line">        &quot;field&quot;: &quot;price&quot;,</span><br><span class="line">        &quot;percents&quot;: [</span><br><span class="line">          1,</span><br><span class="line">          5,</span><br><span class="line">          10,</span><br><span class="line">          15,</span><br><span class="line">          25,</span><br><span class="line">          50,</span><br><span class="line">          75,</span><br><span class="line">          95,</span><br><span class="line">          99</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Value-Count-Aggregation"><a href="#Value-Count-Aggregation" class="headerlink" title="Value Count Aggregation"></a>Value Count Aggregation</h2><p>可以按照字段统计文档数量（包含指定字段的文档数量）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET books/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;aggs&quot;: &#123;</span><br><span class="line">    &quot;count&quot;: &#123;</span><br><span class="line">      &quot;value_count&quot;: &#123;</span><br><span class="line">        &quot;field&quot;: &quot;price&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>es</tag>
      </tags>
  </entry>
  <entry>
    <title>类加载过程</title>
    <url>/2023/08/06/Java%E5%9F%BA%E7%A1%80/jvm/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<p><img  
                     lazyload
                     alt="image"
                     data-src="/images/ClassLoadingProcess.png"
                      alt="类加载过程"
                ></p>
<ul>
<li>javac命令进行编译</li>
<li>javap命令进行反编译</li>
</ul>
<h2 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h2><hr>
<ol>
<li>读取类的二进制流</li>
<li>将流转为方法区数据结构，并存放到方法区</li>
<li>在堆中产生Class对象</li>
</ol>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><hr>
<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><h4 id="验证class文件是否符合规范"><a href="#验证class文件是否符合规范" class="headerlink" title="验证class文件是否符合规范"></a>验证class文件是否符合规范</h4><p>文件格式校验</p>
<ul>
<li>是否是0xCAFEBABE开头</li>
<li>版本号是否合理</li>
</ul>
<h4 id="元数据校验"><a href="#元数据校验" class="headerlink" title="元数据校验"></a>元数据校验</h4><ul>
<li>是否有父类</li>
<li>是否继承了final类</li>
<li>非抽象类是否实现了抽象类的所有抽象方法</li>
</ul>
<h4 id="字节码验证"><a href="#字节码验证" class="headerlink" title="字节码验证"></a>字节码验证</h4><ul>
<li>运行检查</li>
<li>跳转指令是否指向合理的位置</li>
</ul>
<h4 id="符号引用验证"><a href="#符号引用验证" class="headerlink" title="符号引用验证"></a>符号引用验证</h4><ul>
<li>常量池中描述类是否存在</li>
<li>访问的方法或字段是否存在且有足够的权限</li>
</ul>
<p>-Xverify:none关闭验证，可以加快启动速度</p>
<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>为类的静态变量分配内存，初始化</p>
<ul>
<li>final static修饰的变量直接赋值</li>
<li>static修改的变量为默认值</li>
</ul>
<h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>将符号引用转换成直接引用</p>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><hr>
<h3 id="执行clinit方法"><a href="#执行clinit方法" class="headerlink" title="执行clinit方法"></a>执行clinit方法</h3><p>编译器自动收集类里面<strong>所有静态变量的赋值操作以及静态语句块</strong>（类构造器方法）</p>
<ul>
<li>初始化的顺序和源文件中的顺序一致</li>
<li>如果有父类，会先调用父类的类构造器方法</li>
</ul>
<h3 id="调用init方法"><a href="#调用init方法" class="headerlink" title="调用init方法"></a>调用init方法</h3><ol>
<li>实例变量初始化</li>
<li>构造方法</li>
</ol>
<h3 id="初始化示例"><a href="#初始化示例" class="headerlink" title="初始化示例"></a>初始化示例</h3><p>父类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestParent</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;父类静态代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;父类代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TestParent</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;父类构造方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>子类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> <span class="keyword">extends</span> <span class="title class_">TestParent</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;静态代码块&quot;</span>);</span><br><span class="line">        i = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Test</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Test类的构造方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;变量i: &quot;</span> + i);</span><br><span class="line">        System.out.println(<span class="string">&quot;main&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">父类静态代码块</span><br><span class="line">静态代码块</span><br><span class="line">变量i: 1</span><br><span class="line">main</span><br><span class="line">父类代码块</span><br><span class="line">父类构造方法</span><br><span class="line">代码块</span><br><span class="line">Test类的构造方法</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>ElasticSearch全文查询</title>
    <url>/2023/08/06/ES/ES%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5/ElasticSearch%E5%85%A8%E6%96%87%E6%9F%A5%E8%AF%A2/</url>
    <content><![CDATA[<h2 id="match-query"><a href="#match-query" class="headerlink" title="match query"></a>match query</h2><p>match query 会对查询语句进行分词，分词后，如果查询语句中的任何一个词项被匹配，则文档就会被索引到。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET books/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match&quot;: &#123;</span><br><span class="line">      &quot;name&quot;: &quot;美术计算机&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个查询首先会对 美术计算机 进行分词，分词之后，再去查询，只要文档中包含一个分词结果，就回返回文档。换句话说，默认词项之间是 OR 的关系，如果想要修改，也可以改为 AND。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET books/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match&quot;: &#123;</span><br><span class="line">      &quot;name&quot;: &#123;</span><br><span class="line">        &quot;query&quot;: &quot;美术计算机&quot;,</span><br><span class="line">        &quot;operator&quot;: &quot;and&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时就回要求文档中必须同时包含 美术 和 计算机 两个词。</p>
<h2 id="match-phrase-query"><a href="#match-phrase-query" class="headerlink" title="match_phrase query"></a>match_phrase query</h2><p>match_phrase query 也会对查询的关键字进行分词，但是它分词后有两个特点：</p>
<ol>
<li>分词后的词项顺序必须和文档中词项的顺序一致</li>
<li>所有的词都必须出现在文档中<br>示例如下：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET books/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match_phrase&quot;: &#123;</span><br><span class="line">        &quot;name&quot;: &#123;</span><br><span class="line">          &quot;query&quot;: &quot;十一五计算机&quot;,</span><br><span class="line">          &quot;slop&quot;: 7</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>query 是查询的关键字，会被分词器进行分解，分解之后去倒排索引中进行匹配。</p>
<p>slop 是指关键字之间的最小距离，但是注意不是关键之间间隔的字数。文档中的字段被分词器解析之后，解析出来的词项都包含一个 position 字段表示词项的位置，查询短语分词之后 的 position 之间的间隔要满足 slop 的要求。</p>
<h2 id="match-phrase-prefix-query"><a href="#match-phrase-prefix-query" class="headerlink" title="match_phrase_prefix query"></a>match_phrase_prefix query</h2><p>这个类似于 match_phrase query，只不过这里多了一个通配符，match_phrase_prefix 支持最后一个词项的前缀匹配，但是由于这种匹配方式效率较低，因此大家作为了解即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET books/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match_phrase_prefix&quot;: &#123;</span><br><span class="line">      &quot;name&quot;: &quot;计&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个查询过程，会自动进行单词匹配，会自动查找以计开始的单词，默认是 50 个，可以自己控制：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET books/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match_phrase_prefix&quot;: &#123;</span><br><span class="line">      &quot;name&quot;: &#123;</span><br><span class="line">        &quot;query&quot;: &quot;计&quot;,</span><br><span class="line">        &quot;max_expansions&quot;: 3</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>match_phrase_prefix 是针对分片级别的查询，假设 max_expansions 为 1，可能返回多个文档，但是只有一个词，这是我们预期的结果。有的时候实际返回结果和我们预期结果并不一致，原因在于这个查询是分片级别的，不同的分片确实只返回了一个词，但是结果可能来自不同的分片，所以最终会看到多个词。</p>
<h2 id="multi-match-query"><a href="#multi-match-query" class="headerlink" title="multi_match query"></a>multi_match query</h2><p>match 查询的升级版，可以指定多个查询域：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET books/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;multi_match&quot;: &#123;</span><br><span class="line">      &quot;query&quot;: &quot;java&quot;,</span><br><span class="line">      &quot;fields&quot;: [&quot;name&quot;,&quot;info&quot;]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种查询方式还可以指定字段的权重：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET books/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;multi_match&quot;: &#123;</span><br><span class="line">      &quot;query&quot;: &quot;阳光&quot;,</span><br><span class="line">      &quot;fields&quot;: [&quot;name^4&quot;,&quot;info&quot;]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个表示关键字出现在 name 中的权重是出现在 info 中权重的 4 倍。</p>
<h2 id="query-string-query"><a href="#query-string-query" class="headerlink" title="query_string query"></a>query_string query</h2><p>query_string 是一种紧密结合 Lucene 的查询方式，在一个查询语句中可以用到 Lucene 的一些查询语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET books/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;query_string&quot;: &#123;</span><br><span class="line">      &quot;default_field&quot;: &quot;name&quot;,</span><br><span class="line">      &quot;query&quot;: &quot;(十一五) AND (计算机)&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="simple-query-string"><a href="#simple-query-string" class="headerlink" title="simple_query_string"></a>simple_query_string</h2><p>这个是 query_string 的升级，可以直接<strong>使用 +、|、- 代替 AND、OR、NOT 等</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET books/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;simple_query_string&quot;: &#123;</span><br><span class="line">      &quot;fields&quot;: [&quot;name&quot;],</span><br><span class="line">      &quot;query&quot;: &quot;(十一五) + (计算机)&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>es</tag>
      </tags>
  </entry>
  <entry>
    <title>ElasticSearch地理位置查询</title>
    <url>/2023/08/06/ES/ES%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5/ElasticSearch%E5%9C%B0%E7%90%86%E4%BD%8D%E7%BD%AE%E6%9F%A5%E8%AF%A2/</url>
    <content><![CDATA[<h2 id="数据准备"><a href="#数据准备" class="headerlink" title="数据准备"></a>数据准备</h2><p> 创建一个索引：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PUT geo</span><br><span class="line">&#123;</span><br><span class="line">  &quot;mappings&quot;: &#123;</span><br><span class="line">    &quot;properties&quot;: &#123;</span><br><span class="line">      &quot;name&quot;:&#123;</span><br><span class="line">        &quot;type&quot;: &quot;keyword&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;location&quot;:&#123;</span><br><span class="line">        &quot;type&quot;: &quot;geo_point&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>准备一个 geo.json 文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&quot;index&quot;:&#123;&quot;_index&quot;:&quot;geo&quot;,&quot;_id&quot;:1&#125;&#125;</span><br><span class="line">&#123;&quot;name&quot;:&quot;西安&quot;,&quot;location&quot;:&quot;34.288991865037524,108.9404296875&quot;&#125;</span><br><span class="line">&#123;&quot;index&quot;:&#123;&quot;_index&quot;:&quot;geo&quot;,&quot;_id&quot;:2&#125;&#125;</span><br><span class="line">&#123;&quot;name&quot;:&quot;北京&quot;,&quot;location&quot;:&quot;39.926588421909436,116.43310546875&quot;&#125;</span><br><span class="line">&#123;&quot;index&quot;:&#123;&quot;_index&quot;:&quot;geo&quot;,&quot;_id&quot;:3&#125;&#125;</span><br><span class="line">&#123;&quot;name&quot;:&quot;上海&quot;,&quot;location&quot;:&quot;31.240985378021307,121.53076171875&quot;&#125;</span><br><span class="line">&#123;&quot;index&quot;:&#123;&quot;_index&quot;:&quot;geo&quot;,&quot;_id&quot;:4&#125;&#125;</span><br><span class="line">&#123;&quot;name&quot;:&quot;天津&quot;,&quot;location&quot;:&quot;39.13006024213511,117.20214843749999&quot;&#125;</span><br><span class="line">&#123;&quot;index&quot;:&#123;&quot;_index&quot;:&quot;geo&quot;,&quot;_id&quot;:5&#125;&#125;</span><br><span class="line">&#123;&quot;name&quot;:&quot;杭州&quot;,&quot;location&quot;:&quot;30.259067203213018,120.21240234375001&quot;&#125;</span><br><span class="line">&#123;&quot;index&quot;:&#123;&quot;_index&quot;:&quot;geo&quot;,&quot;_id&quot;:6&#125;&#125;</span><br><span class="line">&#123;&quot;name&quot;:&quot;武汉&quot;,&quot;location&quot;:&quot;30.581179257386985,114.3017578125&quot;&#125;</span><br><span class="line">&#123;&quot;index&quot;:&#123;&quot;_index&quot;:&quot;geo&quot;,&quot;_id&quot;:7&#125;&#125;</span><br><span class="line">&#123;&quot;name&quot;:&quot;合肥&quot;,&quot;location&quot;:&quot;31.840232667909365,117.20214843749999&quot;&#125;</span><br><span class="line">&#123;&quot;index&quot;:&#123;&quot;_index&quot;:&quot;geo&quot;,&quot;_id&quot;:8&#125;&#125;</span><br><span class="line">&#123;&quot;name&quot;:&quot;重庆&quot;,&quot;location&quot;:&quot;29.592565403314087,106.5673828125&quot;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>最后，执行如下命令，批量导入 geo.json 数据：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -XPOST &quot;http://localhost:9200/geo/_bulk?pretty&quot; -H &quot;content-type:application/json&quot; --data-binary @geo.json</span><br></pre></td></tr></table></figure>

<h2 id="geo-distance-query"><a href="#geo-distance-query" class="headerlink" title="geo_distance query"></a>geo_distance query</h2><p>给出一个中心点，查询距离该中心点指定范围内的文档：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET geo/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;bool&quot;: &#123;</span><br><span class="line">      &quot;must&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;match_all&quot;: &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      &quot;filter&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;geo_distance&quot;: &#123;</span><br><span class="line">            &quot;distance&quot;: &quot;600km&quot;,</span><br><span class="line">            &quot;location&quot;: &#123;</span><br><span class="line">              &quot;lat&quot;: 34.288991865037524,</span><br><span class="line">              &quot;lon&quot;: 108.9404296875</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以(34.288991865037524,108.9404296875) 为圆心，以 600KM 为半径，这个范围内的数据。</p>
<h2 id="geo-bounding-box-query"><a href="#geo-bounding-box-query" class="headerlink" title="geo_bounding_box query"></a>geo_bounding_box query</h2><p>在某一个矩形内的点，通过两个点锁定一个矩形：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET geo/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;bool&quot;: &#123;</span><br><span class="line">      &quot;must&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;match_all&quot;: &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      &quot;filter&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;geo_bounding_box&quot;: &#123;</span><br><span class="line">            &quot;location&quot;: &#123;</span><br><span class="line">              &quot;top_left&quot;: &#123;</span><br><span class="line">                &quot;lat&quot;: 32.0639555946604,</span><br><span class="line">                &quot;lon&quot;: 118.78967285156249</span><br><span class="line">              &#125;,</span><br><span class="line">              &quot;bottom_right&quot;: &#123;</span><br><span class="line">                &quot;lat&quot;: 29.98824461550903,</span><br><span class="line">                &quot;lon&quot;: 122.20642089843749</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以南京经纬度作为矩形的左上角，以舟山经纬度作为矩形的右下角，构造出来的矩形中，包含上海和杭州两个城市。</p>
<h2 id="geo-polygon-query"><a href="#geo-polygon-query" class="headerlink" title="geo_polygon query"></a>geo_polygon query</h2><p>在某一个多边形范围内的查询。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET geo/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;bool&quot;: &#123;</span><br><span class="line">      &quot;must&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;match_all&quot;: &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      &quot;filter&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;geo_polygon&quot;: &#123;</span><br><span class="line">            &quot;location&quot;: &#123;</span><br><span class="line">              &quot;points&quot;: [</span><br><span class="line">                &#123;</span><br><span class="line">                  &quot;lat&quot;: 31.793755581217674,</span><br><span class="line">                  &quot;lon&quot;: 113.8238525390625</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                  &quot;lat&quot;: 30.007273923504556,</span><br><span class="line">                  &quot;lon&quot;:114.224853515625</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                  &quot;lat&quot;: 30.007273923504556,</span><br><span class="line">                  &quot;lon&quot;:114.8345947265625</span><br><span class="line">                &#125;</span><br><span class="line">              ]</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>给定多个点，由多个点组成的多边形中的数据。</p>
<h2 id="geo-shape-query"><a href="#geo-shape-query" class="headerlink" title="geo_shape query"></a>geo_shape query</h2><p>geo_shape 用来查询图形，针对 geo_shape，两个图形之间的关系有：相交、包含、不相交。<br>新建索引：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PUT geo_shape</span><br><span class="line">&#123;</span><br><span class="line">  &quot;mappings&quot;: &#123;</span><br><span class="line">    &quot;properties&quot;: &#123;</span><br><span class="line">      &quot;name&quot;:&#123;</span><br><span class="line">        &quot;type&quot;: &quot;keyword&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;location&quot;:&#123;</span><br><span class="line">        &quot;type&quot;: &quot;geo_shape&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后添加一条线：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PUT geo_shape/_doc/1</span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;:&quot;西安-郑州&quot;,</span><br><span class="line">  &quot;location&quot;:&#123;</span><br><span class="line">    &quot;type&quot;:&quot;linestring&quot;,</span><br><span class="line">    &quot;coordinates&quot;:[</span><br><span class="line">      [108.9404296875,34.279914398549934],</span><br><span class="line">      [113.66455078125,34.768691457552706]</span><br><span class="line">      ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来查询某一个图形中是否包含该线：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET geo_shape/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;bool&quot;: &#123;</span><br><span class="line">      &quot;must&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;match_all&quot;: &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      &quot;filter&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;geo_shape&quot;: &#123;</span><br><span class="line">            &quot;location&quot;: &#123;</span><br><span class="line">              &quot;shape&quot;: &#123;</span><br><span class="line">                &quot;type&quot;: &quot;envelope&quot;,</span><br><span class="line">                &quot;coordinates&quot;: [</span><br><span class="line">                  [</span><br><span class="line">            106.5234375,</span><br><span class="line">            36.80928470205937</span><br><span class="line">          ],</span><br><span class="line">          [</span><br><span class="line">            115.33447265625,</span><br><span class="line">            32.24997445586331</span><br><span class="line">          ]</span><br><span class="line">                ]</span><br><span class="line">              &#125;,</span><br><span class="line">              &quot;relation&quot;: &quot;within&quot;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>relation 属性表示两个图形的关系：</p>
<ul>
<li>within 包含</li>
<li>intersects 相交</li>
<li>disjoint 不相交</li>
</ul>
]]></content>
      <tags>
        <tag>es</tag>
      </tags>
  </entry>
  <entry>
    <title>ElasticSearch复合查询</title>
    <url>/2023/08/06/ES/ES%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5/ElasticSearch%E5%A4%8D%E5%90%88%E6%9F%A5%E8%AF%A2/</url>
    <content><![CDATA[<h2 id="constant-score-query"><a href="#constant-score-query" class="headerlink" title="constant_score query"></a>constant_score query</h2><p>当我们不关心检索词项的频率（TF）对搜索结果排序的影响时，可以使用 constant_score 将查询语句或者过滤语句包裹起来。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET books/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;constant_score&quot;: &#123;</span><br><span class="line">      &quot;filter&quot;: &#123;</span><br><span class="line">        &quot;term&quot;: &#123;</span><br><span class="line">          &quot;name&quot;: &quot;java&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;boost&quot;: 1.5</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="bool-query"><a href="#bool-query" class="headerlink" title="bool query"></a>bool query</h2><p>bool query 可以将任意多个简单查询组装在一起，有四个关键字可供选择，四个关键字所描述的条件可以有一个或者多个。</p>
<ul>
<li>must：文档必须匹配 must 选项下的查询条件。</li>
<li>should：文档可以匹配 should 下的查询条件，也可以不匹配。</li>
<li>must_not：文档必须不满足 must_not 选项下的查询条件。</li>
<li>filter：类似于 must，但是 filter 不评分，只是过滤数据。</li>
</ul>
<p>例如查询 name 属性中必须包含 java，同时书价不在 [0,35] 区间内，info 属性可以包含 程序设计 也可以不包含程序设计：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET books/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;bool&quot;: &#123;</span><br><span class="line">      &quot;must&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;term&quot;: &#123;</span><br><span class="line">            &quot;name&quot;: &#123;</span><br><span class="line">              &quot;value&quot;: &quot;java&quot;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      &quot;must_not&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;range&quot;: &#123;</span><br><span class="line">            &quot;price&quot;: &#123;</span><br><span class="line">              &quot;gte&quot;: 0,</span><br><span class="line">              &quot;lte&quot;: 35</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      &quot;should&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;match&quot;: &#123;</span><br><span class="line">            &quot;info&quot;: &quot;程序设计&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里还涉及到一个关键字，minmum_should_match 参数。<br>minmum_should_match 参数在 es 官网上称作最小匹配度。在之前学习的 multi_match 或者这里的 should 查询中，都可以设置 minmum_should_match 参数。</p>
<p>假设我们要做一次查询，查询 name 中包含 语言程序设计 关键字的文档：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET books/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match&quot;: &#123;</span><br><span class="line">      &quot;name&quot;: &quot;语言程序设计&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个查询过程中，首先会进行分词，分词结果如下：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://note.youdao.com/yws/res/3540/12F8026DDE964C11808AB123D8956FB3"
                      alt="image"
                ></p>
<p>分词后的 term 会构造成一个 should 的 bool query，每一个 term 都会变成一个 term query 的子句。换句话说，上面的查询和下面的查询等价：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET books/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;bool&quot;: &#123;</span><br><span class="line">      &quot;should&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;term&quot;: &#123;</span><br><span class="line">            &quot;name&quot;: &#123;</span><br><span class="line">              &quot;value&quot;: &quot;语言&quot;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;term&quot;: &#123;</span><br><span class="line">            &quot;name&quot;: &#123;</span><br><span class="line">              &quot;value&quot;: &quot;程序设计&quot;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;term&quot;: &#123;</span><br><span class="line">            &quot;name&quot;: &#123;</span><br><span class="line">              &quot;value&quot;: &quot;程序&quot;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;term&quot;: &#123;</span><br><span class="line">            &quot;name&quot;: &#123;</span><br><span class="line">              &quot;value&quot;: &quot;设计&quot;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这两个查询语句中，都是文档只需要包含词项中的任意一项即可，文档就回被返回，在 match 查询中，可以通过 operator 参数设置文档必须匹配所有词项。</p>
<p>如果想匹配一部分词项，就涉及到一个参数，就是 minmum_should_match，即最小匹配度。即至少匹配多少个词。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET books/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match&quot;: &#123;</span><br><span class="line">      &quot;name&quot;: &#123;</span><br><span class="line">        &quot;query&quot;: &quot;语言程序设计&quot;,</span><br><span class="line">        &quot;operator&quot;: &quot;and&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GET books/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;bool&quot;: &#123;</span><br><span class="line">      &quot;should&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;term&quot;: &#123;</span><br><span class="line">            &quot;name&quot;: &#123;</span><br><span class="line">              &quot;value&quot;: &quot;语言&quot;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;term&quot;: &#123;</span><br><span class="line">            &quot;name&quot;: &#123;</span><br><span class="line">              &quot;value&quot;: &quot;程序设计&quot;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;term&quot;: &#123;</span><br><span class="line">            &quot;name&quot;: &#123;</span><br><span class="line">              &quot;value&quot;: &quot;程序&quot;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;term&quot;: &#123;</span><br><span class="line">            &quot;name&quot;: &#123;</span><br><span class="line">              &quot;value&quot;: &quot;设计&quot;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      &quot;minimum_should_match&quot;: &quot;50%&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;from&quot;: 0,</span><br><span class="line">  &quot;size&quot;: 70</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>50% 表示词项个数的 50%。</p>
<p>如下两个查询等价（参数 4 是因为查询关键字分词后有 4 项）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET books/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match&quot;: &#123;</span><br><span class="line">      &quot;name&quot;: &#123;</span><br><span class="line">        &quot;query&quot;: &quot;语言程序设计&quot;,</span><br><span class="line">        &quot;minimum_should_match&quot;: 4</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">GET books/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match&quot;: &#123;</span><br><span class="line">      &quot;name&quot;: &#123;</span><br><span class="line">        &quot;query&quot;: &quot;语言程序设计&quot;,</span><br><span class="line">        &quot;operator&quot;: &quot;and&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="dis-max-query"><a href="#dis-max-query" class="headerlink" title="dis_max query"></a>dis_max query</h2><p>假设现在有两本书：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PUT blog</span><br><span class="line">&#123;</span><br><span class="line">  &quot;mappings&quot;: &#123;</span><br><span class="line">    &quot;properties&quot;: &#123;</span><br><span class="line">      &quot;title&quot;:&#123;</span><br><span class="line">        &quot;type&quot;: &quot;text&quot;,</span><br><span class="line">        &quot;analyzer&quot;: &quot;ik_max_word&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;content&quot;:&#123;</span><br><span class="line">        &quot;type&quot;: &quot;text&quot;,</span><br><span class="line">        &quot;analyzer&quot;: &quot;ik_max_word&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">POST blog/_doc</span><br><span class="line">&#123;</span><br><span class="line">  &quot;title&quot;:&quot;如何通过Java代码调用ElasticSearch&quot;,</span><br><span class="line">  &quot;content&quot;:&quot;松哥力荐，这是一篇很好的解决方案&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">POST blog/_doc</span><br><span class="line">&#123;</span><br><span class="line">  &quot;title&quot;:&quot;初识 MongoDB&quot;,</span><br><span class="line">  &quot;content&quot;:&quot;简单介绍一下 MongoDB，以及如何通过 Java 调用 MongoDB，MongoDB 是一个不错 NoSQL 解决方案&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在假设搜索 Java解决方案 关键字，但是不确定关键字是在 title 还是在 content，所以两者都搜索：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET blog/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;bool&quot;: &#123;</span><br><span class="line">      &quot;should&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;match&quot;: &#123;</span><br><span class="line">            &quot;title&quot;: &quot;java解决方案&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;match&quot;: &#123;</span><br><span class="line">            &quot;content&quot;: &quot;java解决方案&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>搜索结果如下：<br><img  
                     lazyload
                     alt="image"
                     data-src="https://note.youdao.com/yws/res/3556/582FE6D8A8DD49EEB0CFF0D53EA502AA"
                      alt="image"
                ></p>
<p>肉眼观察，感觉第二个和查询关键字相似度更高，但是实际查询结果并非这样。</p>
<p>要理解这个原因，我们需要来看下 should query 中的评分策略：</p>
<ul>
<li>首先会执行 should 中的两个查询</li>
<li>对两个查询结果的评分求和</li>
<li>对求和结果乘以匹配语句总数</li>
<li>在对第三步的结果除以所有语句总数<br>反映到具体的查询中：</li>
</ul>
<p>前者</p>
<ul>
<li>title 中 包含 java，假设评分是 1.1</li>
<li>content 中包含解决方案，假设评分是 1.2</li>
<li>有得分的 query 数量，这里是 2</li>
<li>总的 query 数量也是 2</li>
<li>最终结果：（1.1+1.2）*2&#x2F;2&#x3D;2.3</li>
</ul>
<p>后者</p>
<ul>
<li>title 中 不包含查询关键字，没有得分</li>
<li>content 中包含解决方案和 java，假设评分是 2</li>
<li>有得分的 query 数量，这里是 1</li>
<li>总的 query 数量也是 2</li>
<li>最终结果：2*1&#x2F;2&#x3D;1</li>
</ul>
<p>在这种查询中，title 和 content 相当于是相互竞争的关系，所以我们需要找到一个最佳匹配字段。</p>
<p>为了解决这一问题，就需要用到 dis_max query（disjunction max query，分离最大化查询）：匹配的文档依然返回，但是只将最佳匹配的评分作为查询的评分。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET blog/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;dis_max&quot;: &#123;</span><br><span class="line">      &quot;queries&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;match&quot;: &#123;</span><br><span class="line">            &quot;title&quot;: &quot;java解决方案&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;match&quot;: &#123;</span><br><span class="line">            &quot;content&quot;: &quot;java解决方案&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查询结果如下：<br><img  
                     lazyload
                     alt="image"
                     data-src="https://note.youdao.com/yws/res/3564/3CA775407E0043EF9EE3F2F6AE9E7458"
                      alt="image"
                ></p>
<p>在 dis_max query 中，还有一个参数 tie_breaker（取值在0～1），在 dis_max query 中，是完全不考虑其他 query 的分数，只是将最佳匹配的字段的评分返回。但是，有的时候，我们又不得不考虑一下其他 query 的分数，此时，可以通过 tie_breaker 来优化 dis_max query。tie_breaker 会将其他 query 的分数，乘以 tie_breaker，然后和分数最高的 query 进行一个综合计算。</p>
]]></content>
      <tags>
        <tag>es</tag>
      </tags>
  </entry>
  <entry>
    <title>ElasticSearch如何像MySQL一样做多表联合查询</title>
    <url>/2023/08/06/ES/ES%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5/ElasticSearch%E5%A6%82%E4%BD%95%E5%83%8FMySQL%E4%B8%80%E6%A0%B7%E5%81%9A%E5%A4%9A%E8%A1%A8%E8%81%94%E5%90%88%E6%9F%A5%E8%AF%A2/</url>
    <content><![CDATA[<p>关系型数据库中有表的关联关系，在 es 中，我们也有类似的需求，例如订单表和商品表，在 es 中，这样的一对多一般来说有两种方式：</p>
<ul>
<li>嵌套文档（nested）</li>
<li>父子文档</li>
</ul>
<h2 id="嵌套文档"><a href="#嵌套文档" class="headerlink" title="嵌套文档"></a>嵌套文档</h2><p>假设：有一个电影文档，每个电影都有演员信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PUT movies</span><br><span class="line">&#123;</span><br><span class="line">  &quot;mappings&quot;: &#123;</span><br><span class="line">    &quot;properties&quot;: &#123;</span><br><span class="line">      &quot;actors&quot;:&#123;</span><br><span class="line">        &quot;type&quot;: &quot;nested&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT movies/_doc/1</span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;:&quot;霸王别姬&quot;,</span><br><span class="line">  &quot;actors&quot;:[</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;name&quot;:&quot;张国荣&quot;,</span><br><span class="line">      &quot;gender&quot;:&quot;男&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;name&quot;:&quot;巩俐&quot;,</span><br><span class="line">      &quot;gender&quot;:&quot;女&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意 actors 类型要是 nested，具体原因参考 10.2.3 小节。<br><strong>请解释一下为什么是3个？</strong></p>
<p>nested类型的actors字段里的每一对对象被单独索引，再加上id为1的文档，就有3个文档了<br>缺点</p>
<p>查看文档数量：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET _cat/indices?v</span><br></pre></td></tr></table></figure>
<p>查看结果如下：<br><img  
                     lazyload
                     alt="image"
                     data-src="https://note.youdao.com/yws/res/3658/A5C7E498DB4B4B73BC2202096EA4EAD7"
                      alt="image"
                ></p>
<p>这是因为 nested 文档在 es 内部其实也是独立的 lucene 文档，只是在我们查询的时候，es 内部帮我们做了 join 处理，所以最终看起来就像一个独立文档一样。因此这种方案性能并不是特别好。</p>
<h2 id="嵌套查询"><a href="#嵌套查询" class="headerlink" title="嵌套查询"></a>嵌套查询</h2><p>这个用来查询嵌套文档：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET movies/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;nested&quot;: &#123;</span><br><span class="line">      &quot;path&quot;: &quot;actors&quot;,</span><br><span class="line">      &quot;query&quot;: &#123;</span><br><span class="line">        &quot;bool&quot;: &#123;</span><br><span class="line">          &quot;must&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">              &quot;match&quot;: &#123;</span><br><span class="line">                &quot;actors.name&quot;: &quot;张国荣&quot;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">              &quot;match&quot;: &#123;</span><br><span class="line">                &quot;actors.gender&quot;: &quot;男&quot;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="父子文档"><a href="#父子文档" class="headerlink" title="父子文档"></a>父子文档</h2><p>相比于嵌套文档，父子文档主要有如下优势：</p>
<ul>
<li>更新父文档时，不会重新索引子文档</li>
<li>创建、修改或者删除子文档时，不会影响父文档或者其他的子文档。</li>
<li>子文档可以作为搜索结果独立返回。</li>
</ul>
<p>例如学生和班级的关系：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PUT stu_class</span><br><span class="line">&#123;</span><br><span class="line">  &quot;mappings&quot;: &#123;</span><br><span class="line">    &quot;properties&quot;: &#123;</span><br><span class="line">      &quot;name&quot;:&#123;</span><br><span class="line">        &quot;type&quot;: &quot;keyword&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;s_c&quot;:&#123;</span><br><span class="line">        &quot;type&quot;: &quot;join&quot;,</span><br><span class="line">        &quot;relations&quot;:&#123;</span><br><span class="line">          &quot;class&quot;:&quot;student&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>s_c 表示父子文档关系的名字，可以自定义。join 表示这是一个父子文档。relations 里边，class 这个位置是 parent，student 这个位置是 child。<br>接下来，插入两个父文档：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PUT stu_class/_doc/1</span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;:&quot;一班&quot;,</span><br><span class="line">  &quot;s_c&quot;:&#123;</span><br><span class="line">    &quot;name&quot;:&quot;class&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">PUT stu_class/_doc/2</span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;:&quot;二班&quot;,</span><br><span class="line">  &quot;s_c&quot;:&#123;</span><br><span class="line">    &quot;name&quot;:&quot;class&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再来添加三个子文档：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PUT stu_class/_doc/3?routing=1</span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;:&quot;zhangsan&quot;,</span><br><span class="line">  &quot;s_c&quot;:&#123;</span><br><span class="line">    &quot;name&quot;:&quot;student&quot;,</span><br><span class="line">    &quot;parent&quot;:1</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">PUT stu_class/_doc/4?routing=1</span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;:&quot;lisi&quot;,</span><br><span class="line">  &quot;s_c&quot;:&#123;</span><br><span class="line">    &quot;name&quot;:&quot;student&quot;,</span><br><span class="line">    &quot;parent&quot;:1</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">PUT stu_class/_doc/5?routing=2</span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;:&quot;wangwu&quot;,</span><br><span class="line">  &quot;s_c&quot;:&#123;</span><br><span class="line">    &quot;name&quot;:&quot;student&quot;,</span><br><span class="line">    &quot;parent&quot;:2</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先大家可以看到，子文档都是独立的文档。特别需要注意的地方是，子文档需要和父文档在同一个分片上，所以 routing 关键字的值为父文档的 id。另外，name 属性表明这是一个子文档。<br>父子文档需要注意的地方：</p>
<ul>
<li>每个索引只能定义一个 join filed</li>
<li>父子文档需要在同一个分片上（查询，修改需要routing）</li>
<li>可以向一个已经存在的 join filed 上新增关系</li>
</ul>
<h2 id="has-child-query"><a href="#has-child-query" class="headerlink" title="has_child query"></a>has_child query</h2><p>通过子文档查询父文档使用 has_child query。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET stu_class/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;has_child&quot;: &#123;</span><br><span class="line">      &quot;type&quot;: &quot;student&quot;,</span><br><span class="line">      &quot;query&quot;: &#123;</span><br><span class="line">        &quot;match&quot;: &#123;</span><br><span class="line">          &quot;name&quot;: &quot;wangwu&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查询 wangwu 所属的班级。</p>
<h2 id="has-parent-query"><a href="#has-parent-query" class="headerlink" title="has_parent query"></a>has_parent query</h2><p>通过父文档查询子文档：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET stu_class/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;has_parent&quot;: &#123;</span><br><span class="line">      &quot;parent_type&quot;: &quot;class&quot;,</span><br><span class="line">      &quot;query&quot;: &#123;</span><br><span class="line">        &quot;match&quot;: &#123;</span><br><span class="line">          &quot;name&quot;: &quot;二班&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查询二班的学生。但是大家注意，这种查询没有评分。</p>
<p>可以使用 parent id 查询子文档：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET stu_class/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;parent_id&quot;:&#123;</span><br><span class="line">      &quot;type&quot;:&quot;student&quot;,</span><br><span class="line">      &quot;id&quot;:1</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过 parent id 查询，默认情况下使用相关性计算分数。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>整体上来说：</p>
<ul>
<li>普通子对象实现一对多，会损失子文档的边界，子对象之间的属性关系丢失。</li>
<li>nested 可以解决第 1 点的问题，但是 nested 有两个缺点：更新主文档的时候要全部更新，不支持子文档属于多个主文档。</li>
<li>父子文档解决 1、2 点的问题，但是它主要适用于写多读少的场景。</li>
</ul>
]]></content>
      <tags>
        <tag>es</tag>
      </tags>
  </entry>
  <entry>
    <title>ElasticSearch搜索入门</title>
    <url>/2023/08/06/ES/ES%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5/ElasticSearch%E6%90%9C%E7%B4%A2%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h2 id="搜索分为两个过程："><a href="#搜索分为两个过程：" class="headerlink" title="搜索分为两个过程："></a>搜索分为两个过程：</h2><ol>
<li>当向索引中保存文档时，默认情况下，es 会保存两份内容，<strong>一份是 _source  中的数据</strong>，<strong>另一份则是通过分词、排序等一系列过程生成的倒排索引文件</strong>，倒排索引中保存了词项和文档之间的对应关系。</li>
<li>搜索时，当 es 接收到用户的搜索请求之后，就会去倒排索引中查询，通过的倒排索引中维护的倒排记录表找到关键词对应的文档集合，然后对文档进行评分、排序、高亮等处理，处理完成后返回文档。</li>
</ol>
<h2 id="简单搜索"><a href="#简单搜索" class="headerlink" title="简单搜索"></a>简单搜索</h2><p>查询文档：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET books/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match_all&quot;: &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查询结果如下：<br><img  
                     lazyload
                     alt="image"
                     data-src="https://note.youdao.com/yws/res/3410/75B1613AC5704F28AF945C1F6B82F6DE"
                      alt="image"
                ></p>
<p>hits 中就是查询结果，total 是符合查询条件的文档数。<br>简单搜索可以简写为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET books/_search</span><br></pre></td></tr></table></figure>
<p>简单搜索默认查询 10 条记录。</p>
]]></content>
      <tags>
        <tag>es</tag>
      </tags>
  </entry>
  <entry>
    <title>ElasticSearch搜索高亮</title>
    <url>/2023/08/06/ES/ES%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5/ElasticSearch%E6%90%9C%E7%B4%A2%E9%AB%98%E4%BA%AE/</url>
    <content><![CDATA[<p>普通高亮，默认会自动添加 em 标签：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET books/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match&quot;: &#123;</span><br><span class="line">      &quot;name&quot;: &quot;大学&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;highlight&quot;: &#123;</span><br><span class="line">    &quot;fields&quot;: &#123;</span><br><span class="line">      &quot;name&quot;: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查询结果如下：<br><img  
                     lazyload
                     alt="image"
                     data-src="https://note.youdao.com/yws/res/3776/9DFC8A25F84F4244848EF962B3D52284"
                      alt="image"
                ></p>
<p>正常来说，我们见到的高亮可能是红色、黄色之类的。<br>可以自定义高亮标签：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET books/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match&quot;: &#123;</span><br><span class="line">      &quot;name&quot;: &quot;大学&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;highlight&quot;: &#123;</span><br><span class="line">    &quot;fields&quot;: &#123;</span><br><span class="line">      &quot;name&quot;: &#123;</span><br><span class="line">        &quot;pre_tags&quot;: [&quot;&lt;strong&gt;&quot;],</span><br><span class="line">        &quot;post_tags&quot;: [&quot;&lt;/strong&gt;&quot;]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>搜索结果如下：<br><img  
                     lazyload
                     alt="image"
                     data-src="https://note.youdao.com/yws/res/3783/3B89346F19BF492798DCE6F40497C743"
                      alt="image"
                ></p>
<p>有的时候，虽然我们是在 name 字段中搜索的，但是我们希望 info 字段中，相关的关键字也能高亮：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET books/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match&quot;: &#123;</span><br><span class="line">      &quot;name&quot;: &quot;大学&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;highlight&quot;: &#123;</span><br><span class="line">    &quot;require_field_match&quot;: &quot;false&quot;, </span><br><span class="line">    &quot;fields&quot;: &#123;</span><br><span class="line">      &quot;name&quot;: &#123;</span><br><span class="line">        &quot;pre_tags&quot;: [&quot;&lt;strong&gt;&quot;],</span><br><span class="line">        &quot;post_tags&quot;: [&quot;&lt;/strong&gt;&quot;]</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;info&quot;: &#123;</span><br><span class="line">        &quot;pre_tags&quot;: [&quot;&lt;strong&gt;&quot;],</span><br><span class="line">        &quot;post_tags&quot;: [&quot;&lt;/strong&gt;&quot;]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>搜索结果如下：<br><img  
                     lazyload
                     alt="image"
                     data-src="https://note.youdao.com/yws/res/3788/A7C5CC07910344B5998E8454812D4291"
                      alt="image"
                ></p>
]]></content>
      <tags>
        <tag>es</tag>
      </tags>
  </entry>
  <entry>
    <title>前缀查询</title>
    <url>/2023/08/06/ES/ES%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5/%E5%89%8D%E7%BC%80%E6%9F%A5%E8%AF%A2/</url>
    <content><![CDATA[<p>前缀查询，效率略低，除非必要，一般不太建议使用。</p>
<p>给定关键词的前缀去查询：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET books/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;prefix&quot;: &#123;</span><br><span class="line">      &quot;name&quot;: &#123;</span><br><span class="line">        &quot;value&quot;: &quot;大学&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>es</tag>
      </tags>
  </entry>
  <entry>
    <title>ElasticSearch特殊查询</title>
    <url>/2023/08/06/ES/ES%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5/ElasticSearch%E7%89%B9%E6%AE%8A%E6%9F%A5%E8%AF%A2/</url>
    <content><![CDATA[<h2 id="more-like-this-query"><a href="#more-like-this-query" class="headerlink" title="more_like_this query"></a>more_like_this query</h2><p>more_like_this query 可以实现基于内容的推荐，给定一篇文章，可以查询出和该文章相似的内容。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET books/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;more_like_this&quot;: &#123;</span><br><span class="line">      &quot;fields&quot;: [</span><br><span class="line">        &quot;info&quot;</span><br><span class="line">      ],</span><br><span class="line">      &quot;like&quot;: &quot;大学战略&quot;,</span><br><span class="line">      &quot;min_term_freq&quot;: 1,</span><br><span class="line">      &quot;max_query_terms&quot;: 12</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>fields：要匹配的字段，可以有多个</li>
<li>like：要匹配的文本</li>
<li>min_term_freq：词项的最低频率，默认是 2。特别注意，这个是指词项在要匹配的文本中的频率，而不是 es 文档中的频率</li>
<li>max_query_terms：query 中包含的最大词项数目</li>
<li>min_doc_freq：最小的文档频率，搜索的词，至少在多少个文档中出现，少于指定数目，该词会被忽略</li>
<li>max_doc_freq：最大文档频率</li>
<li>analyzer：分词器，默认使用字段的分词器</li>
<li>stop_words：停用词列表</li>
<li>minmum_should_match</li>
</ul>
<h2 id="script-query"><a href="#script-query" class="headerlink" title="script query"></a>script query</h2><p> 脚本查询，例如查询所有价格大于 200 的图书：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET books/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;bool&quot;: &#123;</span><br><span class="line">      &quot;filter&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;script&quot;: &#123;</span><br><span class="line">            &quot;script&quot;: &#123;</span><br><span class="line">              &quot;lang&quot;: &quot;painless&quot;,</span><br><span class="line">              &quot;source&quot;: &quot;if(doc[&#x27;price&#x27;].size()!=0)&#123;doc[&#x27;price&#x27;].value &gt; 200&#125;&quot;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="percolate-query"><a href="#percolate-query" class="headerlink" title="percolate query"></a>percolate query</h2><p>percolate query 译作渗透查询或者反向查询。<br>正常操作：根据查询语句找到对应的文档 query-&gt;document</p>
<p>percolate query：根据文档，返回与之匹配的查询语句，document-&gt;query</p>
<p>应用场景：</p>
<ul>
<li>价格监控</li>
<li>库存报警</li>
<li>股票警告</li>
<li>…<br>例如阈值告警，假设指定字段值大于阈值，报警提示。</li>
</ul>
<p>percolate mapping 定义：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PUT log</span><br><span class="line">&#123;</span><br><span class="line">  &quot;mappings&quot;: &#123;</span><br><span class="line">    &quot;properties&quot;: &#123;</span><br><span class="line">      &quot;threshold&quot;:&#123;</span><br><span class="line">        &quot;type&quot;: &quot;long&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;count&quot;:&#123;</span><br><span class="line">        &quot;type&quot;: &quot;long&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;query&quot;:&#123;</span><br><span class="line">        &quot;type&quot;:&quot;percolator&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>percolator(翻译是渗透器) 类型相当于 keyword、long 以及 integer 等。<br>插入文档：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PUT log/_doc/1</span><br><span class="line">&#123;</span><br><span class="line">  &quot;threshold&quot;:10,</span><br><span class="line">  &quot;query&quot;:&#123;</span><br><span class="line">    &quot;bool&quot;:&#123;</span><br><span class="line">      &quot;must&quot;:&#123;</span><br><span class="line">        &quot;range&quot;:&#123;</span><br><span class="line">          &quot;count&quot;:&#123;</span><br><span class="line">            &quot;gt&quot;:10</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后查询：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET log/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;percolate&quot;: &#123;</span><br><span class="line">      &quot;field&quot;: &quot;query&quot;,</span><br><span class="line">      &quot;documents&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;count&quot;:3</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;count&quot;:6</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;count&quot;:90</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;count&quot;:12</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;count&quot;:15</span><br><span class="line">        &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查询结果中会列出不满足条件的文档。</p>
<p>查询结果中的 _percolator_document_slot 字段表示文档的 position，从 0 开始计。</p>
]]></content>
      <tags>
        <tag>es</tag>
      </tags>
  </entry>
  <entry>
    <title>布尔过滤器</title>
    <url>/2023/08/06/ES/ES%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5/%E5%B8%83%E5%B0%94%E8%BF%87%E6%BB%A4%E5%99%A8/</url>
    <content><![CDATA[<p>一个 bool 过滤器由三部分组成：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   &quot;bool&quot; : &#123;</span><br><span class="line">      &quot;must&quot; :     [&#123;&quot;term&quot;: &#123;&quot;FIELD1&quot;: &#123; &quot;value&quot;: &quot;VALUE&quot; &#125; &#125; &#125;,…,&#123;&quot;term&quot;: &#123;&quot;FIELD2&quot;: &#123; &quot;value&quot;: &quot;VALUE&quot; &#125; &#125; &#125;],</span><br><span class="line">      &quot;should&quot; :   [&#123;&quot;term&quot;: &#123;&quot;FIELD3&quot;: &#123; &quot;value&quot;: &quot;VALUE&quot; &#125; &#125; &#125;,…,&#123;&quot;term&quot;: &#123;&quot;FIELD4&quot;: &#123; &quot;value&quot;: &quot;VALUE&quot; &#125; &#125; &#125;],</span><br><span class="line">      &quot;must_not&quot; : [&#123;&quot;term&quot;: &#123;&quot;FIELD5&quot;: &#123; &quot;value&quot;: &quot;VALUE&quot; &#125; &#125; &#125;,…,&#123;&quot;term&quot;: &#123;&quot;FIELD6&quot;: &#123; &quot;value&quot;: &quot;VALUE&quot; &#125; &#125; &#125;],</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>相当于mysql</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from tables where FIELD1 and FIELD2 and (FIELD3 or FIELD4) and !=FIELD5 and !=FIELD6;</span><br></pre></td></tr></table></figure>


<ol>
<li>must ：所有的语句都 必须（must） 匹配，与 AND 等价。 </li>
<li>must_not ：所有的语句都 不能（must not） 匹配，与 NOT 等价。 </li>
<li>should ：至少有一个语句要匹配，与 OR 等价。</li>
</ol>
<p>当我们需要多个过滤器时，只须将它们置入 bool 过滤器的不同部分即可。</p>
]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>想搜索附近评分较高的餐厅ElasticSearch大显身手</title>
    <url>/2023/08/06/ES/ES%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5/%E6%83%B3%E6%90%9C%E7%B4%A2%E9%99%84%E8%BF%91%E8%AF%84%E5%88%86%E8%BE%83%E9%AB%98%E7%9A%84%E9%A4%90%E5%8E%85ElasticSearch%E5%A4%A7%E6%98%BE%E8%BA%AB%E6%89%8B/</url>
    <content><![CDATA[<h2 id="场景："><a href="#场景：" class="headerlink" title="场景："></a>场景：</h2><p>场景：例如想要搜索附近的肯德基，搜索的关键字是肯德基，但是我希望能够将评分较高的肯德基优先展示出来。但是默认的评分策略是没有办法考虑到餐厅评分的，他只是考虑相关性，这个时候可以通过 function_score query 来实现。</p>
<p>准备两条测试数据：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PUT blog</span><br><span class="line">&#123;</span><br><span class="line">  &quot;mappings&quot;: &#123;</span><br><span class="line">    &quot;properties&quot;: &#123;</span><br><span class="line">      &quot;title&quot;:&#123;</span><br><span class="line">        &quot;type&quot;: &quot;text&quot;,</span><br><span class="line">        &quot;analyzer&quot;: &quot;ik_max_word&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;votes&quot;:&#123;</span><br><span class="line">        &quot;type&quot;: &quot;integer&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT blog/_doc/1</span><br><span class="line">&#123;</span><br><span class="line">  &quot;title&quot;:&quot;Java集合详解&quot;,</span><br><span class="line">  &quot;votes&quot;:100</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT blog/_doc/2</span><br><span class="line">&#123;</span><br><span class="line">  &quot;title&quot;:&quot;Java多线程详解，Java锁详解&quot;,</span><br><span class="line">  &quot;votes&quot;:10</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在搜索标题中包含 java 关键字的文档：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET blog/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match&quot;: &#123;</span><br><span class="line">      &quot;title&quot;: &quot;java&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查询结果如下：<br><img  
                     lazyload
                     alt="image"
                     data-src="https://note.youdao.com/yws/res/3584/0EDC3C47762749FEAC46EA2DE9257921"
                      alt="image"
                ></p>
<p>默认情况下，id 为 2 的记录得分较高，因为他的 title 中包含两个 java。</p>
<p>如果我们在查询中，希望能够充分考虑 votes 字段，将 votes 较高的文档优先展示，就可以通过 function_score 来实现。</p>
<p>具体的思路，就是在旧的得分基础上，根据 votes 的数值进行综合运算，重新得出一个新的评分。</p>
<p>具体有几种不同的计算方式：</p>
<ul>
<li>weight</li>
<li>random_score</li>
<li>script_score</li>
<li>field_value_factor</li>
</ul>
<h2 id="weight"><a href="#weight" class="headerlink" title="weight"></a>weight</h2><p>weight 可以对评分设置权重，就是在旧的评分基础上乘以 weight，他其实无法解决我们上面所说的问题。具体用法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET blog/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;function_score&quot;: &#123;</span><br><span class="line">      &quot;query&quot;: &#123;</span><br><span class="line">        &quot;match&quot;: &#123;</span><br><span class="line">          &quot;title&quot;: &quot;java&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;functions&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;weight&quot;: 10</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查询结果如下：<br><img  
                     lazyload
                     alt="image"
                     data-src="https://note.youdao.com/yws/res/3597/DDCA30A3336C40E6A682ACEB594C9C56"
                      alt="image"
                ></p>
<p>可以看到，此时的评分，在之前的评分基础上*10</p>
<h2 id="random-score"><a href="#random-score" class="headerlink" title="random_score"></a>random_score</h2><p>random_score 会根据 uid 字段进行 hash 运算，生成分数，使用 random_score 时可以配置一个种子，如果不配置，默认使用当前时间。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET blog/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;function_score&quot;: &#123;</span><br><span class="line">      &quot;query&quot;: &#123;</span><br><span class="line">        &quot;match&quot;: &#123;</span><br><span class="line">          &quot;title&quot;: &quot;java&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;functions&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;random_score&quot;: &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="script-score"><a href="#script-score" class="headerlink" title="script_score"></a>script_score</h2><p>自定义评分脚本。假设每个文档的最终得分是旧的分数加上votes。查询方式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET blog/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;function_score&quot;: &#123;</span><br><span class="line">      &quot;query&quot;: &#123;</span><br><span class="line">        &quot;match&quot;: &#123;</span><br><span class="line">          &quot;title&quot;: &quot;java&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;functions&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;script_score&quot;: &#123;</span><br><span class="line">            &quot;script&quot;: &#123;</span><br><span class="line">              &quot;lang&quot;: &quot;painless&quot;,</span><br><span class="line">              &quot;source&quot;: &quot;_score + doc[&#x27;votes&#x27;].value&quot;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果不想乘以 oldScore，查询方式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET blog/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;function_score&quot;: &#123;</span><br><span class="line">      &quot;query&quot;: &#123;</span><br><span class="line">        &quot;match&quot;: &#123;</span><br><span class="line">          &quot;title&quot;: &quot;java&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;functions&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;script_score&quot;: &#123;</span><br><span class="line">            &quot;script&quot;: &#123;</span><br><span class="line">              &quot;lang&quot;: &quot;painless&quot;,</span><br><span class="line">              &quot;source&quot;: &quot;_score + doc[&#x27;votes&#x27;].value&quot;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      &quot;boost_mode&quot;: &quot;replace&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过 boost_mode 参数，可以设置最终的计算方式。该参数还有其他取值：</p>
<ul>
<li>multiply：分数相乘</li>
<li>sum：分数相加</li>
<li>avg：求平均数</li>
<li>max：最大分</li>
<li>min：最小分</li>
<li>replace：不进行二次计算</li>
</ul>
<h2 id="field-value-factor"><a href="#field-value-factor" class="headerlink" title="field_value_factor"></a>field_value_factor</h2><p>这个的功能类似于 script_score，但是不用自己写脚本。<br>假设每个文档的最终得分是旧的分数乘以votes。查询方式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET blog/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;function_score&quot;: &#123;</span><br><span class="line">      &quot;query&quot;: &#123;</span><br><span class="line">        &quot;match&quot;: &#123;</span><br><span class="line">          &quot;title&quot;: &quot;java&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;functions&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;field_value_factor&quot;: &#123;</span><br><span class="line">            &quot;field&quot;: &quot;votes&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>默认的得分就是oldScore*votes。<br>还可以利用 es 内置的函数进行一些更复杂的运算：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET blog/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;function_score&quot;: &#123;</span><br><span class="line">      &quot;query&quot;: &#123;</span><br><span class="line">        &quot;match&quot;: &#123;</span><br><span class="line">          &quot;title&quot;: &quot;java&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;functions&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;field_value_factor&quot;: &#123;</span><br><span class="line">            &quot;field&quot;: &quot;votes&quot;,</span><br><span class="line">            &quot;modifier&quot;: &quot;sqrt&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      &quot;boost_mode&quot;: &quot;replace&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时，最终的得分是（sqrt(votes)）。<br>modifier 中可以设置内置函数，其他的内置函数还有：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://note.youdao.com/yws/res/3624/4C6F5F5A13DF4DC1B1C4EC08395A749C"
                      alt="image"
                ></p>
<p>另外还有个参数 factor ，影响因子。字段值先乘以影响因子，然后再进行计算。以 sqrt 为例，计算方式为 sqrt(factor*votes)：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET blog/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;function_score&quot;: &#123;</span><br><span class="line">      &quot;query&quot;: &#123;</span><br><span class="line">        &quot;match&quot;: &#123;</span><br><span class="line">          &quot;title&quot;: &quot;java&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;functions&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;field_value_factor&quot;: &#123;</span><br><span class="line">            &quot;field&quot;: &quot;votes&quot;,</span><br><span class="line">            &quot;modifier&quot;: &quot;sqrt&quot;,</span><br><span class="line">            &quot;factor&quot;: 10</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      &quot;boost_mode&quot;: &quot;replace&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还有一个参数 max_boost，控制计算结果的范围：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET blog/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;function_score&quot;: &#123;</span><br><span class="line">      &quot;query&quot;: &#123;</span><br><span class="line">        &quot;match&quot;: &#123;</span><br><span class="line">          &quot;title&quot;: &quot;java&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;functions&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;field_value_factor&quot;: &#123;</span><br><span class="line">            &quot;field&quot;: &quot;votes&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      &quot;boost_mode&quot;: &quot;sum&quot;,</span><br><span class="line">      &quot;max_boost&quot;: 100</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>max_boost 参数表示 functions 模块中，最终的计算结果上限。如果超过上限，就按照上线计算。</p>
<h2 id="boosting-query"><a href="#boosting-query" class="headerlink" title="boosting query"></a>boosting query</h2><p>boosting query 中包含三部分：</p>
<ul>
<li>positive：得分不变</li>
<li>negative：降低得分</li>
<li>negative_boost：降低的权重</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET books/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;boosting&quot;: &#123;</span><br><span class="line">      &quot;positive&quot;: &#123;</span><br><span class="line">        &quot;match&quot;: &#123;</span><br><span class="line">          &quot;name&quot;: &quot;java&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;negative&quot;: &#123;</span><br><span class="line">        &quot;match&quot;: &#123;</span><br><span class="line">          &quot;name&quot;: &quot;2008&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;negative_boost&quot;: 0.5</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查询结果如下：<br><img  
                     lazyload
                     alt="image"
                     data-src="https://note.youdao.com/yws/res/3639/96F088E57B1C4628A12CE9D5F2010B24"
                      alt="image"
                ></p>
<p>可以看到，id 为 86 的文档满足条件，因此它的最终得分在旧的分数上*0.5。</p>
]]></content>
      <tags>
        <tag>es</tag>
      </tags>
  </entry>
  <entry>
    <title>批量更新</title>
    <url>/2023/08/06/ES/ES%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5/%E6%89%B9%E9%87%8F%E6%9B%B4%E6%96%B0/</url>
    <content><![CDATA[<h2 id="sample"><a href="#sample" class="headerlink" title="sample"></a>sample</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET oss-rcs-detail-*/_update_by_query</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;range&quot;: &#123;</span><br><span class="line">      &quot;wtime&quot;: &#123;</span><br><span class="line">        &quot;gte&quot;: &quot;2020-09-01 00:00:00&quot;,</span><br><span class="line">        &quot;lte&quot;: &quot;2021-01-12 00:00:00&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;script&quot;: &#123;</span><br><span class="line">    &quot;source&quot;: &quot;ctx._source.messagetype += 1&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>给符合条件的messagetype加一处理</p>
]]></content>
      <tags>
        <tag>es</tag>
      </tags>
  </entry>
  <entry>
    <title>根据id对数据进行更新</title>
    <url>/2023/08/06/ES/ES%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5/%E6%A0%B9%E6%8D%AEid%E5%AF%B9%E6%95%B0%E6%8D%AE%E8%BF%9B%E8%A1%8C%E6%9B%B4%E6%96%B0/</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST test/_doc/1/_update</span><br><span class="line">&#123;</span><br><span class="line">    &quot;doc&quot; : &#123;</span><br><span class="line">        &quot;name&quot; : &quot;new_name&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>test:为索引</li>
<li>_doc:为mapping，可以不要</li>
<li>1:记录id</li>
</ul>
]]></content>
      <tags>
        <tag>es</tag>
      </tags>
  </entry>
  <entry>
    <title>模糊查询</title>
    <url>/2023/08/06/ES/ES%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5/%E6%A8%A1%E7%B3%8A%E6%9F%A5%E8%AF%A2/</url>
    <content><![CDATA[<p>在实际搜索中，有时我们可能会打错字，从而导致搜索不到，在 match query 中，可以通过 fuzziness 属性实现模糊查询。</p>
<p>fuzzy query 返回与搜索关键字相似的文档。怎么样就算相似？以LevenShtein 编辑距离为准。<strong>编辑距离是指将一个字符变为另一个字符所需要更改字符的次数</strong>，更改主要包括四种：</p>
<ul>
<li>更改字符（javb–〉java）</li>
<li>删除字符（javva–〉java）</li>
<li>插入字符（jaa–〉java）</li>
<li>转置字符（ajva–〉java）</li>
</ul>
<p>为了找到相似的词，模糊查询会在指定的编辑距离中创建搜索关键词的所有可能变化或者扩展的集合，然后进行搜索匹配。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET books/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;fuzzy&quot;: &#123;</span><br><span class="line">      &quot;name&quot;: &quot;javba&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>es</tag>
      </tags>
  </entry>
  <entry>
    <title>范围查询</title>
    <url>/2023/08/06/ES/ES%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5/%E8%8C%83%E5%9B%B4%E6%9F%A5%E8%AF%A2/</url>
    <content><![CDATA[<h2 id="范围查询"><a href="#范围查询" class="headerlink" title="范围查询"></a>范围查询</h2><p>可以按照日期范围、数字范围等查询。<br>range query 中的参数主要有四个：</p>
<ul>
<li>gt</li>
<li>lt</li>
<li>gte</li>
<li>lte<br>案例：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET books/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;range&quot;: &#123;</span><br><span class="line">      &quot;price&quot;: &#123;</span><br><span class="line">        &quot;gte&quot;: 10,</span><br><span class="line">        &quot;lt&quot;: 20</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;sort&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;price&quot;: &#123;</span><br><span class="line">        &quot;order&quot;: &quot;desc&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="sample"><a href="#sample" class="headerlink" title="sample"></a>sample</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;query&quot;: &#123;</span><br><span class="line">     &#123;</span><br><span class="line">          &quot;range&quot;: &#123;</span><br><span class="line">            &quot;wtime&quot;: &#123;</span><br><span class="line">              &quot;from&quot;: &quot;2021-01-01 00:00:00&quot;,</span><br><span class="line">              &quot;to&quot;: &quot;2021-12-31 23:59:59&quot;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相当于mysql中的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from table where wtime &gt;= &#x27;2021-01-01 00:00:00&#x27;  and wtime &lt;= &#x27;2021-12-31 23:59:59&#x27; ;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>es</tag>
      </tags>
  </entry>
  <entry>
    <title>词项查询</title>
    <url>/2023/08/06/ES/ES%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5/%E8%AF%8D%E9%A1%B9%E6%9F%A5%E8%AF%A2/</url>
    <content><![CDATA[<h2 id="词项查询"><a href="#词项查询" class="headerlink" title="词项查询"></a>词项查询</h2><p>即 term 查询，就是根据词去查询，查询指定字段中包含给定单词的文档，<strong>term 查询不被解析，只有搜索的词和文档中的词精确匹配</strong>，才会返回文档。应用场景如：人名、地名等等。</p>
<p>查询 name 字段中包含 十一五 的文档。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET books/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;term&quot;: &#123;</span><br><span class="line">      &quot;name&quot;: &quot;十一五&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h2><p>默认返回前 10 条数据，es 中也可以像关系型数据库一样，给一个分页参数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET books/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;term&quot;: &#123;</span><br><span class="line">      &quot;name&quot;: &quot;十一五&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;size&quot;: 10,</span><br><span class="line">  &quot;from&quot;: 10</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="过滤返回字段"><a href="#过滤返回字段" class="headerlink" title="过滤返回字段"></a>过滤返回字段</h2><p>如果返回的字段比较多，又不需要这么多字段，此时可以指定返回的字段：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET books/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;term&quot;: &#123;</span><br><span class="line">      &quot;name&quot;: &quot;十一五&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;size&quot;: 10,</span><br><span class="line">  &quot;from&quot;: 10,</span><br><span class="line">  &quot;_source&quot;: [&quot;name&quot;,&quot;author&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时，返回的字段就只有 name 和 author 了。</p>
<h2 id="最小评分"><a href="#最小评分" class="headerlink" title="最小评分"></a>最小评分</h2><p>有的文档得分特别低，说明这个文档和我们查询的关键字相关度很低。我们可以设置一个最低分，只有得分超过最低分的文档才会被返回。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET books/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;term&quot;: &#123;</span><br><span class="line">      &quot;name&quot;: &quot;十一五&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;min_score&quot;:1.75,</span><br><span class="line">  &quot;_source&quot;: [&quot;name&quot;,&quot;author&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>得分低于 1.75 的文档将直接被舍弃。</p>
<h2 id="高亮"><a href="#高亮" class="headerlink" title="高亮"></a>高亮</h2><p>查询关键字高亮：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET books/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;term&quot;: &#123;</span><br><span class="line">      &quot;name&quot;: &quot;十一五&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;min_score&quot;:1.75,</span><br><span class="line">  &quot;_source&quot;: [&quot;name&quot;,&quot;author&quot;],</span><br><span class="line">  &quot;highlight&quot;: &#123;</span><br><span class="line">    &quot;fields&quot;: &#123;</span><br><span class="line">      &quot;name&quot;: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="terms-query"><a href="#terms-query" class="headerlink" title="terms query"></a>terms query</h2><p>词项查询，但是可以给多个关键词。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET books/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;terms&quot;: &#123;</span><br><span class="line">      &quot;name&quot;: [&quot;程序&quot;,&quot;设计&quot;,&quot;java&quot;]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>es</tag>
      </tags>
  </entry>
  <entry>
    <title>通过id进行查询</title>
    <url>/2023/08/06/ES/ES%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5/%E9%80%9A%E8%BF%87id%E8%BF%9B%E8%A1%8C%E6%9F%A5%E8%AF%A2/</url>
    <content><![CDATA[<p>根据指定的 id 查询。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET books/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;ids&quot;:&#123;</span><br><span class="line">      &quot;values&quot;:  [1,2,3]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>es</tag>
      </tags>
  </entry>
  <entry>
    <title>通配符查询</title>
    <url>/2023/08/06/ES/ES%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5/%E9%80%9A%E9%85%8D%E7%AC%A6%E6%9F%A5%E8%AF%A2/</url>
    <content><![CDATA[<p>wildcard query 即通配符查询。支持单字符和多字符通配符：</p>
<ul>
<li>？表示一个任意字符。</li>
<li>*表示零个或者多个字符。</li>
</ul>
<p>查询所有姓张的作者的书：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET books/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;wildcard&quot;: &#123;</span><br><span class="line">      &quot;author&quot;: &#123;</span><br><span class="line">        &quot;value&quot;: &quot;张*&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查询所有姓张并且名字只有两个字的作者的书：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET books/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;wildcard&quot;: &#123;</span><br><span class="line">      &quot;author&quot;: &#123;</span><br><span class="line">        &quot;value&quot;: &quot;张?&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="regexp-query"><a href="#regexp-query" class="headerlink" title="regexp query"></a>regexp query</h2><p>支持正则表达式查询。</p>
<p>查询所有姓张并且名字只有两个字的作者的书：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET books/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;regexp&quot;: &#123;</span><br><span class="line">      &quot;author&quot;: &quot;张.&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>es</tag>
      </tags>
  </entry>
  <entry>
    <title>非空查询</title>
    <url>/2023/08/06/ES/ES%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5/%E9%9D%9E%E7%A9%BA%E6%9F%A5%E8%AF%A2/</url>
    <content><![CDATA[<p>exists query 会返回指定字段中至少有一个非空值的文档：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET books/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;exists&quot;: &#123;</span><br><span class="line">      &quot;field&quot;: &quot;javaboy&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，空字符串也是有值。null 是空值。</p>
]]></content>
      <tags>
        <tag>es</tag>
      </tags>
  </entry>
  <entry>
    <title>cpu过高如何排查.md</title>
    <url>/2024/12/03/Java%E5%9F%BA%E7%A1%80/%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/cpu%E8%BF%87%E9%AB%98%E5%A6%82%E4%BD%95%E6%8E%92%E6%9F%A5/</url>
    <content><![CDATA[<h2 id="使用arthas"><a href="#使用arthas" class="headerlink" title="使用arthas"></a>使用arthas</h2><ol>
<li>排除GC影响，频繁的GC会占用大量的CPU资源</li>
<li>定位到高CPU占用的线程，使用dashboard命令，重点关注进程信息，识别出与应用程序相关的线程</li>
<li>分析高CPU消耗的线程，thread -n 5查看最繁忙的5个线程的堆栈信息，找到线程停留在哪个方法上执行，定位到具体的方法和代码位置</li>
</ol>
<h2 id="top-jstack"><a href="#top-jstack" class="headerlink" title="top+jstack"></a>top+jstack</h2><ol>
<li>使用top找到cpu占用率高的进程</li>
<li>使用top -Hp 进程号，找到进程中各线程的cpu占用率</li>
<li>使用jstack 线程号 &gt; out.txt，导出堆栈信息（16进制）</li>
<li>printf %x 线程号，获取16进制的线程号表示</li>
<li>cat out.txt | grep -A 30 16进制的线程号表示，向后找30行</li>
<li>找到问题的代码和方法</li>
</ol>
<h2 id="可能的原因"><a href="#可能的原因" class="headerlink" title="可能的原因"></a>可能的原因</h2><ol>
<li>while无限循环，避免无限循环，sleep 让循环执行的慢点</li>
<li>频繁的GC，垃圾收集线程频繁的执行，降低收集频率</li>
<li>频繁的上下文切换</li>
<li>正则表达式，回溯操作</li>
<li>序列化和反序列化，选择合理的api实现</li>
<li>频繁创建对象，合理使用单例</li>
</ol>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>内存泄露如何排查.md</title>
    <url>/2024/12/03/Java%E5%9F%BA%E7%A1%80/%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E5%A6%82%E4%BD%95%E6%8E%92%E6%9F%A5/</url>
    <content><![CDATA[<ol>
<li>先确认内存当前的使用情况，查看堆内存、各代内存分区、非堆内存的使用情况</li>
<li>观察内存的变化，多次观察，正常情况内存使用有涨有落，若持续增长而不减少，有较大内存泄露的可能性</li>
<li>生成堆转储文件，可以生成多次，捕获不同时间点堆的状态</li>
<li>分析堆转储文件，使用MAT工具分析对象的数量、大小及其引用链，重点关注数量异常增多或异常大的对象</li>
<li>定位泄露对象，找出问题对象和创建对象的源头</li>
<li>进行修复，回溯代码，理解为什么没有正确回收对象，优化资源释放和生命周期管理</li>
</ol>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>线程中注入service</title>
    <url>/2023/08/06/Java%E5%9F%BA%E7%A1%80/%E7%BA%BF%E7%A8%8B%E5%A4%84%E7%90%86/%E7%BA%BF%E7%A8%8B%E4%B8%AD%E6%B3%A8%E5%85%A5service/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>在线程中注入service,但是若直接在Thread子类中通过注解方式注入是无效的。</p>
<h1 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h1><p>因为Spring本身默认Bean为单例模式构建，同时是非线程安全的，因此禁止了在Thread子类中的注入行为，因此在Thread中直接注入的bean是null的，会发生空指针错误。</p>
<h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><h2 id="1-通过封装Thread子类注入"><a href="#1-通过封装Thread子类注入" class="headerlink" title="1.通过封装Thread子类注入"></a>1.通过封装Thread子类注入</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NetListingConsumer</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 通过注解注入封装线程的Bean</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    INetListingService netListingService;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JedisCluster redis;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Worker</span>().start();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 线程内部类，Thread或者Runnable均可</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Worker</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">                List&lt;String&gt; listingList = redis.brpop(<span class="number">0</span>, <span class="string">&quot;listingList&quot;</span>);</span><br><span class="line">                log.info(<span class="string">&quot;[开始消费REDIS消息队列listingList数据...]&quot;</span>);</span><br><span class="line">                <span class="type">String</span> <span class="variable">jsonMsg</span> <span class="operator">=</span> listingList.get(<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    <span class="type">NetListingHistory</span> <span class="variable">netListingHistory</span> <span class="operator">=</span> JSON.parseObject(jsonMsg, NetListingHistory.class);</span><br><span class="line">                    <span class="comment">// 此时已被注入，非null.</span></span><br><span class="line">                    NetListingConsumer.<span class="built_in">this</span>.netListingService.save(netListingHistory);</span><br><span class="line">                    log.info(<span class="string">&quot;[消费REDIS消息队列listingList数据成功.]&quot;</span>);</span><br><span class="line">                &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                    log.error(<span class="string">&quot;[消费REDIS消息队列listingList数据失败，失败信息:&#123;&#125;]&quot;</span>, e.getMessage());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-通过外部引入"><a href="#2-通过外部引入" class="headerlink" title="2.通过外部引入"></a>2.通过外部引入</h2><p>在通过Thread子类的构造函数引入</p>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉搜索树.md</title>
    <url>/2024/12/06/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    <content><![CDATA[<h2 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h2><ol>
<li>左子树中的所有节点的值 &lt; 根节点的值 &lt; 右子树中所有节点的值</li>
<li>对于任意节点，都要满足1</li>
<li>中序遍历，是升序的。使用O(n)的时间复杂度即可获取到有序数组</li>
<li>频繁的插入和删除操作可能会导致二叉树退化为链表</li>
</ol>
<h3 id="与数组的时间复杂度比较"><a href="#与数组的时间复杂度比较" class="headerlink" title="与数组的时间复杂度比较"></a>与数组的时间复杂度比较</h3><p><img  
                     lazyload
                     alt="image"
                     data-src="https://ancyxing.github.io/picx-images-hosting/20241206/image.8hgiw7l6oj.webp"
                      alt="img"
                ></p>
<h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 查找节点 */</span></span><br><span class="line">TreeNode <span class="title function_">search</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">    <span class="comment">// 循环查找，越过叶节点后跳出</span></span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 目标节点在 cur 的右子树中</span></span><br><span class="line">        <span class="keyword">if</span> (cur.val &lt; num)</span><br><span class="line">            cur = cur.right;</span><br><span class="line">        <span class="comment">// 目标节点在 cur 的左子树中</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cur.val &gt; num)</span><br><span class="line">            cur = cur.left;</span><br><span class="line">        <span class="comment">// 找到目标节点，跳出循环</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回目标节点</span></span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查找目标值为num的节点，循环次数最多为二叉树的高度，时间复杂度为O(logn)</p>
<h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><ul>
<li>二叉搜索树不允许存在重复节点，否则将违反其定义。若待插入节点在树中已存在，则不执行插入直接返回。（只能在叶子节点上进行插入）</li>
<li>为了实现插入节点，我们需要借助节点 pre 保存上一轮循环的节点。这样在遍历至 None 时，我们可以获取到其父节点，从而完成节点插入操作。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 插入节点 */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">    <span class="comment">// 若树为空，则初始化根节点</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(num);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> root, pre = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 循环查找，越过叶节点后跳出</span></span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 找到重复节点，直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (cur.val == num)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        pre = cur;</span><br><span class="line">        <span class="comment">// 插入位置在 cur 的右子树中</span></span><br><span class="line">        <span class="keyword">if</span> (cur.val &lt; num)</span><br><span class="line">            cur = cur.right;</span><br><span class="line">        <span class="comment">// 插入位置在 cur 的左子树中</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cur = cur.left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 插入节点</span></span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(num);</span><br><span class="line">    <span class="keyword">if</span> (pre.val &lt; num)</span><br><span class="line">        pre.right = node;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        pre.left = node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
时间复杂度为O(logn)</li>
</ul>
<h2 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h2><p>待删除节点的度为0：<br><img  
                     lazyload
                     alt="image"
                     data-src="https://ancyxing.github.io/picx-images-hosting/20241207/image.6m3y4opgp6.webp"
                      alt="删除度为0的节点"
                ><br>待删除节点的度为1：<br><img  
                     lazyload
                     alt="image"
                     data-src="https://ancyxing.github.io/picx-images-hosting/20241207/image.syzve28wf.webp"
                      alt="删除度为1的节点"
                ></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 删除节点 */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">    <span class="comment">// 若树为空，直接提前返回</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> root, pre = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 循环查找，越过叶节点后跳出</span></span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 找到待删除节点，跳出循环</span></span><br><span class="line">        <span class="keyword">if</span> (cur.val == num)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        pre = cur;</span><br><span class="line">        <span class="comment">// 待删除节点在 cur 的右子树中</span></span><br><span class="line">        <span class="keyword">if</span> (cur.val &lt; num)</span><br><span class="line">            cur = cur.right;</span><br><span class="line">        <span class="comment">// 待删除节点在 cur 的左子树中</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cur = cur.left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 若无待删除节点，则直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (cur == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 子节点数量 = 0 or 1</span></span><br><span class="line">    <span class="keyword">if</span> (cur.left == <span class="literal">null</span> || cur.right == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 当子节点数量 = 0 或 1 时， child = null 或 该子节点</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">child</span> <span class="operator">=</span> cur.left != <span class="literal">null</span> ? cur.left : cur.right;</span><br><span class="line">        <span class="comment">// 删除节点 cur</span></span><br><span class="line">        <span class="keyword">if</span> (cur != root) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pre.left == cur)</span><br><span class="line">                pre.left = child;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                pre.right = child;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 若删除节点为根节点，则重新指定根节点</span></span><br><span class="line">            root = child;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 子节点数量 = 2</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 获取中序遍历中 cur 的下一个节点（找到右子树中值最小的节点）</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">tmp</span> <span class="operator">=</span> cur.right;</span><br><span class="line">        <span class="keyword">while</span> (tmp.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            tmp = tmp.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找到后，递归删除节点 tmp</span></span><br><span class="line">        remove(tmp.val);</span><br><span class="line">        <span class="comment">// 用 tmp 覆盖 cur</span></span><br><span class="line">        cur.val = tmp.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度为O(logn)，其中查找待删除节点需要O(logn)，获取中序遍历后继节点需要O(logn)</p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树.md</title>
    <url>/2024/12/05/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h2 id="常见术语"><a href="#常见术语" class="headerlink" title="常见术语"></a>常见术语</h2><ol>
<li>边：连接两个节点的线段</li>
<li>节点所在层：从顶至底递增，根节点所在层为1</li>
<li>节点的度：节点的子节点数量，二叉树中的取值范围是0、1、2</li>
<li>节点的深度：从根节点到该节点所经过的边的数量 </li>
<li>二叉树的高度：从根节点到最远叶子节点所经过的边的数量</li>
<li>节点的高度：从距离该节点最远的叶节点到该节点所经过的边的数量</li>
</ol>
<h2 id="常见二叉树的类型"><a href="#常见二叉树的类型" class="headerlink" title="常见二叉树的类型"></a>常见二叉树的类型</h2><h3 id="完美二叉树"><a href="#完美二叉树" class="headerlink" title="完美二叉树"></a>完美二叉树</h3><p>也称为满二叉树，叶节点的度为0，其余节点的度为2，若树的高度为h，则节点总数为2^(h+1) -1</p>
<h3 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h3><p>只有最底层的节点没有被填满，且底层节点尽量靠左填充，完美二叉树也是一个完全二叉树</p>
<h3 id="完满二叉树"><a href="#完满二叉树" class="headerlink" title="完满二叉树"></a>完满二叉树</h3><p>除了叶子节点的度为0，其余节点的度为2，且叶子节点不需要写靠左填充</p>
<h3 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h3><p>任意节点的左子树与右子树的高度之差的绝对值不超过1</p>
<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>当只有左子树或只有右子树时，二叉树会形似成链表</p>
<h2 id="计算公式"><a href="#计算公式" class="headerlink" title="计算公式"></a>计算公式</h2><p><img  
                     lazyload
                     alt="image"
                     data-src="https://ancyxing.github.io/picx-images-hosting/20241206/image.3yehssafgp.webp"
                      alt="img.png"
                ></p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的表示方式.md</title>
    <url>/2024/12/06/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%A1%A8%E7%A4%BA%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="数组表示"><a href="#数组表示" class="headerlink" title="数组表示"></a>数组表示</h2><p>按照层序遍历的顺序将数据存储在数组中，一层接一层存储，每一层的元素从左往右</p>
<h3 id="一些计算公式"><a href="#一些计算公式" class="headerlink" title="一些计算公式"></a>一些计算公式</h3><p>某个节点的索引下标为<strong>i</strong>，则该节点的左子节点索引为<strong>2i+1</strong>，右子节点索引为<strong>2i+2</strong></p>
<h3 id="表示任意二叉树"><a href="#表示任意二叉树" class="headerlink" title="表示任意二叉树"></a>表示任意二叉树</h3><p>使用null填充空位，层序遍历就可以唯一表示二叉树了。<strong>完全二叉树非常适合使用数组来表示</strong>，因为空只出现在最底层且靠右的位置，可以省略存储所有 None</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 层序遍历 */</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">levelOrder</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 直接遍历数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (val(i) != <span class="literal">null</span>) res.add(val(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的遍历.md</title>
    <url>/2024/12/06/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<h2 id="二叉树的遍历方式"><a href="#二叉树的遍历方式" class="headerlink" title="二叉树的遍历方式"></a>二叉树的遍历方式</h2><h2 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h2><p>从顶部到底部逐层遍历二叉树，并在每一层按照从左到右的顺序访问节点，属于<strong>广度优先遍历</strong>。</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>基于队列进行实现，逐层推进与先进先出的思想相符</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 层序遍历 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="comment">// 初始化队列，加入根节点</span></span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    queue.add(root);</span><br><span class="line">    <span class="comment">// 初始化一个列表，用于保存遍历序列</span></span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll(); <span class="comment">// 队列出队</span></span><br><span class="line">        list.add(node.val);           <span class="comment">// 保存节点值</span></span><br><span class="line">        <span class="comment">// 先左再右</span></span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="literal">null</span>)</span><br><span class="line">            queue.offer(node.left);   <span class="comment">// 左子节点入队</span></span><br><span class="line">        <span class="keyword">if</span> (node.right != <span class="literal">null</span>)</span><br><span class="line">            queue.offer(node.right);  <span class="comment">// 右子节点入队</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度为O(n)，每个节点遍历一次</p>
<p>空间复杂度为O(n)，节点总数为n的满二叉树，最底层的叶节点数量为(n+1)&#x2F;2，遍历到最底层之前，队列中最多同时存在(n+1)&#x2F;2<br>个节点</p>
<h2 id="前序、中序、后续遍历"><a href="#前序、中序、后续遍历" class="headerlink" title="前序、中序、后续遍历"></a>前序、中序、后续遍历</h2><p>属于<strong>深度优先遍历</strong>，先走到头，再回溯继续的遍历方式，深度优先遍历就像是绕着整棵二叉树的外围“走”一圈</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 递归实现</span></span><br><span class="line"><span class="comment"> * 前序遍历</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 访问优先级：根节点 -&gt; 左子树 -&gt; 右子树</span></span><br><span class="line">    list.add(root.val);</span><br><span class="line">    preOrder(root.left);</span><br><span class="line">    preOrder(root.right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 前序遍历，使用栈实现</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> root</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preOrder2</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="comment">// 创建栈,加入根节点</span></span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    stack.push(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">pop</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">        System.out.println(pop.val);</span><br><span class="line">        <span class="keyword">if</span> (pop.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            stack.push(pop.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pop.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            stack.push(pop.left);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 中序遍历 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">inOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 访问优先级：左子树 -&gt; 根节点 -&gt; 右子树</span></span><br><span class="line">    inOrder(root.left);</span><br><span class="line">    list.add(root.val);</span><br><span class="line">    inOrder(root.right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 后序遍历 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">postOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 访问优先级：左子树 -&gt; 右子树 -&gt; 根节点</span></span><br><span class="line">    postOrder(root.left);</span><br><span class="line">    postOrder(root.right);</span><br><span class="line">    list.add(root.val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度为O(n)，每个节点遍历一次</p>
<p>空间复杂度为O(n)，在最差情况下，即树退化为链表时，递归深度达到 ，系统占用O(n)栈帧</p>
<h2 id="递归的一些感悟"><a href="#递归的一些感悟" class="headerlink" title="递归的一些感悟"></a>递归的一些感悟</h2><ol>
<li>定义一套处理流程和结束条件，每一个人都得遵守</li>
<li>包含递进和回溯两个过程</li>
<li>剩下的交给计算机</li>
</ol>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>平衡二叉树.md</title>
    <url>/2024/12/07/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ol>
<li>各种操作的时间复杂度保持在O(logn)，有高效的数据操作性能</li>
<li>适用于高频查找、低频增删的场景</li>
<li>是平衡二叉搜索树</li>
<li>红黑树也是一种常见的平衡二叉搜索树</li>
</ol>
<h2 id="常见术语"><a href="#常见术语" class="headerlink" title="常见术语"></a>常见术语</h2><h3 id="节点的高度"><a href="#节点的高度" class="headerlink" title="节点的高度"></a>节点的高度</h3><p>从该节点到最远叶子节点所经过的边的数量，叶子节点的高度为0，空节点的高度为-1</p>
<h3 id="节点的平衡因子"><a href="#节点的平衡因子" class="headerlink" title="节点的平衡因子"></a>节点的平衡因子</h3><p>节点左子树的高度减去节点右子树的高度，空节点的平衡因子为0 ，一棵 AVL 树的任意节点的平衡因子都在区间[-1,1]中</p>
<h2 id="平衡树的旋转"><a href="#平衡树的旋转" class="headerlink" title="平衡树的旋转"></a>平衡树的旋转</h2><p><strong>旋转</strong>操作既能保持<strong>二叉搜索树</strong>的性质，也能使树重新变为<strong>平衡二叉树</strong>，将平衡因子绝对值&gt;1的节点称为<strong>失衡节点</strong>，根据节点失衡情况的不同，旋转操作分为四种：<strong>右旋</strong>、<strong>左旋</strong>、<strong>先右旋后左旋</strong>、<strong>先左旋后右旋</strong></p>
<h3 id="右旋"><a href="#右旋" class="headerlink" title="右旋"></a>右旋</h3><p>当子节点没有有右子节点时：<br><img  
                     lazyload
                     alt="image"
                     data-src="https://ancyxing.github.io/picx-images-hosting/20241207/image.83a36dddnb.webp"
                      alt="右旋"
                ><br><img  
                     lazyload
                     alt="image"
                     data-src="https://ancyxing.github.io/picx-images-hosting/20241207/image.83a36dfuij.webp"
                      alt="右旋"
                ><br>当子节点有右子节点时：<br><img  
                     lazyload
                     alt="image"
                     data-src="https://ancyxing.github.io/picx-images-hosting/20241207/image.b8y6qotrf.webp"
                      alt="右旋"
                ></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 右旋操作 */</span></span><br><span class="line">TreeNode <span class="title function_">rightRotate</span><span class="params">(TreeNode node)</span> &#123;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">child</span> <span class="operator">=</span> node.left;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">grandChild</span> <span class="operator">=</span> child.right;</span><br><span class="line">    <span class="comment">// 以 child 为原点，将 node 向右旋转</span></span><br><span class="line">    child.right = node;</span><br><span class="line">    node.left = grandChild;</span><br><span class="line">    <span class="comment">// 更新节点高度</span></span><br><span class="line">    updateHeight(node);</span><br><span class="line">    updateHeight(child);</span><br><span class="line">    <span class="comment">// 返回旋转后子树的根节点</span></span><br><span class="line">    <span class="keyword">return</span> child;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="左旋"><a href="#左旋" class="headerlink" title="左旋"></a>左旋</h3><p>当子节点有左节点时：<br><img  
                     lazyload
                     alt="image"
                     data-src="https://ancyxing.github.io/picx-images-hosting/20241207/image.pfdxm2pf6.webp"
                      alt="左旋"
                ></p>
<p>当子节点没有左节点时：<br><img  
                     lazyload
                     alt="image"
                     data-src="https://ancyxing.github.io/picx-images-hosting/20241207/image.7pc911u8k.webp"
                      alt="左旋"
                ></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 左旋操作 */</span></span><br><span class="line">TreeNode <span class="title function_">leftRotate</span><span class="params">(TreeNode node)</span> &#123;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">child</span> <span class="operator">=</span> node.right;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">grandChild</span> <span class="operator">=</span> child.left;</span><br><span class="line">    <span class="comment">// 以 child 为原点，将 node 向左旋转</span></span><br><span class="line">    child.left = node;</span><br><span class="line">    node.right = grandChild;</span><br><span class="line">    <span class="comment">// 更新节点高度</span></span><br><span class="line">    updateHeight(node);</span><br><span class="line">    updateHeight(child);</span><br><span class="line">    <span class="comment">// 返回旋转后子树的根节点</span></span><br><span class="line">    <span class="keyword">return</span> child;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="先左旋后右旋"><a href="#先左旋后右旋" class="headerlink" title="先左旋后右旋"></a>先左旋后右旋</h3><p><img  
                     lazyload
                     alt="image"
                     data-src="https://ancyxing.github.io/picx-images-hosting/20241207/image.32i0etlxkk.webp"
                      alt="先左旋后右旋"
                ></p>
<h3 id="先右旋后左旋"><a href="#先右旋后左旋" class="headerlink" title="先右旋后左旋"></a>先右旋后左旋</h3><p><img  
                     lazyload
                     alt="image"
                     data-src="https://ancyxing.github.io/picx-images-hosting/20241207/image.9gwmaf51us.webp"
                      alt="先右旋后左旋"
                ></p>
<h3 id="旋转的实现"><a href="#旋转的实现" class="headerlink" title="旋转的实现"></a>旋转的实现</h3><p><img  
                     lazyload
                     alt="image"
                     data-src="https://ancyxing.github.io/picx-images-hosting/20241207/image.1zib3xsu7b.webp"
                      alt="旋转总结"
                ><br><img  
                     lazyload
                     alt="image"
                     data-src="https://ancyxing.github.io/picx-images-hosting/20241207/image.1hs9fcv6wt.webp"
                      alt="旋转的选择"
                ></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 执行旋转操作，使该子树重新恢复平衡 */</span></span><br><span class="line">TreeNode <span class="title function_">rotate</span><span class="params">(TreeNode node)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取节点 node 的平衡因子</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">balanceFactor</span> <span class="operator">=</span> balanceFactor(node);</span><br><span class="line">    <span class="comment">// 左偏树</span></span><br><span class="line">    <span class="keyword">if</span> (balanceFactor &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (balanceFactor(node.left) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 右旋</span></span><br><span class="line">            <span class="keyword">return</span> rightRotate(node);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 先左旋后右旋</span></span><br><span class="line">            node.left = leftRotate(node.left);</span><br><span class="line">            <span class="keyword">return</span> rightRotate(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 右偏树</span></span><br><span class="line">    <span class="keyword">if</span> (balanceFactor &lt; -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (balanceFactor(node.right) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 左旋</span></span><br><span class="line">            <span class="keyword">return</span> leftRotate(node);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 先右旋后左旋</span></span><br><span class="line">            node.right = rightRotate(node.right);</span><br><span class="line">            <span class="keyword">return</span> leftRotate(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 平衡树，无须旋转，直接返回</span></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h2><h3 id="添加节点"><a href="#添加节点" class="headerlink" title="添加节点"></a>添加节点</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 插入节点 */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">    root = insertHelper(root, val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 递归插入节点（辅助方法） */</span></span><br><span class="line">TreeNode <span class="title function_">insertHelper</span><span class="params">(TreeNode node, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(val);</span><br><span class="line">    <span class="comment">/* 1. 查找插入位置并插入节点 */</span></span><br><span class="line">    <span class="keyword">if</span> (val &lt; node.val)</span><br><span class="line">        node.left = insertHelper(node.left, val);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (val &gt; node.val)</span><br><span class="line">        node.right = insertHelper(node.right, val);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> node; <span class="comment">// 重复节点不插入，直接返回</span></span><br><span class="line">    updateHeight(node); <span class="comment">// 更新节点高度</span></span><br><span class="line">    <span class="comment">/* 2. 执行旋转操作，使该子树重新恢复平衡 */</span></span><br><span class="line">    node = rotate(node);</span><br><span class="line">    <span class="comment">// 返回子树的根节点</span></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 删除节点 */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">    root = removeHelper(root, val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 递归删除节点（辅助方法） */</span></span><br><span class="line">TreeNode <span class="title function_">removeHelper</span><span class="params">(TreeNode node, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">/* 1. 查找节点并删除 */</span></span><br><span class="line">    <span class="keyword">if</span> (val &lt; node.val)</span><br><span class="line">        node.left = removeHelper(node.left, val);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (val &gt; node.val)</span><br><span class="line">        node.right = removeHelper(node.right, val);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node.left == <span class="literal">null</span> || node.right == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">child</span> <span class="operator">=</span> node.left != <span class="literal">null</span> ? node.left : node.right;</span><br><span class="line">            <span class="comment">// 子节点数量 = 0 ，直接删除 node 并返回</span></span><br><span class="line">            <span class="keyword">if</span> (child == <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">// 子节点数量 = 1 ，直接删除 node</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                node = child;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 子节点数量 = 2 ，则将中序遍历的下个节点删除，并用该节点替换当前节点</span></span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> node.right;</span><br><span class="line">            <span class="keyword">while</span> (temp.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                temp = temp.left;</span><br><span class="line">            &#125;</span><br><span class="line">            node.right = removeHelper(node.right, temp.val);</span><br><span class="line">            node.val = temp.val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    updateHeight(node); <span class="comment">// 更新节点高度</span></span><br><span class="line">    <span class="comment">/* 2. 执行旋转操作，使该子树重新恢复平衡 */</span></span><br><span class="line">    node = rotate(node);</span><br><span class="line">    <span class="comment">// 返回子树的根节点</span></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>冒泡排序.md</title>
    <url>/2024/12/17/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>通过<strong>连续地比较与交换相邻元素</strong>实现排序，每一轮中的最大元素移动到数组的右端</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bubbleSort</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">// 外层循环表示需要排序的次数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> nums.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">// 每一轮找到一个最大值</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="comment">// 相邻元素比较，交换位置上的值</span></span><br><span class="line">                <span class="keyword">if</span> (nums[j] &gt; nums[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[j + <span class="number">1</span>];</span><br><span class="line">                    nums[j + <span class="number">1</span>] = nums[j];</span><br><span class="line">                    nums[j] = temp;</span><br><span class="line">                    flag = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果没有任何交换，则认为完成排序</span></span><br><span class="line">            <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Arrays.toString(nums));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度为O(n^2)，完全有序时为O(n)</li>
<li>空间复杂度为O(1)，原地排序</li>
<li>稳定排序，相邻的相等元素不进行交换</li>
</ul>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>快速排序.md</title>
    <url>/2024/12/17/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>是一种基于分治策略的排序算法，选择数组中的某个元素作为<strong>基准数</strong>，将所有小于基准数的元素移到其左侧，而大于基准数的元素移到其右侧，直到数组长度为1时结束。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] array, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="comment">// 子数组长度为 1 时终止递归</span></span><br><span class="line">        <span class="keyword">if</span> (left &gt;= right)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 哨兵划分</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> partition(array, left, right);</span><br><span class="line">        <span class="comment">// 递归左子数组、右子数组</span></span><br><span class="line">        quickSort(array, left, pivot - <span class="number">1</span>);</span><br><span class="line">        quickSort(array, pivot + <span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] array, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="comment">// 设置基准元素</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">base</span> <span class="operator">=</span> array[left];</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> right;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="comment">// 先从右至左，寻找比标准元素小的，没找到移动j</span></span><br><span class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; array[j] &gt;= base) &#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 先从左至右，寻找比标准元素大的，没找到移动i</span></span><br><span class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; array[i] &lt;= base) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 交换i，j位置上的元素</span></span><br><span class="line">            swap(array, i, j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 交换base与left</span></span><br><span class="line">        swap(array, i, left);</span><br><span class="line">        <span class="comment">// 此时的i为分界线</span></span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>选取数组最左端元素作为基准数，初始化两个指针 i 和 j 分别指向数组的两端。</li>
<li>设置一个循环，在每轮中使用 i（j）分别寻找第一个比基准数大（小）的元素，然后交换这两个元素。</li>
<li>循环执行步骤 2.，直到 i 和 j 相遇时停止，最后将基准数交换至两个子数组的分界线。</li>
</ol>
<ul>
<li>时间复杂度为O(nlog(n))，完全逆序时为O(n^2)</li>
<li>空间复杂度为O(n)，原地排序</li>
<li>不稳定排序，在哨兵划分的最后一步，基准数可能会被交换至相等元素的右侧</li>
</ul>
<p>每轮哨兵划分操作都将长度为n 的数组划分为长度为0 和n-1 的两个子数组，此时递归层数达到n ，每层中的循环数为n ，总体使用O(n^2)<br>时间。</p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>ElasticSearch中的中文分词器</title>
    <url>/2023/08/06/ES/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ElasticSearch%E4%B8%AD%E7%9A%84%E4%B8%AD%E6%96%87%E5%88%86%E8%AF%8D%E5%99%A8/</url>
    <content><![CDATA[<h1 id="内置分词器"><a href="#内置分词器" class="headerlink" title="内置分词器"></a>内置分词器</h1><p>ElasticSearch 核心功能就是数据检索，首先通过索引将文档写入 es。查询分析则主要分为两个步骤：</p>
<ol>
<li>词条化：分词器将输入的文本转为一个一个的词条流。</li>
<li>过滤：比如停用词过滤器会从词条中去除不相干的词条（的，嗯，啊，呢）；另外还有同义词过滤器、小写过滤器等。</li>
</ol>
<p>ElasticSearch中内置了多种分词器可以供使用<br>内置分词器：<br><img  
                     lazyload
                     alt="image"
                     data-src="https://note.youdao.com/yws/res/2715/BD09480AAE114297AE56354E9C1A6B00"
                      alt="image"
                ></p>
<h1 id="中文分词器"><a href="#中文分词器" class="headerlink" title="中文分词器"></a>中文分词器</h1><p> 在 Es 中，使用较多的中文分词器是 elasticsearch-analysis-ik，这个是 es 的一个第三方插件，代码托管在 GitHub 上：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://github.com/medcl/elasticsearch-analysis-ik</span><br></pre></td></tr></table></figure>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>两种使用方式：</p>
<h3 id="第一种："><a href="#第一种：" class="headerlink" title="第一种："></a>第一种：</h3><ol>
<li>首先打开分词器官网：<a class="link"   href="https://github.com/medcl/elasticsearch-analysis-ik%E3%80%82" >https://github.com/medcl/elasticsearch-analysis-ik。<i class="fas fa-external-link-alt"></i></a></li>
<li>在 <a class="link"   href="https://github.com/medcl/elasticsearch-analysis-ik/releases" >https://github.com/medcl/elasticsearch-analysis-ik/releases<i class="fas fa-external-link-alt"></i></a> 页面找到最新的正式版，下载下来。我们这里的下载链接是 <a class="link"   href="https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v7.9.3/elasticsearch-analysis-ik-7.9.3.zip%E3%80%82" >https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v7.9.3/elasticsearch-analysis-ik-7.9.3.zip。<i class="fas fa-external-link-alt"></i></a></li>
<li>将下载文件解压。</li>
<li>在 es&#x2F;plugins 目录下，新建 ik 目录，并将解压后的所有文件拷贝到 ik 目录下。</li>
<li>重启 es 服务。</li>
</ol>
<h3 id="第二种"><a href="#第二种" class="headerlink" title="第二种"></a>第二种</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./bin/elasticsearch-plugin install https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v7.9.3/elasticsearch-analysis-ik-7.9.3.zip</span><br></pre></td></tr></table></figure>
<h3 id="ik-max-word-和-ik-smart-什么区别"><a href="#ik-max-word-和-ik-smart-什么区别" class="headerlink" title="ik_max_word 和 ik_smart 什么区别?"></a>ik_max_word 和 ik_smart 什么区别?</h3><ul>
<li>ik_max_word: 会将文本做最细粒度的拆分，比如会将“中华人民共和国国歌”拆分为“中华人民共和国,中华人民,中华,华人,人民共和国,人民,人,民,共和国,共和,和,国国,国歌”，<strong>会穷尽各种可能的组合</strong>，适合 Term Query；</li>
<li>ik_smart: <strong>会做最粗粒度的拆分</strong>，比如会将“中华人民共和国国歌”拆分为“中华人民共和国,国歌”，适合 Phrase 查询。</li>
</ul>
<h3 id="自定义扩展词库或热更新-IK-分词使用方法"><a href="#自定义扩展词库或热更新-IK-分词使用方法" class="headerlink" title="自定义扩展词库或热更新 IK 分词使用方法"></a>自定义扩展词库或热更新 IK 分词使用方法</h3><p>修改IKAnalyzer.cfg.xml对应的配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE properties SYSTEM &quot;http://java.sun.com/dtd/properties.dtd&quot;&gt;</span><br><span class="line">&lt;properties&gt;</span><br><span class="line">	&lt;comment&gt;IK Analyzer 扩展配置&lt;/comment&gt;</span><br><span class="line">	&lt;!--用户可以在这里配置自己的扩展字典 --&gt;</span><br><span class="line">	&lt;entry key=&quot;ext_dict&quot;&gt;&lt;/entry&gt;</span><br><span class="line">	 &lt;!--用户可以在这里配置自己的扩展停止词字典--&gt;</span><br><span class="line">	&lt;entry key=&quot;ext_stopwords&quot;&gt;&lt;/entry&gt;</span><br><span class="line">	&lt;!--用户可以在这里配置远程扩展字典 --&gt;</span><br><span class="line">	&lt;!-- &lt;entry key=&quot;remote_ext_dict&quot;&gt;words_location&lt;/entry&gt; --&gt;</span><br><span class="line">	&lt;!--用户可以在这里配置远程扩展停止词字典--&gt;</span><br><span class="line">	&lt;!-- &lt;entry key=&quot;remote_ext_stopwords&quot;&gt;words_location&lt;/entry&gt; --&gt;</span><br><span class="line">&lt;/properties&gt;</span><br></pre></td></tr></table></figure>
<p><strong>热更新注意点：</strong><br>其中 location 是指一个 url，比如 <a class="link"   href="http://yoursite.com/getCustomDict" >http://yoursite.com/getCustomDict<i class="fas fa-external-link-alt"></i></a> ，该请求只需满足以下两点即可完成分词热更新。</p>
<ol>
<li>该 http 请求需要返回两个头部(header)，一个是 Last-Modified，一个是 ETag，这两者都是字符串类型，只要有一个发生变化，该插件就会去抓取新的分词进而更新词库。</li>
<li>该 http 请求返回的内容格式是一行一个分词，换行符用 \n 即可。</li>
</ol>
<p>满足上面两点要求就可以实现热更新分词了，不需要重启 ES 实例。</p>
]]></content>
      <tags>
        <tag>es</tag>
      </tags>
  </entry>
  <entry>
    <title>ElasticSearch中的倒排索引到底是什么</title>
    <url>/2023/08/06/ES/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ElasticSearch%E4%B8%AD%E7%9A%84%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95%E5%88%B0%E5%BA%95%E6%98%AF%E4%BB%80%E4%B9%88/</url>
    <content><![CDATA[<p>倒排索引是 es 中非常重要的索引结构，是从文档词项到文档 ID 的一个映射过程。</p>
<h1 id="“正排索引”"><a href="#“正排索引”" class="headerlink" title="“正排索引”"></a>“正排索引”</h1><p>我们在关系型数据库中见到的索引，就是“正排索引”。<br>关系型数据库中的索引如下，假设我有一个博客表：<br><img  
                     lazyload
                     alt="image"
                     data-src="https://note.youdao.com/yws/res/2987/1A57CD1792724F86BE3BFAC310F34D42"
                      alt="image"
                ><br>我们可以针对这个表建立索引（正排索引）：<br><img  
                     lazyload
                     alt="image"
                     data-src="https://note.youdao.com/yws/res/2990/0903BFDAA25A46AFBE7CDABFFD51E5B7"
                      alt="image"
                ></p>
<p>当我们通过 id 或者标题去搜索文章时，就可以快速搜到。</p>
<p>但是如果我们按照文章内容的关键字去搜索，就只能去内容中做字符匹配了。为了提高查询效率，就要考虑使用倒排索引。</p>
<h1 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h1><p>倒排索引就是以内容的关键字建立索引，通过索引找到文档 id，再进而找到整个文档。<br><img  
                     lazyload
                     alt="image"
                     data-src="https://note.youdao.com/yws/res/2995/07D2257311E447CB95B99AFEBD9FDBBA"
                      alt="image"
                ></p>
<p>一般来说，倒排索引分为两个部分：</p>
<ul>
<li>单词词典（记录所有的文档词项，以及词项到倒排列表的关联关系）</li>
<li>倒排列表（记录单词与对应的关系，由一系列倒排索引项组成，倒排索引项指：文档 id、词频（TF）（词项在文档中出现的次数，评分时使用）、位置（Position，词项在文档中分词的位置）、偏移（记录词项开始和结束的位置））</li>
</ul>
<p>当我们去索引一个文档时，就回建立倒排索引，搜索时，直接根据倒排索引搜索。</p>
]]></content>
      <tags>
        <tag>es</tag>
      </tags>
  </entry>
  <entry>
    <title>ElasticSearch动态映射与静态映射</title>
    <url>/2023/08/06/ES/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ElasticSearch%E5%8A%A8%E6%80%81%E6%98%A0%E5%B0%84%E4%B8%8E%E9%9D%99%E6%80%81%E6%98%A0%E5%B0%84/</url>
    <content><![CDATA[<p>映射就是 Mapping，它用来定义一个文档以及文档所包含的字段该如何被存储和索引。所以，它其实有点类似于关系型数据库中表的定义。</p>
<h1 id="映射分类"><a href="#映射分类" class="headerlink" title="映射分类"></a>映射分类</h1><h2 id="动态映射"><a href="#动态映射" class="headerlink" title="动态映射"></a>动态映射</h2><p>顾名思义，就是自动创建出来的映射。es 根据存入的文档，自动分析出来文档中字段的类型以及存储方式，这种就是动态映射。</p>
<p>举一个简单例子，新建一个索引，然后查看索引信息：<br><img  
                     lazyload
                     alt="image"
                     data-src="https://note.youdao.com/yws/res/3006/DBFC06C352054BEE9B0084AA4A12CA3D"
                      alt="image"
                ></p>
<p>在创建好的索引信息中，可以看到，mappings 为空，这个 mappings 中保存的就是映射信息。<br>现在我们向索引中添加一个文档，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PUT blog/_doc/1</span><br><span class="line">&#123;</span><br><span class="line">  &quot;title&quot;:&quot;1111&quot;,</span><br><span class="line">  &quot;date&quot;:&quot;2020-11-11&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ps: <strong>若索引不存在，会自动创建索引并添加文档</strong></p>
<p>文档添加成功后，就会自动生成 Mappings：<br><img  
                     lazyload
                     alt="image"
                     data-src="https://note.youdao.com/yws/res/3012/F114F8331DC14552859902E4800C3663"
                      alt="image"
                ></p>
<p>可以看到，date 字段的类型为 date，title 的类型有两个，text 和 keyword。</p>
<p>默认情况下，文档中如果新增了字段，mappings 中也会自动新增进来。</p>
<p>有的时候，如果希望新增字段时，能够抛出异常来提醒开发者，这个可以通过 mappings 中 dynamic 属性来配置。</p>
<p>dynamic 属性有三种取值：</p>
<ul>
<li>true，默认即此。自动添加新字段。</li>
<li>false，忽略新字段。</li>
<li>strict，严格模式，发现新字段会抛出异常。</li>
</ul>
<p>具体配置方式如下，创建索引时指定 mappings（这其实就是静态映射）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PUT blog</span><br><span class="line">&#123;</span><br><span class="line">  &quot;mappings&quot;: &#123;</span><br><span class="line">    &quot;dynamic&quot;:&quot;strict&quot;,</span><br><span class="line">    &quot;properties&quot;: &#123;</span><br><span class="line">      &quot;title&quot;:&#123;</span><br><span class="line">        &quot;type&quot;: &quot;text&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;age&quot;:&#123;</span><br><span class="line">        &quot;type&quot;:&quot;long&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后向 blog 中索引中添加数据：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PUT blog/_doc/2</span><br><span class="line">&#123;</span><br><span class="line">  &quot;title&quot;:&quot;1111&quot;,</span><br><span class="line">  &quot;date&quot;:&quot;2020-11-11&quot;,</span><br><span class="line">  &quot;age&quot;:99</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在添加的文档中，多出了一个 date 字段，而该字段没有预定义，所以这个添加操作就回报错：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;error&quot; : &#123;</span><br><span class="line">    &quot;root_cause&quot; : [</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;type&quot; : &quot;strict_dynamic_mapping_exception&quot;,</span><br><span class="line">        &quot;reason&quot; : &quot;mapping set to strict, dynamic introduction of [date] within [_doc] is not allowed&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;type&quot; : &quot;strict_dynamic_mapping_exception&quot;,</span><br><span class="line">    &quot;reason&quot; : &quot;mapping set to strict, dynamic introduction of [date] within [_doc] is not allowed&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;status&quot; : 400</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>动态映射还有一个日期检测</strong>的问题。</p>
<p>例如新建一个索引，然后添加一个含有日期的文档，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PUT blog/_doc/1</span><br><span class="line">&#123;</span><br><span class="line">  &quot;remark&quot;:&quot;2020-11-11&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>添加成功后，remark 字段会被推断是一个日期类型。<br><img  
                     lazyload
                     alt="image"
                     data-src="https://note.youdao.com/yws/res/3032/C1B6DFFD1CDD4C2AB553A57D2797E4FA"
                      alt="image"
                ></p>
<p>此时，remark 字段就无法存储其他类型了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PUT blog/_doc/1</span><br><span class="line">&#123;</span><br><span class="line">  &quot;remark&quot;:&quot;javaboy&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时报错如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;error&quot; : &#123;</span><br><span class="line">    &quot;root_cause&quot; : [</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;type&quot; : &quot;mapper_parsing_exception&quot;,</span><br><span class="line">        &quot;reason&quot; : &quot;failed to parse field [remark] of type [date] in document with id &#x27;1&#x27;. Preview of field&#x27;s value: &#x27;javaboy&#x27;&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;type&quot; : &quot;mapper_parsing_exception&quot;,</span><br><span class="line">    &quot;reason&quot; : &quot;failed to parse field [remark] of type [date] in document with id &#x27;1&#x27;. Preview of field&#x27;s value: &#x27;javaboy&#x27;&quot;,</span><br><span class="line">    &quot;caused_by&quot; : &#123;</span><br><span class="line">      &quot;type&quot; : &quot;illegal_argument_exception&quot;,</span><br><span class="line">      &quot;reason&quot; : &quot;failed to parse date field [javaboy] with format [strict_date_optional_time||epoch_millis]&quot;,</span><br><span class="line">      &quot;caused_by&quot; : &#123;</span><br><span class="line">        &quot;type&quot; : &quot;date_time_parse_exception&quot;,</span><br><span class="line">        &quot;reason&quot; : &quot;Failed to parse with all enclosed parsers&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;status&quot; : 400</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要解决这个问题，可以使用静态映射，即在索引定义时，将 remark 指定为 text 类型。也可以关闭日期检测。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PUT blog</span><br><span class="line">&#123;</span><br><span class="line">  &quot;mappings&quot;: &#123;</span><br><span class="line">    &quot;date_detection&quot;: false</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="静态映射"><a href="#静态映射" class="headerlink" title="静态映射"></a>静态映射</h1><p>创建索引时指定 mappings（这其实就是静态映射）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PUT blog</span><br><span class="line">&#123;</span><br><span class="line">  &quot;mappings&quot;: &#123;</span><br><span class="line">    &quot;dynamic&quot;:&quot;strict&quot;,</span><br><span class="line">    &quot;properties&quot;: &#123;</span><br><span class="line">      &quot;title&quot;:&#123;</span><br><span class="line">        &quot;type&quot;: &quot;text&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;age&quot;:&#123;</span><br><span class="line">        &quot;type&quot;:&quot;long&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="类型推断"><a href="#类型推断" class="headerlink" title="类型推断"></a>类型推断</h1><p>es 中动态映射类型推断方式如下：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://note.youdao.com/yws/res/3048/F69D4224AA1B4CA4B6D9A42CA4D381B2"
                      alt="image"
                ></p>
]]></content>
      <tags>
        <tag>es</tag>
      </tags>
  </entry>
  <entry>
    <title>ElasticSearch十大核心概念</title>
    <url>/2023/08/06/ES/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ElasticSearch%E5%8D%81%E5%A4%A7%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<h1 id="集群（Cluster）"><a href="#集群（Cluster）" class="headerlink" title="集群（Cluster）"></a>集群（Cluster）</h1><p>一个或者多个安装了 es 节点的服务器组织在一起，就是集群，这些节点共同持有数据，共同提供搜索服务。</p>
<p>一个集群有一个名字，这个名字是集群的唯一标识，该名字成为 cluster name，默认的集群名称是 elasticsearch，具有相同名称的节点才会组成一个集群。</p>
<p>可以在 config&#x2F;elasticsearch.yml 文件中配置集群名称：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cluster.name: javaboy-es</span><br></pre></td></tr></table></figure>
<p>在集群中，节点的状态有三种：绿色、黄色、红色：</p>
<ul>
<li>绿色：节点运行状态为健康状态。所有的主分片、副本分片都可以正常工作。</li>
<li>黄色：表示节点的运行状态为警告状态，所有的主分片目前都可以直接运行，但是至少有一个副本分片是不能正常工作的。</li>
<li>红色：表示集群无法正常工作。</li>
</ul>
<h1 id="节点（Node）"><a href="#节点（Node）" class="headerlink" title="节点（Node）"></a>节点（Node）</h1><p>集群中的一个服务器就是一个节点，节点中会存储数据，同时参与集群的索引以及搜索功能。<strong>一个节点想要加入一个集群，只需要配置一下集群名称即可</strong>。默认情况下，如果我们启动了多个节点，多个节点还能够互相发现彼此，那么它们会自动组成一个集群，这是 es 默认提供的，但是这种方式并不可靠，有可能会发生脑裂现象。所以在实际使用中，建议一定手动配置一下集群信息。</p>
<h1 id="索引（Index）"><a href="#索引（Index）" class="headerlink" title="索引（Index）"></a>索引（Index）</h1><p>索引可以从两方面来理解：</p>
<p><strong>名词</strong></p>
<p>具有相似特征文档的集合。</p>
<p><strong>动词</strong></p>
<p>索引数据</p>
<h1 id="类型（Type）"><a href="#类型（Type）" class="headerlink" title="类型（Type）"></a>类型（Type）</h1><p>类型是索引上的逻辑分类或者分区。<strong>在 es6 之前，一个索引中可以有多个类型，从 es7 开始，一个索引中，只能有一个类型。在 es6.x 中，依然保持了兼容，依然支持单 index 多个 type 结构，但是已经不建议这么使用</strong>。</p>
<h1 id="文档（Document）"><a href="#文档（Document）" class="headerlink" title="文档（Document）"></a>文档（Document）</h1><p>一个可以被索引的数据单元。例如一个用户的文档、一个产品的文档等等。文档都是 JSON 格式的。</p>
<h1 id="分片（Shards）"><a href="#分片（Shards）" class="headerlink" title="分片（Shards）"></a>分片（Shards）</h1><p>索引都是存储在节点上的，但是受限于节点的空间大小以及数据处理能力，单个节点的处理效果可能不理想，此时我们可以对索引进行分片。当我们创建一个索引的时候，就需要指定分片的数量。每个分片本身也是一个功能完善并且独立的索引。</p>
<p>默认情况下，一个索引会自动创建 1 个分片，并且为每一个分片创建一个副本。</p>
<h1 id="副本（Replicas）"><a href="#副本（Replicas）" class="headerlink" title="副本（Replicas）"></a>副本（Replicas）</h1><p>副本也就是备份，是对主分片的一个备份。</p>
<h1 id="Settings"><a href="#Settings" class="headerlink" title="Settings"></a>Settings</h1><p>集群中对索引的定义信息，例如索引的分片数、副本数等等。</p>
<h1 id="Mapping"><a href="#Mapping" class="headerlink" title="Mapping"></a>Mapping</h1><p>Mapping 保存了定义索引字段的存储类型、分词方式、是否存储等信息。</p>
<h1 id="Analyzer"><a href="#Analyzer" class="headerlink" title="Analyzer"></a>Analyzer</h1><p>字段分词方式的定义。</p>
<h1 id="ElasticSearch-Vs-关系型数据库"><a href="#ElasticSearch-Vs-关系型数据库" class="headerlink" title="ElasticSearch Vs 关系型数据库"></a>ElasticSearch Vs 关系型数据库</h1><p><img  
                     lazyload
                     alt="image"
                     data-src="https://note.youdao.com/yws/res/2697/B0654B419C064FCCBD4FFE6D21C6AF22"
                      alt="image"
                ></p>
]]></content>
      <tags>
        <tag>es</tag>
      </tags>
  </entry>
  <entry>
    <title>ElasticSearch四种字段类型详解</title>
    <url>/2023/08/06/ES/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ElasticSearch%E5%9B%9B%E7%A7%8D%E5%AD%97%E6%AE%B5%E7%B1%BB%E5%9E%8B%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="核心类型"><a href="#核心类型" class="headerlink" title="核心类型"></a>核心类型</h1><h2 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h2><ul>
<li>string：这是一个已经过期的字符串类型。在 es5 之前，用这个来描述字符串，现在的话，它已经被 text 和 keyword 替代了。</li>
<li>text：如果一个字段是要被全文检索的，比如说博客内容、新闻内容、产品描述，那么可以使用 text。<strong>用了 text 之后，字段内容会被分析</strong>，在生成倒排索引之前，字符串会被分词器分成一个个词项。text 类型的字段不用于排序，很少用于聚合。这种字符串也被称为 analyzed 字段。</li>
<li>keyword：这种类型适用于结构化的字段，例如标签、email 地址、手机号码等等，这种类型的字段可以用作过滤、排序、聚合等。这种字符串也称之为 <strong>not-analyzed 字段</strong>。</li>
</ul>
<h2 id="数字类型"><a href="#数字类型" class="headerlink" title="数字类型"></a>数字类型</h2><p><img  
                     lazyload
                     alt="image"
                     data-src="https://note.youdao.com/yws/res/3135/36406BBF659A464AB778E6AC13D0ECFA"
                      alt="image"
                ></p>
<p>在满足需求的情况下，优先使用范围小的字段。<strong>字段长度越短，索引和搜索的效率越高</strong>。<br>浮点数，优先考虑使用 scaled_float。</p>
<h2 id="日期类型"><a href="#日期类型" class="headerlink" title="日期类型"></a>日期类型</h2><p>由于 JSON 中没有日期类型，所以 es 中的日期类型形式就比较多样：</p>
<ul>
<li>2020-11-11 或者 2020-11-11 11:11:11</li>
<li>一个从 1970.1.1 零点到现在的一个秒数或者毫秒数。</li>
</ul>
<p>es 内部将时间转为 UTC，然后将时间按照 millseconds-since-the-epoch 的长整型来存储。<br>自定义日期类型：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PUT product</span><br><span class="line">&#123;</span><br><span class="line">  &quot;mappings&quot;: &#123;</span><br><span class="line">    &quot;properties&quot;: &#123;</span><br><span class="line">      &quot;date&quot;:&#123;</span><br><span class="line">        &quot;type&quot;: &quot;date&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个能够解析出来的时间格式比较多。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PUT product/_doc/1</span><br><span class="line">&#123;</span><br><span class="line">  &quot;date&quot;:&quot;2020-11-11&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT product/_doc/2</span><br><span class="line">&#123;</span><br><span class="line">  &quot;date&quot;:&quot;2020-11-11T11:11:11Z&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PUT product/_doc/3</span><br><span class="line">&#123;</span><br><span class="line">  &quot;date&quot;:&quot;1604672099958&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面三个文档中的日期都可以被解析，内部存储的是毫秒计时的长整型数。</p>
<h2 id="布尔类型（boolean）"><a href="#布尔类型（boolean）" class="headerlink" title="布尔类型（boolean）"></a>布尔类型（boolean）</h2><p>JSON 中的 “true”、“false”、true、false 都可以。</p>
<h2 id="二进制类型（binary）"><a href="#二进制类型（binary）" class="headerlink" title="二进制类型（binary）"></a>二进制类型（binary）</h2><p>二进制接受的是 base64 编码的字符串，默认不存储，也不可搜索。</p>
<h2 id="范围类型"><a href="#范围类型" class="headerlink" title="范围类型"></a>范围类型</h2><ol>
<li>integer_range</li>
<li>float_range</li>
<li>long_range</li>
<li>double_range</li>
<li>date_range</li>
<li>ip_range</li>
</ol>
<p>定义的时候，指定范围类型即可：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PUT product</span><br><span class="line">&#123;</span><br><span class="line">  &quot;mappings&quot;: &#123;</span><br><span class="line">    &quot;properties&quot;: &#123;</span><br><span class="line">      &quot;date&quot;:&#123;</span><br><span class="line">        &quot;type&quot;: &quot;date&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;price&quot;:&#123;</span><br><span class="line">        &quot;type&quot;:&quot;float_range&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>插入文档的时候，需要指定范围的界限：</p>
<p>指定范围的时，可以使用 gt、gte、lt、lte</p>
]]></content>
      <tags>
        <tag>es</tag>
      </tags>
  </entry>
  <entry>
    <title>ElasticSearch并发的处理方式锁和版本控制</title>
    <url>/2023/08/06/ES/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ElasticSearch%E5%B9%B6%E5%8F%91%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F%E9%94%81%E5%92%8C%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<p>当我们使用 es 的 API 去进行文档更新时，它首先读取原文档出来，然后对原文档进行更新，更新完成后再重新索引整个文档。不论你执行多少次更新，最终保存在 es 中的是最后一次更新的文档。但是如果有两个线程同时去更新，就有可能出问题。</p>
<p>要解决问题，就是锁。</p>
<h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><h2 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h2><p>很悲观，每一次去读取数据的时候，都认为别人可能会修改数据，所以屏蔽一切可能破坏数据完整性的操作。关系型数据库中，悲观锁使用较多，例如行锁、表锁等等。</p>
<h2 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h2><p>很乐观，每次读取数据时，都认为别人不会修改数据，因此也不锁定数据，只有在提交数据时，才会检查数据完整性。这种方式可以<strong>省去锁的开销，进而提高吞吐量</strong>。</p>
<p>在 es 中，实际上使用的就是乐观锁。</p>
<h1 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h1><h2 id="es6-7之前"><a href="#es6-7之前" class="headerlink" title="es6.7之前"></a>es6.7之前</h2><p>在 es6.7 之前，使用 version+version_type 来进行乐观并发控制。根据前面的介绍，文档每被修改一个，version 就会自增一次，es 通过 version 字段来确保所有的操作都有序进行。</p>
<p>version 分为内部版本控制和外部版本控制。</p>
<h3 id="内部版本"><a href="#内部版本" class="headerlink" title="内部版本"></a>内部版本</h3><p>es 自己维护的就是内部版本，当创建一个文档时，es 会给文档的版本赋值为 1。</p>
<p>每当用户修改一次文档，版本号就回自增 1。</p>
<p>如果使用内部版本，es 要求 version 参数的值必须和 es 文档中 version 的值相当，才能操作成功。</p>
<h3 id="外部版本"><a href="#外部版本" class="headerlink" title="外部版本"></a>外部版本</h3><p>也可以维护外部版本。</p>
<p>在添加文档时，就指定版本号：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PUT blog/_doc/1?version=200&amp;version_type=external</span><br><span class="line">&#123;</span><br><span class="line">  &quot;title&quot;:&quot;2222&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以后更新的时候，版本要大于已有的版本号。</p>
<ul>
<li>vertion_type&#x3D;external 或者 vertion_type&#x3D;external_gt 表示以后更新的时候，版本要大于已有的版本号。</li>
<li>vertion_type&#x3D;external_gte 表示以后更新的时候，版本要大于等于已有的版本号。</li>
</ul>
<h2 id="最新方案（Es6-7-之后）"><a href="#最新方案（Es6-7-之后）" class="headerlink" title="最新方案（Es6.7 之后）"></a>最新方案（Es6.7 之后）</h2><p>现在使用 if_seq_no 和 if_primary_term 两个参数来做并发控制。</p>
<p>seq_no 不属于某一个文档，它是属于整个索引的（version 则是属于某一个文档的，每个文档的 version 互不影响）。现在更新文档时，使用 seq_no 来做并发。由于 seq_no 是属于整个 index 的，所以任何文档的修改或者新增，seq_no 都会自增。</p>
<p>现在就可以通过 seq_no 和 primary_term 来做乐观并发控制。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PUT blog/_doc/2?if_seq_no=5&amp;if_primary_term=1</span><br><span class="line">&#123;</span><br><span class="line">  &quot;title&quot;:&quot;6666&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>es</tag>
      </tags>
  </entry>
  <entry>
    <title>ElasticSearch文档的删除</title>
    <url>/2023/08/06/ES/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ElasticSearch%E6%96%87%E6%A1%A3%E7%9A%84%E5%88%A0%E9%99%A4/</url>
    <content><![CDATA[<h1 id="删除文档"><a href="#删除文档" class="headerlink" title="删除文档"></a>删除文档</h1><h2 id="根据-id-删除"><a href="#根据-id-删除" class="headerlink" title="根据 id 删除"></a>根据 id 删除</h2><p>从索引中删除一个文档。</p>
<p>删除一个 id 为 TuUpmHUByGJWB5WuMasV 的文档。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELETE blog/_doc/TuUpmHUByGJWB5WuMasV</span><br></pre></td></tr></table></figure>
<p>如果在添加文档时指定了路由，则删除文档时也需要指定路由，否则删除失败。</p>
<h1 id="查询删除"><a href="#查询删除" class="headerlink" title="查询删除"></a>查询删除</h1><p>查询删除是 POST 请求。<br>例如删除 title 中包含 666 的文档：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST blog/_delete_by_query</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;:&#123;</span><br><span class="line">    &quot;term&quot;:&#123;</span><br><span class="line">      &quot;title&quot;:&quot;666&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以删除某一个索引下的所有文档：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST blog/_delete_by_query</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;:&#123;</span><br><span class="line">    &quot;match_all&quot;:&#123;</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>es</tag>
      </tags>
  </entry>
  <entry>
    <title>ElasticSearch文档的添加、获取</title>
    <url>/2023/08/06/ES/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ElasticSearch%E6%96%87%E6%A1%A3%E7%9A%84%E6%B7%BB%E5%8A%A0%E3%80%81%E8%8E%B7%E5%8F%96/</url>
    <content><![CDATA[<h1 id="新建文档"><a href="#新建文档" class="headerlink" title="新建文档"></a>新建文档</h1><p>首先新建一个索引。</p>
<p>然后向索引中添加一个文档：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PUT blog/_doc/1</span><br><span class="line">&#123;</span><br><span class="line">  &quot;title&quot;:&quot;6. ElasticSearch 文档基本操作&quot;,</span><br><span class="line">  &quot;date&quot;:&quot;2020-11-05&quot;,</span><br><span class="line">  &quot;content&quot;:&quot;hello world。&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1 表示新建文档的 id。<br>添加成功后，响应的 json 如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;_index&quot; : &quot;blog&quot;,</span><br><span class="line">  &quot;_type&quot; : &quot;_doc&quot;,</span><br><span class="line">  &quot;_id&quot; : &quot;1&quot;,</span><br><span class="line">  &quot;_version&quot; : 1,</span><br><span class="line">  &quot;result&quot; : &quot;created&quot;,</span><br><span class="line">  &quot;_shards&quot; : &#123;</span><br><span class="line">    &quot;total&quot; : 2,</span><br><span class="line">    &quot;successful&quot; : 2,</span><br><span class="line">    &quot;failed&quot; : 0</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;_seq_no&quot; : 0,</span><br><span class="line">  &quot;_primary_term&quot; : 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>_index 表示文档索引。</li>
<li>_type 表示文档的类型。</li>
<li>_id 表示文档的 id。</li>
<li>_version 表示文档的版本（更新文档，版本会自动加 1，针对一个文档的）。</li>
<li>result 表示执行结果。</li>
<li>_shards 表示分片信息。</li>
<li>_seq_no 和 _primary_term 这两个也是版本控制用的（针对当前 index）。</li>
</ul>
<p>添加成功后，可以查看添加的文档：<br><img  
                     lazyload
                     alt="image"
                     data-src="https://note.youdao.com/yws/res/3072/6BC6032E85C444E09A936DCB5EE53977"
                      alt="image"
                ><br>当然，添加文档时，也可以不指定 id，此时系统会默认给出一个 id，如果不指定 id，则需要使用 POST 请求，而不能使用 PUT 请求。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST blog/_doc</span><br><span class="line">&#123;</span><br><span class="line">  &quot;title&quot;:&quot;666&quot;,</span><br><span class="line">  &quot;date&quot;:&quot;2020-11-05&quot;,</span><br><span class="line">  &quot;content&quot;:&quot;hello world&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="获取文档"><a href="#获取文档" class="headerlink" title="获取文档"></a>获取文档</h1><p>Es 中提供了 GET API 来查看存储在 es 中的文档。使用方式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET blog/_doc/RuWrl3UByGJWB5WucKtP</span><br></pre></td></tr></table></figure>
<p>上面这个命令表示获取一个 id 为 RuWrl3UByGJWB5WucKtP 的文档。</p>
<p>如果获取不存在的文档，会返回如下信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;_index&quot; : &quot;blog&quot;,</span><br><span class="line">  &quot;_type&quot; : &quot;_doc&quot;,</span><br><span class="line">  &quot;_id&quot; : &quot;2&quot;,</span><br><span class="line">  &quot;found&quot; : false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果仅仅只是想探测某一个文档是否存在，可以使用 head 请求：<br>如果文档不存在，响应如下：<br><img  
                     lazyload
                     alt="image"
                     data-src="https://note.youdao.com/yws/res/3085/C44CB892703C434D93D349920C6C72CA"
                      alt="image"
                ><br>如果文档存在，响应如下：<br><img  
                     lazyload
                     alt="image"
                     data-src="https://note.youdao.com/yws/res/3088/D36F0D2D69B54653919298CA9699E89C"
                      alt="image"
                ><br>当然也可以批量获取文档。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET blog/_mget</span><br><span class="line">&#123;</span><br><span class="line">  &quot;ids&quot;:[&quot;1&quot;,&quot;RuWrl3UByGJWB5WucKtP&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里可能有小伙伴有疑问，GET 请求竟然可以携带请求体？</p>
<p>某些特定的语言，例如 JavaScript 的 HTTP 请求库是不允许 GET 请求有请求体的，实际上在 RFC7231 文档中，并没有规定 GET 请求的请求体该如何处理，这样造成了一定程度的混乱，有的 HTTP 服务器支持 GET 请求携带请求体，有的 HTTP 服务器则不支持。<strong>虽然 es 工程师倾向于使用 GET 做查询</strong>，但是为了保证兼容性，es 同时也支持使用 POST 查询。例如上面的批量查询案例，也可以使用 POST 请求。</p>
]]></content>
      <tags>
        <tag>es</tag>
      </tags>
  </entry>
  <entry>
    <title>ElasticSearch文档路由你的数据到底存在哪一个分片上</title>
    <url>/2023/08/06/ES/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ElasticSearch%E6%96%87%E6%A1%A3%E8%B7%AF%E7%94%B1%E4%BD%A0%E7%9A%84%E6%95%B0%E6%8D%AE%E5%88%B0%E5%BA%95%E5%AD%98%E5%9C%A8%E5%93%AA%E4%B8%80%E4%B8%AA%E5%88%86%E7%89%87%E4%B8%8A/</url>
    <content><![CDATA[<p>es 是一个分布式系统，当我们存储一个文档到 es 上之后，这个文档实际上是被存储到 master 节点中的某一个主分片上。<br>例如新建一个索引，该索引有两个分片，0个副本，如下:<br><img  
                     lazyload
                     alt="image"
                     data-src="https://note.youdao.com/yws/res/2934/8E90589EB2C0477397939902F6845533"
                      alt="image"
                ><br>接下来，向该索引中保存一个文档：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PUT blog/_doc/a</span><br><span class="line">&#123;</span><br><span class="line">  &quot;title&quot;:&quot;a&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>文档保存成功后，可以查看该文档被保存到哪个分片中去了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET _cat/shards/blog?v</span><br></pre></td></tr></table></figure>
<p>查看结果如下：<br><img  
                     lazyload
                     alt="image"
                     data-src="https://note.youdao.com/yws/res/2942/C16AF9FFEAA64FFA8C5944CAE919CFFC"
                      alt="image"
                ><br>从这个结果中，可以看出，文档被保存到分片 0 中。</p>
<h2 id="es分配分片的规则"><a href="#es分配分片的规则" class="headerlink" title="es分配分片的规则"></a>es分配分片的规则</h2><p>es 中的路由机制是通过哈希算法，<strong>将具有相同哈希值的文档放到一个主分片中</strong>，分片位置的计算方式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shard=hash(routing) % number_of_primary_shards</span><br></pre></td></tr></table></figure>


<p>routing 可以是一个任意字符串，<strong>es 默认是将文档的 id 作为 routing 值</strong>，通过哈希函数根据 routing 生成一个数字，然后将该数字和分片数取余，取余的结果就是分片的位置。</p>
<h3 id="优缺点："><a href="#优缺点：" class="headerlink" title="优缺点："></a>优缺点：</h3><p>默认的这种路由模式，<strong>最大的优势在于负载均衡</strong>，这种方式可以保证数据平均分配在不同的分片上。</p>
<p>但是他有一个很大的劣势，就是<strong>查询时候无法确定文档的位置</strong>，此时它会将请求广播到所有的分片上去执行。另一方面，使用默认的路由模式，后期修改分片数量不方便。</p>
<p>当然开发者也可以自定义 routing 的值，方式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PUT blog/_doc/d?routing=javaboy</span><br><span class="line">&#123;</span><br><span class="line">  &quot;title&quot;:&quot;d&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果文档在添加时指定了 routing，则查询、删除、更新时也需要指定 routing。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET blog/_doc/d?routing=javaboy</span><br></pre></td></tr></table></figure>
<p>自定义 routing 有可能会导致负载不均衡，这个还是要结合实际情况选择。</p>
]]></content>
      <tags>
        <tag>es</tag>
      </tags>
  </entry>
  <entry>
    <title>ElasticSearch的安装</title>
    <url>/2023/08/06/ES/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ElasticSearch%E7%9A%84%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h1 id="单节点安装"><a href="#单节点安装" class="headerlink" title="单节点安装"></a>单节点安装</h1><ol>
<li>首先打开 Es 官网，找到 Elasticsearch：<a class="link"   href="https://www.elastic.co/cn/elasticsearch/" >https://www.elastic.co/cn/elasticsearch/<i class="fas fa-external-link-alt"></i></a> 下载安装合适版本</li>
<li>将下载的文件解压，解压后的目录含义如下：</li>
</ol>
<table>
<thead>
<tr>
<th>目录</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>modules</td>
<td>依赖模块目录</td>
</tr>
<tr>
<td>lib</td>
<td>第三方依赖库</td>
</tr>
<tr>
<td>logs</td>
<td>输出日志目录</td>
</tr>
<tr>
<td>plugins</td>
<td>插件目录</td>
</tr>
<tr>
<td>bin</td>
<td>可执行文件目录</td>
</tr>
<tr>
<td>config</td>
<td>配置文件目录</td>
</tr>
<tr>
<td>data</td>
<td>数据存储目录</td>
</tr>
<tr>
<td>3. 启动方式：进入到 bin 目录下，直接执行 .&#x2F;elasticsearch 启动即可。</td>
<td></td>
</tr>
<tr>
<td>4. 配置集群名字及节点名称</td>
<td></td>
</tr>
<tr>
<td>打开 config&#x2F;elasticsearch.yml 文件</td>
<td></td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cluster.name: javaboy-es</span><br><span class="line">node.name: master</span><br></pre></td></tr></table></figure>
<p>配置完成后保存配置并重启es</p>
<h1 id="HEAD-插件安装"><a href="#HEAD-插件安装" class="headerlink" title="HEAD 插件安装"></a>HEAD 插件安装</h1><p>Elasticsearch-head 插件，可以通过可视化的方式查看集群信息。<br><img  
                     lazyload
                     alt="image"
                     data-src="https://note.youdao.com/yws/res/2644/586148F9953047FD8BC0C9D1E44AC95B"
                      alt="image"
                ><br>注意，此时看不到集群数据。原因在于这里通过跨域的方式请求集群数据的，默认情况下，集群不支持跨域，所以这里就看不到集群数据。</p>
<p>解决办法如下，修改 es 的 config&#x2F;elasticsearch.yml 配置文件，添加如下内容，使之支持跨域：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http.cors.enabled: true</span><br><span class="line">http.cors.allow-origin: &quot;*&quot;</span><br></pre></td></tr></table></figure>
<p>配置完成后，重启 es，此时 head 上就有数据了。<br><img  
                     lazyload
                     alt="image"
                     data-src="https://note.youdao.com/yws/res/2650/8D03F9BD4DE54FFF84DB71A74DB9E7D8"
                      alt="image"
                ></p>
<p><strong>ps: 如果是通过浏览器插件查看则没有上述问题</strong></p>
]]></content>
      <tags>
        <tag>es</tag>
      </tags>
  </entry>
  <entry>
    <title>ElasticSearch简介</title>
    <url>/2023/08/06/ES/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ElasticSearch%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h1 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h1><p>ElasticSearch 是一个<strong>分布式、可扩展、近实时性的高性能搜索与数据分析引擎</strong>。ElasticSearch 基于 Java 编写，通过进一步封装 Lucene，将搜索的复杂性屏蔽起来，开发者只需要一套简单的 RESTful API 就可以操作全文检索，它支持 PB 级别的结构化或非结构化海量数据处理。</p>
<h1 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h1><ul>
<li>数据搜集</li>
<li>数据分析</li>
<li><strong>数据存储</strong></li>
</ul>
<h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h1><ul>
<li>分布式文件存储。</li>
<li>实时分析的分布式搜索引擎。</li>
<li>高可拓展性。</li>
<li>可插拔的插件支持。</li>
</ul>
]]></content>
      <tags>
        <tag>es</tag>
      </tags>
  </entry>
  <entry>
    <title>ElasticSearch索引基本操作</title>
    <url>/2023/08/06/ES/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ElasticSearch%E7%B4%A2%E5%BC%95%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h1 id="新建索引"><a href="#新建索引" class="headerlink" title="新建索引"></a>新建索引</h1><h2 id="通过-head-插件新建索引"><a href="#通过-head-插件新建索引" class="headerlink" title="通过 head 插件新建索引"></a>通过 head 插件新建索引</h2><p>在 head 插件中，选择 索引选项卡，然后点击新建索引。新建索引时，需要填入索引名称、分片数以及副本数。<br><img  
                     lazyload
                     alt="image"
                     data-src="https://note.youdao.com/yws/res/2766/DBC22C0D17BC433CAAB444B3AB7BADD7"
                      alt="image"
                ><br>创建成功后：<br><img  
                     lazyload
                     alt="image"
                     data-src="https://note.youdao.com/yws/res/2767/E5B0940F73354B65BC229DCC77563F82"
                      alt="image"
                ><br>0、1、2、3、4 分别表示索引的分片，粗框表示主分片，细框表示副本（点一下框，通过 primary 属性可以查看是主分片还是副本）。</p>
<h2 id="通过请求创建"><a href="#通过请求创建" class="headerlink" title="通过请求创建"></a>通过请求创建</h2><p>可以通过 postman 发送请求，也可以通过 kibana 发送请求，由于 kibana 有提示，所以这里采用 kibana。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PUT book</span><br></pre></td></tr></table></figure>

<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ol>
<li>索引名称不能有大写字母</li>
<li>索引名是唯一的，不能重复，重复创建会出错</li>
</ol>
]]></content>
      <tags>
        <tag>es</tag>
      </tags>
  </entry>
  <entry>
    <title>kibana安装</title>
    <url>/2023/08/06/ES/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/kibana%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h1 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h1><p>Kibana 是一个 Elastic 公司推出的一个针对 es 的分析以及数据可视化平台，可以搜索、查看存放在 es 中的数据。</p>
<h1 id="安装步骤如下"><a href="#安装步骤如下" class="headerlink" title="安装步骤如下"></a>安装步骤如下</h1><ol>
<li>下载 Kibana：<a class="link"   href="https://www.elastic.co/cn/downloads/kibana" >https://www.elastic.co/cn/downloads/kibana<i class="fas fa-external-link-alt"></i></a></li>
<li>解压</li>
<li>配置 es 的地址信息（可选，如果 es 是默认地址以及端口，可以不用配置，具体的配置文件是 config&#x2F;kibana.yml）</li>
<li>执行 .&#x2F;bin&#x2F;kibana 文件启动</li>
<li>localhost:5601</li>
</ol>
]]></content>
      <tags>
        <tag>es</tag>
      </tags>
  </entry>
  <entry>
    <title>什么是Lucene</title>
    <url>/2023/08/06/ES/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%BB%80%E4%B9%88%E6%98%AFLucene/</url>
    <content><![CDATA[<h1 id="Lucene"><a href="#Lucene" class="headerlink" title="Lucene"></a>Lucene</h1><h2 id="什么是Lucene"><a href="#什么是Lucene" class="headerlink" title="什么是Lucene"></a>什么是Lucene</h2><p>Lucene 是一个开源、免费、高性能、纯 Java 编写的全文检索引擎，可以算作是开源领域最好的全文检索工具包。</p>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>在实际开发中，Lucene 几乎适用于任何需要全文检索的场景</p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul>
<li>简单</li>
<li>跨语言</li>
<li>强大的搜索引擎</li>
<li>索引速度快</li>
<li>索引文件兼容不同平台</li>
</ul>
<h2 id="具体使用"><a href="#具体使用" class="headerlink" title="具体使用"></a>具体使用</h2><p>不过需要注意的是，<strong>Lucene 只是一个工具包</strong>，并非一个完整的搜索引擎，开发者可以基于 Lucene 来开发完整的搜索引擎。比较著名的有 Solr、ElasticSearch，不过<strong>在分布式和大数据环境下</strong>，<strong>ElasticSearch</strong> 更胜一筹</p>
]]></content>
      <tags>
        <tag>es</tag>
      </tags>
  </entry>
  <entry>
    <title>删除索引</title>
    <url>/2023/08/06/ES/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%88%A0%E9%99%A4%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<h1 id="head-插件可以删除索引"><a href="#head-插件可以删除索引" class="headerlink" title="head 插件可以删除索引"></a>head 插件可以删除索引</h1><p><img  
                     lazyload
                     alt="image"
                     data-src="https://note.youdao.com/yws/res/2835/5FFFAA4516894E33A53B2666357C103D"
                      alt="image"
                ></p>
<h1 id="请求删除如下"><a href="#请求删除如下" class="headerlink" title="请求删除如下"></a>请求删除如下</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELETE test</span><br></pre></td></tr></table></figure>
<p>删除一个不存在的索引会报错。</p>
]]></content>
      <tags>
        <tag>es</tag>
      </tags>
  </entry>
  <entry>
    <title>复制索引</title>
    <url>/2023/08/06/ES/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%A4%8D%E5%88%B6%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<p>索引复制，只会复制数据，不会复制索引配置。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST _reindex</span><br><span class="line">&#123;</span><br><span class="line">  &quot;source&quot;: &#123;&quot;index&quot;:&quot;book&quot;&#125;,</span><br><span class="line">  &quot;dest&quot;: &#123;&quot;index&quot;:&quot;book_new&quot;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复制的时候，可以添加查询条件。</p>
]]></content>
      <tags>
        <tag>es</tag>
      </tags>
  </entry>
  <entry>
    <title>复合类型</title>
    <url>/2023/08/06/ES/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h1><p>es 中没有专门的数组类型。默认情况下，任何字段都可以有一个或者多个值。<strong>需要注意的是，数组中的元素必须是同一种类型</strong>。</p>
<p>添加数组是，数组中的第一个元素决定了整个数组的类型。</p>
<h1 id="对象类型（object）"><a href="#对象类型（object）" class="headerlink" title="对象类型（object）"></a>对象类型（object）</h1><p>由于 JSON 本身具有层级关系，所以文档包含内部对象。内部对象中，还可以再包含内部对象。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PUT product/_doc/2</span><br><span class="line">&#123;</span><br><span class="line">  &quot;date&quot;:&quot;2020-11-11T11:11:11Z&quot;,</span><br><span class="line">  &quot;ext_info&quot;:&#123;</span><br><span class="line">    &quot;address&quot;:&quot;China&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="嵌套类型（nested）"><a href="#嵌套类型（nested）" class="headerlink" title="嵌套类型（nested）"></a>嵌套类型（nested）</h1><p>还是有点难以理解呢？</p>
<p>nested 是 object 中的一个特例。</p>
<p>如果使用 object 类型，假如有如下一个文档：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;user&quot;:[</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;first&quot;:&quot;Zhang&quot;,</span><br><span class="line">      &quot;last&quot;:&quot;san&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;first&quot;:&quot;Li&quot;,</span><br><span class="line">      &quot;last&quot;:&quot;si&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于 Lucene 没有内部对象的概念，所以 es 会将对象层次扁平化，将一个对象转为字段名和值构成的简单列表。即上面的文档，最终存储形式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;user.first&quot;:[&quot;Zhang&quot;,&quot;Li&quot;],</span><br><span class="line">&quot;user.last&quot;:[&quot;san&quot;,&quot;si&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>扁平化之后，用户名之间的关系没了。这样会导致如果搜索 Zhang si 这个人，会搜索到。</p>
<p>此时可以 nested 类型来解决问题，nested 对象类型可以保持数组中每个对象的独立性。nested 类型将数组中的<strong>每一对对象作为独立隐藏文档来索引</strong>，这样每一个嵌套对象都可以独立被索引。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&#123;</span><br><span class="line">&quot;user.first&quot;:&quot;Zhang&quot;,</span><br><span class="line">&quot;user.last&quot;:&quot;san&quot;</span><br><span class="line">&#125;,&#123;</span><br><span class="line">&quot;user.first&quot;:&quot;Li&quot;,</span><br><span class="line">&quot;user.last&quot;:&quot;si&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>文档存储在一起，读取性能高。</p>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>更新父或者子文档时需要更新整个文档。</p>
]]></content>
      <tags>
        <tag>es</tag>
      </tags>
  </entry>
  <entry>
    <title>批量操作</title>
    <url>/2023/08/06/ES/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%89%B9%E9%87%8F%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p>批量操作</p>
<p>es 中通过 Bulk API 可以执行批量索引、批量删除、批量更新等操作。</p>
<p>首先需要将所有的批量操作写入一个 JSON 文件中，然后通过 POST 请求将该 JSON 文件上传并执行。</p>
<p>例如新建一个名为 aaa.json 的文件，内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&quot;index&quot;: &#123;&quot;_index&quot;:&quot;user&quot;, &quot;_id&quot;:&quot;666&quot;&#125;&#125;</span><br><span class="line">&#123;&quot;name&quot;: &quot;java&quot;&#125;</span><br><span class="line">&#123;&quot;update&quot;: &#123;&quot;_index&quot;:&quot;user&quot;, &quot;_id&quot;:&quot;666&quot;&#125;&#125;</span><br><span class="line">&#123;&quot;doc&quot;:&#123;&quot;name&quot;:&quot;java666&quot;&#125;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>首先第一行：index 表示要执行一个索引操作（<strong>这个表示一个 action，其他的 action 还有 create，delete，update</strong>）。_index 定义了索引名称，这里表示要创建一个名为 user 的索引，_id 表示新建文档的 id 为 666。</p>
<p>第二行是第一行操作的参数。</p>
<p>第三行的 update 则表示要更新。</p>
<p>第四行是第三行的参数。</p>
<p>注意，结尾要空出一行。</p>
<p>aaa.json 文件创建成功后，在该目录下，执行请求命令，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -XPOST &quot;http://localhost:9200/user/_bulk&quot; -H &quot;content-type:application/json&quot; --data-binary @aaa.json</span><br></pre></td></tr></table></figure>

<p><img  
                     lazyload
                     alt="image"
                     data-src="https://note.youdao.com/yws/res/2925/C4A0DC8DA14B47448462DFB5B8D1F383"
                      alt="image"
                ></p>
]]></content>
      <tags>
        <tag>es</tag>
      </tags>
  </entry>
  <entry>
    <title>文档更新</title>
    <url>/2023/08/06/ES/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%96%87%E6%A1%A3%E6%9B%B4%E6%96%B0/</url>
    <content><![CDATA[<h1 id="普通更新"><a href="#普通更新" class="headerlink" title="普通更新"></a>普通更新</h1><p>注意，文档更新一次，version 就会自增 1。</p>
<p>可以直接更新整个文档：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PUT blog/_doc/RuWrl3UByGJWB5WucKtP</span><br><span class="line">&#123;</span><br><span class="line">  &quot;title&quot;:&quot;666&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方式，更新的文档会覆盖掉原文档。</p>
<p>大多数时候，我们只是想更新文档字段，这个可以通过脚本来实现。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST blog/_update/1</span><br><span class="line">&#123;</span><br><span class="line">  &quot;script&quot;: &#123;</span><br><span class="line">    &quot;lang&quot;: &quot;painless&quot;,</span><br><span class="line">    &quot;source&quot;:&quot;ctx._source.title=params.title&quot;,</span><br><span class="line">    &quot;params&quot;: &#123;</span><br><span class="line">      &quot;title&quot;:&quot;666666&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更新的请求格式：POST {index}&#x2F;_update&#x2F;{id}</p>
<p>在脚本中，lang 表示脚本语言，painless 是 es 内置的一种脚本语言。<strong>source 表示具体执行的脚本</strong>，<strong>ctx 是一个上下文对象</strong>，通过 ctx 可以访问到 _source、_title 等。</p>
<p>也可以向文档中添加字段：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST blog/_update/1</span><br><span class="line">&#123;</span><br><span class="line">  &quot;script&quot;: &#123;</span><br><span class="line">    &quot;lang&quot;: &quot;painless&quot;,</span><br><span class="line">    &quot;source&quot;:&quot;ctx._source.tags=[\&quot;java\&quot;,\&quot;php\&quot;]&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>添加成功后的文档如下：<br><img  
                     lazyload
                     alt="image"
                     data-src="https://note.youdao.com/yws/res/3111/37671D243F294CD0BE5A509F8A3254BA"
                      alt="image"
                ><br>通过脚本语言，也可以修改数组。例如再增加一个 tag：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST blog/_update/1</span><br><span class="line">&#123;</span><br><span class="line">  &quot;script&quot;:&#123;</span><br><span class="line">    &quot;lang&quot;: &quot;painless&quot;,</span><br><span class="line">    &quot;source&quot;:&quot;ctx._source.tags.add(\&quot;js\&quot;)&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，也可以使用 if else 构造稍微复杂一点的逻辑。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST blog/_update/1</span><br><span class="line">&#123;</span><br><span class="line">  &quot;script&quot;: &#123;</span><br><span class="line">    &quot;lang&quot;: &quot;painless&quot;,</span><br><span class="line">    &quot;source&quot;: &quot;if (ctx._source.tags.contains(\&quot;java\&quot;))&#123;ctx.op=\&quot;delete\&quot;&#125;else&#123;ctx.op=\&quot;none\&quot;&#125;&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="查询更新"><a href="#查询更新" class="headerlink" title="查询更新"></a>查询更新</h1><p>通过条件查询找到文档，然后再去更新。</p>
<p>例如将 title 中包含 666 的文档的 content 修改为 888。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST blog/_update_by_query</span><br><span class="line">&#123;</span><br><span class="line">  &quot;script&quot;: &#123;</span><br><span class="line">    &quot;source&quot;: &quot;ctx._source.content=\&quot;888\&quot;&quot;,</span><br><span class="line">    &quot;lang&quot;: &quot;painless&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;term&quot;: &#123;</span><br><span class="line">      &quot;title&quot;:&quot;666&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>es</tag>
      </tags>
  </entry>
  <entry>
    <title>映射参数-boost</title>
    <url>/2023/08/06/ES/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%98%A0%E5%B0%84%E5%8F%82%E6%95%B0-boost/</url>
    <content><![CDATA[<h1 id="boost"><a href="#boost" class="headerlink" title="boost"></a>boost</h1><p>boost 参数可以设置字段的权重。</p>
<p>boost 有两种使用思路，一种就是在定义 mappings 的时候使用，在指定字段类型时使用；另一种就是在查询时使用。</p>
<p>实际开发中建议使用后者，前者有问题：如果不重新索引文档，权重无法修改。<br>mapping 中使用 boost（不推荐）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PUT blog</span><br><span class="line">&#123;</span><br><span class="line">  &quot;mappings&quot;: &#123;</span><br><span class="line">    &quot;properties&quot;: &#123;</span><br><span class="line">      &quot;content&quot;:&#123;</span><br><span class="line">        &quot;type&quot;: &quot;text&quot;,</span><br><span class="line">        &quot;boost&quot;: 2</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另一种方式就是在查询的时候，指定 boost</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET blog/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match&quot;: &#123;</span><br><span class="line">      &quot;content&quot;: &#123;</span><br><span class="line">        &quot;query&quot;: &quot;你好&quot;,</span><br><span class="line">        &quot;boost&quot;: 2</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>es</tag>
      </tags>
  </entry>
  <entry>
    <title>映射参数-analyzer</title>
    <url>/2023/08/06/ES/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%98%A0%E5%B0%84%E5%8F%82%E6%95%B0-analyzer/</url>
    <content><![CDATA[<h1 id="analyzer"><a href="#analyzer" class="headerlink" title="analyzer"></a>analyzer</h1><p>定义文本字段的分词器。默认对索引和查询都是有效的。</p>
<blockquote>
<p>什么叫对索引和查询都是有效的？</p>
</blockquote>
<p>假设不用分词器，我们先来看一下索引的结果，创建一个索引并添加一个文档：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PUT blog</span><br><span class="line"></span><br><span class="line">PUT blog/_doc/1</span><br><span class="line">&#123;</span><br><span class="line">  &quot;title&quot;:&quot;定义文本字段的分词器。默认对索引和查询都是有效的。&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查看词条向量（term vectors）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET blog/_termvectors/1</span><br><span class="line">&#123;</span><br><span class="line">  &quot;fields&quot;: [&quot;title&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查看结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;_index&quot; : &quot;blog&quot;,</span><br><span class="line">  &quot;_type&quot; : &quot;_doc&quot;,</span><br><span class="line">  &quot;_id&quot; : &quot;1&quot;,</span><br><span class="line">  &quot;_version&quot; : 1,</span><br><span class="line">  &quot;found&quot; : true,</span><br><span class="line">  &quot;took&quot; : 0,</span><br><span class="line">  &quot;term_vectors&quot; : &#123;</span><br><span class="line">    &quot;title&quot; : &#123;</span><br><span class="line">      &quot;field_statistics&quot; : &#123;</span><br><span class="line">        &quot;sum_doc_freq&quot; : 22,</span><br><span class="line">        &quot;doc_count&quot; : 1,</span><br><span class="line">        &quot;sum_ttf&quot; : 23</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;terms&quot; : &#123;</span><br><span class="line">        &quot;义&quot; : &#123;</span><br><span class="line">          &quot;term_freq&quot; : 1,</span><br><span class="line">          &quot;tokens&quot; : [</span><br><span class="line">            &#123;</span><br><span class="line">              &quot;position&quot; : 1,</span><br><span class="line">              &quot;start_offset&quot; : 1,</span><br><span class="line">              &quot;end_offset&quot; : 2</span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;分&quot; : &#123;</span><br><span class="line">          &quot;term_freq&quot; : 1,</span><br><span class="line">          &quot;tokens&quot; : [</span><br><span class="line">            &#123;</span><br><span class="line">              &quot;position&quot; : 7,</span><br><span class="line">              &quot;start_offset&quot; : 7,</span><br><span class="line">              &quot;end_offset&quot; : 8</span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;和&quot; : &#123;</span><br><span class="line">          &quot;term_freq&quot; : 1,</span><br><span class="line">          &quot;tokens&quot; : [</span><br><span class="line">            &#123;</span><br><span class="line">              &quot;position&quot; : 15,</span><br><span class="line">              &quot;start_offset&quot; : 16,</span><br><span class="line">              &quot;end_offset&quot; : 17</span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;器&quot; : &#123;</span><br><span class="line">          &quot;term_freq&quot; : 1,</span><br><span class="line">          &quot;tokens&quot; : [</span><br><span class="line">            &#123;</span><br><span class="line">              &quot;position&quot; : 9,</span><br><span class="line">              &quot;start_offset&quot; : 9,</span><br><span class="line">              &quot;end_offset&quot; : 10</span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;字&quot; : &#123;</span><br><span class="line">          &quot;term_freq&quot; : 1,</span><br><span class="line">          &quot;tokens&quot; : [</span><br><span class="line">            &#123;</span><br><span class="line">              &quot;position&quot; : 4,</span><br><span class="line">              &quot;start_offset&quot; : 4,</span><br><span class="line">              &quot;end_offset&quot; : 5</span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;定&quot; : &#123;</span><br><span class="line">          &quot;term_freq&quot; : 1,</span><br><span class="line">          &quot;tokens&quot; : [</span><br><span class="line">            &#123;</span><br><span class="line">              &quot;position&quot; : 0,</span><br><span class="line">              &quot;start_offset&quot; : 0,</span><br><span class="line">              &quot;end_offset&quot; : 1</span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;对&quot; : &#123;</span><br><span class="line">          &quot;term_freq&quot; : 1,</span><br><span class="line">          &quot;tokens&quot; : [</span><br><span class="line">            &#123;</span><br><span class="line">              &quot;position&quot; : 12,</span><br><span class="line">              &quot;start_offset&quot; : 13,</span><br><span class="line">              &quot;end_offset&quot; : 14</span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;引&quot; : &#123;</span><br><span class="line">          &quot;term_freq&quot; : 1,</span><br><span class="line">          &quot;tokens&quot; : [</span><br><span class="line">            &#123;</span><br><span class="line">              &quot;position&quot; : 14,</span><br><span class="line">              &quot;start_offset&quot; : 15,</span><br><span class="line">              &quot;end_offset&quot; : 16</span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;效&quot; : &#123;</span><br><span class="line">          &quot;term_freq&quot; : 1,</span><br><span class="line">          &quot;tokens&quot; : [</span><br><span class="line">            &#123;</span><br><span class="line">              &quot;position&quot; : 21,</span><br><span class="line">              &quot;start_offset&quot; : 22,</span><br><span class="line">              &quot;end_offset&quot; : 23</span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;文&quot; : &#123;</span><br><span class="line">          &quot;term_freq&quot; : 1,</span><br><span class="line">          &quot;tokens&quot; : [</span><br><span class="line">            &#123;</span><br><span class="line">              &quot;position&quot; : 2,</span><br><span class="line">              &quot;start_offset&quot; : 2,</span><br><span class="line">              &quot;end_offset&quot; : 3</span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;是&quot; : &#123;</span><br><span class="line">          &quot;term_freq&quot; : 1,</span><br><span class="line">          &quot;tokens&quot; : [</span><br><span class="line">            &#123;</span><br><span class="line">              &quot;position&quot; : 19,</span><br><span class="line">              &quot;start_offset&quot; : 20,</span><br><span class="line">              &quot;end_offset&quot; : 21</span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;有&quot; : &#123;</span><br><span class="line">          &quot;term_freq&quot; : 1,</span><br><span class="line">          &quot;tokens&quot; : [</span><br><span class="line">            &#123;</span><br><span class="line">              &quot;position&quot; : 20,</span><br><span class="line">              &quot;start_offset&quot; : 21,</span><br><span class="line">              &quot;end_offset&quot; : 22</span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;本&quot; : &#123;</span><br><span class="line">          &quot;term_freq&quot; : 1,</span><br><span class="line">          &quot;tokens&quot; : [</span><br><span class="line">            &#123;</span><br><span class="line">              &quot;position&quot; : 3,</span><br><span class="line">              &quot;start_offset&quot; : 3,</span><br><span class="line">              &quot;end_offset&quot; : 4</span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;查&quot; : &#123;</span><br><span class="line">          &quot;term_freq&quot; : 1,</span><br><span class="line">          &quot;tokens&quot; : [</span><br><span class="line">            &#123;</span><br><span class="line">              &quot;position&quot; : 16,</span><br><span class="line">              &quot;start_offset&quot; : 17,</span><br><span class="line">              &quot;end_offset&quot; : 18</span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;段&quot; : &#123;</span><br><span class="line">          &quot;term_freq&quot; : 1,</span><br><span class="line">          &quot;tokens&quot; : [</span><br><span class="line">            &#123;</span><br><span class="line">              &quot;position&quot; : 5,</span><br><span class="line">              &quot;start_offset&quot; : 5,</span><br><span class="line">              &quot;end_offset&quot; : 6</span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;的&quot; : &#123;</span><br><span class="line">          &quot;term_freq&quot; : 2,</span><br><span class="line">          &quot;tokens&quot; : [</span><br><span class="line">            &#123;</span><br><span class="line">              &quot;position&quot; : 6,</span><br><span class="line">              &quot;start_offset&quot; : 6,</span><br><span class="line">              &quot;end_offset&quot; : 7</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">              &quot;position&quot; : 22,</span><br><span class="line">              &quot;start_offset&quot; : 23,</span><br><span class="line">              &quot;end_offset&quot; : 24</span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;索&quot; : &#123;</span><br><span class="line">          &quot;term_freq&quot; : 1,</span><br><span class="line">          &quot;tokens&quot; : [</span><br><span class="line">            &#123;</span><br><span class="line">              &quot;position&quot; : 13,</span><br><span class="line">              &quot;start_offset&quot; : 14,</span><br><span class="line">              &quot;end_offset&quot; : 15</span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;认&quot; : &#123;</span><br><span class="line">          &quot;term_freq&quot; : 1,</span><br><span class="line">          &quot;tokens&quot; : [</span><br><span class="line">            &#123;</span><br><span class="line">              &quot;position&quot; : 11,</span><br><span class="line">              &quot;start_offset&quot; : 12,</span><br><span class="line">              &quot;end_offset&quot; : 13</span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;词&quot; : &#123;</span><br><span class="line">          &quot;term_freq&quot; : 1,</span><br><span class="line">          &quot;tokens&quot; : [</span><br><span class="line">            &#123;</span><br><span class="line">              &quot;position&quot; : 8,</span><br><span class="line">              &quot;start_offset&quot; : 8,</span><br><span class="line">              &quot;end_offset&quot; : 9</span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;询&quot; : &#123;</span><br><span class="line">          &quot;term_freq&quot; : 1,</span><br><span class="line">          &quot;tokens&quot; : [</span><br><span class="line">            &#123;</span><br><span class="line">              &quot;position&quot; : 17,</span><br><span class="line">              &quot;start_offset&quot; : 18,</span><br><span class="line">              &quot;end_offset&quot; : 19</span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;都&quot; : &#123;</span><br><span class="line">          &quot;term_freq&quot; : 1,</span><br><span class="line">          &quot;tokens&quot; : [</span><br><span class="line">            &#123;</span><br><span class="line">              &quot;position&quot; : 18,</span><br><span class="line">              &quot;start_offset&quot; : 19,</span><br><span class="line">              &quot;end_offset&quot; : 20</span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;默&quot; : &#123;</span><br><span class="line">          &quot;term_freq&quot; : 1,</span><br><span class="line">          &quot;tokens&quot; : [</span><br><span class="line">            &#123;</span><br><span class="line">              &quot;position&quot; : 10,</span><br><span class="line">              &quot;start_offset&quot; : 11,</span><br><span class="line">              &quot;end_offset&quot; : 12</span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，默认情况下，中文就是一个字一个字的分，这种分词方式没有任何意义。如果这样分词，查询就只能按照一个字一个字来查，像下面这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET blog/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;term&quot;: &#123;</span><br><span class="line">      &quot;title&quot;: &quot;定&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>无意义！！！</p>
<p>所以，我们要根据实际情况，配置合适的分词器。</p>
<p>给字段设定分词器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PUT blog</span><br><span class="line">&#123;</span><br><span class="line">  &quot;mappings&quot;: &#123;</span><br><span class="line">    &quot;properties&quot;: &#123;</span><br><span class="line">      &quot;title&quot;:&#123;</span><br><span class="line">        &quot;type&quot;:&quot;text&quot;,</span><br><span class="line">        &quot;analyzer&quot;: &quot;ik_smart&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>存储文档：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PUT blog/_doc/1</span><br><span class="line">&#123;</span><br><span class="line">  &quot;title&quot;:&quot;定义文本字段的分词器。默认对索引和查询都是有效的。&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查看词条向量：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET blog/_termvectors/1</span><br><span class="line">&#123;</span><br><span class="line">  &quot;fields&quot;: [&quot;title&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查询结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;_index&quot; : &quot;blog&quot;,</span><br><span class="line">  &quot;_type&quot; : &quot;_doc&quot;,</span><br><span class="line">  &quot;_id&quot; : &quot;1&quot;,</span><br><span class="line">  &quot;_version&quot; : 1,</span><br><span class="line">  &quot;found&quot; : true,</span><br><span class="line">  &quot;took&quot; : 1,</span><br><span class="line">  &quot;term_vectors&quot; : &#123;</span><br><span class="line">    &quot;title&quot; : &#123;</span><br><span class="line">      &quot;field_statistics&quot; : &#123;</span><br><span class="line">        &quot;sum_doc_freq&quot; : 12,</span><br><span class="line">        &quot;doc_count&quot; : 1,</span><br><span class="line">        &quot;sum_ttf&quot; : 13</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;terms&quot; : &#123;</span><br><span class="line">        &quot;分词器&quot; : &#123;</span><br><span class="line">          &quot;term_freq&quot; : 1,</span><br><span class="line">          &quot;tokens&quot; : [</span><br><span class="line">            &#123;</span><br><span class="line">              &quot;position&quot; : 4,</span><br><span class="line">              &quot;start_offset&quot; : 7,</span><br><span class="line">              &quot;end_offset&quot; : 10</span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;和&quot; : &#123;</span><br><span class="line">          &quot;term_freq&quot; : 1,</span><br><span class="line">          &quot;tokens&quot; : [</span><br><span class="line">            &#123;</span><br><span class="line">              &quot;position&quot; : 8,</span><br><span class="line">              &quot;start_offset&quot; : 16,</span><br><span class="line">              &quot;end_offset&quot; : 17</span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;字段&quot; : &#123;</span><br><span class="line">          &quot;term_freq&quot; : 1,</span><br><span class="line">          &quot;tokens&quot; : [</span><br><span class="line">            &#123;</span><br><span class="line">              &quot;position&quot; : 2,</span><br><span class="line">              &quot;start_offset&quot; : 4,</span><br><span class="line">              &quot;end_offset&quot; : 6</span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;定义&quot; : &#123;</span><br><span class="line">          &quot;term_freq&quot; : 1,</span><br><span class="line">          &quot;tokens&quot; : [</span><br><span class="line">            &#123;</span><br><span class="line">              &quot;position&quot; : 0,</span><br><span class="line">              &quot;start_offset&quot; : 0,</span><br><span class="line">              &quot;end_offset&quot; : 2</span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;对&quot; : &#123;</span><br><span class="line">          &quot;term_freq&quot; : 1,</span><br><span class="line">          &quot;tokens&quot; : [</span><br><span class="line">            &#123;</span><br><span class="line">              &quot;position&quot; : 6,</span><br><span class="line">              &quot;start_offset&quot; : 13,</span><br><span class="line">              &quot;end_offset&quot; : 14</span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;文本&quot; : &#123;</span><br><span class="line">          &quot;term_freq&quot; : 1,</span><br><span class="line">          &quot;tokens&quot; : [</span><br><span class="line">            &#123;</span><br><span class="line">              &quot;position&quot; : 1,</span><br><span class="line">              &quot;start_offset&quot; : 2,</span><br><span class="line">              &quot;end_offset&quot; : 4</span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;有效&quot; : &#123;</span><br><span class="line">          &quot;term_freq&quot; : 1,</span><br><span class="line">          &quot;tokens&quot; : [</span><br><span class="line">            &#123;</span><br><span class="line">              &quot;position&quot; : 11,</span><br><span class="line">              &quot;start_offset&quot; : 21,</span><br><span class="line">              &quot;end_offset&quot; : 23</span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;查询&quot; : &#123;</span><br><span class="line">          &quot;term_freq&quot; : 1,</span><br><span class="line">          &quot;tokens&quot; : [</span><br><span class="line">            &#123;</span><br><span class="line">              &quot;position&quot; : 9,</span><br><span class="line">              &quot;start_offset&quot; : 17,</span><br><span class="line">              &quot;end_offset&quot; : 19</span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;的&quot; : &#123;</span><br><span class="line">          &quot;term_freq&quot; : 2,</span><br><span class="line">          &quot;tokens&quot; : [</span><br><span class="line">            &#123;</span><br><span class="line">              &quot;position&quot; : 3,</span><br><span class="line">              &quot;start_offset&quot; : 6,</span><br><span class="line">              &quot;end_offset&quot; : 7</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">              &quot;position&quot; : 12,</span><br><span class="line">              &quot;start_offset&quot; : 23,</span><br><span class="line">              &quot;end_offset&quot; : 24</span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;索引&quot; : &#123;</span><br><span class="line">          &quot;term_freq&quot; : 1,</span><br><span class="line">          &quot;tokens&quot; : [</span><br><span class="line">            &#123;</span><br><span class="line">              &quot;position&quot; : 7,</span><br><span class="line">              &quot;start_offset&quot; : 14,</span><br><span class="line">              &quot;end_offset&quot; : 16</span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;都是&quot; : &#123;</span><br><span class="line">          &quot;term_freq&quot; : 1,</span><br><span class="line">          &quot;tokens&quot; : [</span><br><span class="line">            &#123;</span><br><span class="line">              &quot;position&quot; : 10,</span><br><span class="line">              &quot;start_offset&quot; : 19,</span><br><span class="line">              &quot;end_offset&quot; : 21</span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;默认&quot; : &#123;</span><br><span class="line">          &quot;term_freq&quot; : 1,</span><br><span class="line">          &quot;tokens&quot; : [</span><br><span class="line">            &#123;</span><br><span class="line">              &quot;position&quot; : 5,</span><br><span class="line">              &quot;start_offset&quot; : 11,</span><br><span class="line">              &quot;end_offset&quot; : 13</span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后就可以通过词去搜索了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET blog/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;term&quot;: &#123;</span><br><span class="line">      &quot;title&quot;: &quot;索引&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>es</tag>
      </tags>
  </entry>
  <entry>
    <title>映射参数-coerce</title>
    <url>/2023/08/06/ES/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%98%A0%E5%B0%84%E5%8F%82%E6%95%B0-coerce/</url>
    <content><![CDATA[<h1 id="coerce"><a href="#coerce" class="headerlink" title="coerce"></a>coerce</h1><p>coerce 用来清除脏数据，默认为 true。</p>
<p>例如一个数字，在 JSON 中，用户可能写错了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&quot;age&quot;:&quot;99&quot;&#125;</span><br></pre></td></tr></table></figure>
<p>或者 ：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&quot;age&quot;:&quot;99.0&quot;&#125;</span><br></pre></td></tr></table></figure>
<p>这些都不是正确的数字格式。</p>
<p>通过 coerce 可以解决该问题。</p>
<p>默认情况下，以下操作没问题，就是 coerce 起作用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PUT blog</span><br><span class="line">&#123;</span><br><span class="line">  &quot;mappings&quot;: &#123;</span><br><span class="line">    &quot;properties&quot;: &#123;</span><br><span class="line">      &quot;age&quot;:&#123;</span><br><span class="line">        &quot;type&quot;: &quot;integer&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">POST blog/_doc</span><br><span class="line">&#123;</span><br><span class="line">  &quot;age&quot;:&quot;99.0&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果需要修改 coerce ，方式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PUT blog</span><br><span class="line">&#123;</span><br><span class="line">  &quot;mappings&quot;: &#123;</span><br><span class="line">    &quot;properties&quot;: &#123;</span><br><span class="line">      &quot;age&quot;:&#123;</span><br><span class="line">        &quot;type&quot;: &quot;integer&quot;,</span><br><span class="line">        &quot;coerce&quot;: false</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">POST blog/_doc</span><br><span class="line">&#123;</span><br><span class="line">  &quot;age&quot;:99</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当 coerce 修改为 false 之后，数字就只能是数字了，不可以是字符串，该字段传入字符串会报错。</p>
]]></content>
      <tags>
        <tag>es</tag>
      </tags>
  </entry>
  <entry>
    <title>映射参数-copy_to</title>
    <url>/2023/08/06/ES/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%98%A0%E5%B0%84%E5%8F%82%E6%95%B0-copy_to/</url>
    <content><![CDATA[<h1 id="copy-to"><a href="#copy-to" class="headerlink" title="copy_to"></a>copy_to</h1><p>这个属性，可以将多个字段的值，复制到同一个字段中。</p>
<p>定义方式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PUT blog</span><br><span class="line">&#123;</span><br><span class="line">  &quot;mappings&quot;: &#123;</span><br><span class="line">    &quot;properties&quot;: &#123;</span><br><span class="line">      &quot;title&quot;:&#123;</span><br><span class="line">        &quot;type&quot;: &quot;text&quot;,</span><br><span class="line">        &quot;copy_to&quot;: &quot;full_content&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;content&quot;:&#123;</span><br><span class="line">        &quot;type&quot;: &quot;text&quot;,</span><br><span class="line">        &quot;copy_to&quot;: &quot;full_content&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;full_content&quot;:&#123;</span><br><span class="line">        &quot;type&quot;: &quot;text&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT blog/_doc/1</span><br><span class="line">&#123;</span><br><span class="line">  &quot;title&quot;:&quot;你好江南一点雨&quot;,</span><br><span class="line">  &quot;content&quot;:&quot;当 coerce 修改为 false 之后，数字就只能是数字了，不可以是字符串，该字段传入字符串会报错。&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GET blog/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;term&quot;: &#123;</span><br><span class="line">      &quot;full_content&quot;: &quot;当&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>不知道有啥用？</p>
</blockquote>
]]></content>
      <tags>
        <tag>es</tag>
      </tags>
  </entry>
  <entry>
    <title>映射参数-doc_values</title>
    <url>/2023/08/06/ES/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%98%A0%E5%B0%84%E5%8F%82%E6%95%B0-doc_values/</url>
    <content><![CDATA[<h1 id="doc-values"><a href="#doc-values" class="headerlink" title="doc_values"></a>doc_values</h1><p>es 中的搜索主要是用到倒排索引，doc_values 参数是为了<strong>加快排序、聚合操作</strong>而生的。<strong>当建立倒排索引的时候</strong>，会额外增加列式存储映射。<br><strong>doc_values 默认是开启的，如果确定某个字段不需要排序或者不需要聚合，那么可以关闭 doc_values</strong>。</p>
<p><strong>大部分的字段在索引时都会生成 doc_values，除了 text。text 字段在查询时会生成一个 fielddata 的数据结构，fieldata 在字段首次被聚合、排序的时候生成</strong>。</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://note.youdao.com/yws/res/3298/61DBEDB856994D7FB33031A64AC544AE"
                      alt="image"
                ></p>
<p>doc_values 默认开启，fielddata 默认关闭。</p>
<p>doc_values 演示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PUT users</span><br><span class="line"></span><br><span class="line">PUT users/_doc/1</span><br><span class="line">&#123;</span><br><span class="line">  &quot;age&quot;:100</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT users/_doc/2</span><br><span class="line">&#123;</span><br><span class="line">  &quot;age&quot;:99</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT users/_doc/3</span><br><span class="line">&#123;</span><br><span class="line">  &quot;age&quot;:98</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT users/_doc/4</span><br><span class="line">&#123;</span><br><span class="line">  &quot;age&quot;:101</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GET users/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match_all&quot;: &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;sort&quot;:[</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;age&quot;:&#123;</span><br><span class="line">        &quot;order&quot;: &quot;desc&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于 doc_values 默认时开启的，所以可以直接使用该字段排序，如果想关闭 doc_values ，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PUT users</span><br><span class="line">&#123;</span><br><span class="line">  &quot;mappings&quot;: &#123;</span><br><span class="line">    &quot;properties&quot;: &#123;</span><br><span class="line">      &quot;age&quot;:&#123;</span><br><span class="line">        &quot;type&quot;: &quot;integer&quot;,</span><br><span class="line">        &quot;doc_values&quot;: false</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT users/_doc/1</span><br><span class="line">&#123;</span><br><span class="line">  &quot;age&quot;:100</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT users/_doc/2</span><br><span class="line">&#123;</span><br><span class="line">  &quot;age&quot;:99</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT users/_doc/3</span><br><span class="line">&#123;</span><br><span class="line">  &quot;age&quot;:98</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT users/_doc/4</span><br><span class="line">&#123;</span><br><span class="line">  &quot;age&quot;:101</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GET users/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match_all&quot;: &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;sort&quot;:[</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;age&quot;:&#123;</span><br><span class="line">        &quot;order&quot;: &quot;desc&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>es</tag>
      </tags>
  </entry>
  <entry>
    <title>映射参数-enabled</title>
    <url>/2023/08/06/ES/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%98%A0%E5%B0%84%E5%8F%82%E6%95%B0-enabled/</url>
    <content><![CDATA[<p>es 默认会索引所有的字段，但是有的字段可能只需要存储，   不需要索引。此时可以通过 enabled 字段来控制：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PUT blog</span><br><span class="line">&#123;</span><br><span class="line">  &quot;mappings&quot;: &#123;</span><br><span class="line">    &quot;properties&quot;: &#123;</span><br><span class="line">      &quot;title&quot;:&#123;</span><br><span class="line">        &quot;enabled&quot;: false</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT blog/_doc/1</span><br><span class="line">&#123;</span><br><span class="line">  &quot;title&quot;:&quot;javaboy&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GET blog/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;term&quot;: &#123;</span><br><span class="line">      &quot;title&quot;: &quot;javaboy&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这时查询结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;took&quot; : 0,</span><br><span class="line">  &quot;timed_out&quot; : false,</span><br><span class="line">  &quot;_shards&quot; : &#123;</span><br><span class="line">    &quot;total&quot; : 1,</span><br><span class="line">    &quot;successful&quot; : 1,</span><br><span class="line">    &quot;skipped&quot; : 0,</span><br><span class="line">    &quot;failed&quot; : 0</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;hits&quot; : &#123;</span><br><span class="line">    &quot;total&quot; : &#123;</span><br><span class="line">      &quot;value&quot; : 0,</span><br><span class="line">      &quot;relation&quot; : &quot;eq&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;max_score&quot; : null,</span><br><span class="line">    &quot;hits&quot; : [ ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>设置了 enabled 为 false 之后，就可以再通过该字段进行搜索了。</p>
]]></content>
      <tags>
        <tag>es</tag>
      </tags>
  </entry>
  <entry>
    <title>映射参数-fields</title>
    <url>/2023/08/06/ES/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%98%A0%E5%B0%84%E5%8F%82%E6%95%B0-fields/</url>
    <content><![CDATA[<p>fields 参数<strong>可以让同一字段有多种不同的索引方式</strong>。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PUT blog</span><br><span class="line">&#123;</span><br><span class="line">  &quot;mappings&quot;: &#123;</span><br><span class="line">    &quot;properties&quot;: &#123;</span><br><span class="line">      &quot;title&quot;:&#123;</span><br><span class="line">        &quot;type&quot;: &quot;text&quot;,</span><br><span class="line">        &quot;fields&quot;: &#123;</span><br><span class="line">          &quot;raw&quot;:&#123;</span><br><span class="line">            &quot;type&quot;:&quot;keyword&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT blog/_doc/1</span><br><span class="line">&#123;</span><br><span class="line">  &quot;title&quot;:&quot;javaboy&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GET blog/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;term&quot;: &#123;</span><br><span class="line">      &quot;title.raw&quot;: &quot;javaboy&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>es</tag>
      </tags>
  </entry>
  <entry>
    <title>映射参数-format</title>
    <url>/2023/08/06/ES/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%98%A0%E5%B0%84%E5%8F%82%E6%95%B0-format/</url>
    <content><![CDATA[<p>日期格式。format 可以规范日期格式，而且一次可以定义多个 format。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PUT users</span><br><span class="line">&#123;</span><br><span class="line">  &quot;mappings&quot;: &#123;</span><br><span class="line">    &quot;properties&quot;: &#123;</span><br><span class="line">      &quot;birthday&quot;:&#123;</span><br><span class="line">        &quot;type&quot;: &quot;date&quot;,</span><br><span class="line">        &quot;format&quot;: &quot;yyyy-MM-dd||yyyy-MM-dd HH:mm:ss&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT users/_doc/1</span><br><span class="line">&#123;</span><br><span class="line">  &quot;birthday&quot;:&quot;2020-11-11&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT users/_doc/2</span><br><span class="line">&#123;</span><br><span class="line">  &quot;birthday&quot;:&quot;2020-11-11 11:11:11&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>多个日期格式之间，使用 || 符号连接，注意没有空格。</li>
<li>如果用户没有指定日期的 format，默认的日期格式是strict_date_optional_time||epoch_mills</li>
</ul>
<p>另外，所有的日期格式，可以在 <a class="link"   href="https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-date-format.html" >https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-date-format.html<i class="fas fa-external-link-alt"></i></a> 网址查看。</p>
]]></content>
      <tags>
        <tag>es</tag>
      </tags>
  </entry>
  <entry>
    <title>映射参数-ignore_above</title>
    <url>/2023/08/06/ES/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%98%A0%E5%B0%84%E5%8F%82%E6%95%B0-ignore_above/</url>
    <content><![CDATA[<p>igbore_above 用于指定分词和索引的字符串最大长度，超过最大长度的话，该字段将不会被索引，这个字段只适用于 keyword 类型。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PUT blog</span><br><span class="line">&#123;</span><br><span class="line">  &quot;mappings&quot;: &#123;</span><br><span class="line">    &quot;properties&quot;: &#123;</span><br><span class="line">      &quot;title&quot;:&#123;</span><br><span class="line">        &quot;type&quot;: &quot;keyword&quot;,</span><br><span class="line">        &quot;ignore_above&quot;: 10</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT blog/_doc/1</span><br><span class="line">&#123;</span><br><span class="line">  &quot;title&quot;:&quot;javaboy&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT blog/_doc/2</span><br><span class="line">&#123;</span><br><span class="line">  &quot;title&quot;:&quot;javaboyjavaboyjavaboy&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GET blog/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;term&quot;: &#123;</span><br><span class="line">      &quot;title&quot;: &quot;javaboyjavaboyjavaboy&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>es</tag>
      </tags>
  </entry>
  <entry>
    <title>映射参数-ignore_malformed</title>
    <url>/2023/08/06/ES/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%98%A0%E5%B0%84%E5%8F%82%E6%95%B0-ignore_malformed/</url>
    <content><![CDATA[<p>ignore_malformed 可以忽略不规则的数据，该参数默认为 false。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PUT users</span><br><span class="line">&#123;</span><br><span class="line">  &quot;mappings&quot;: &#123;</span><br><span class="line">    &quot;properties&quot;: &#123;</span><br><span class="line">      &quot;birthday&quot;:&#123;</span><br><span class="line">        &quot;type&quot;: &quot;date&quot;,</span><br><span class="line">        &quot;format&quot;: &quot;yyyy-MM-dd||yyyy-MM-dd HH:mm:ss&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;age&quot;:&#123;</span><br><span class="line">        &quot;type&quot;: &quot;integer&quot;,</span><br><span class="line">        &quot;ignore_malformed&quot;: true</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT users/_doc/1</span><br><span class="line">&#123;</span><br><span class="line">  &quot;birthday&quot;:&quot;2020-11-11&quot;,</span><br><span class="line">  &quot;age&quot;:99</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT users/_doc/2</span><br><span class="line">&#123;</span><br><span class="line">  &quot;birthday&quot;:&quot;2020-11-11 11:11:11&quot;,</span><br><span class="line">  &quot;age&quot;:&quot;abc&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PUT users/_doc/2</span><br><span class="line">&#123;</span><br><span class="line">  &quot;birthday&quot;:&quot;2020-11-11 11:11:11aaa&quot;,</span><br><span class="line">  &quot;age&quot;:&quot;abc&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>es</tag>
      </tags>
  </entry>
  <entry>
    <title>映射参数-include_in_all</title>
    <url>/2023/08/06/ES/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%98%A0%E5%B0%84%E5%8F%82%E6%95%B0-include_in_all/</url>
    <content><![CDATA[<p>这个是针对 _all 字段的，但是在 es7 中，该字段已经被废弃了。</p>
]]></content>
      <tags>
        <tag>es</tag>
      </tags>
  </entry>
  <entry>
    <title>映射参数-index</title>
    <url>/2023/08/06/ES/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%98%A0%E5%B0%84%E5%8F%82%E6%95%B0-index/</url>
    <content><![CDATA[<p>index 属性指定一个字段是否被索引，该属性为 true 表示字段被索引，false 表示字段不被索引。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PUT users</span><br><span class="line">&#123;</span><br><span class="line">  &quot;mappings&quot;: &#123;</span><br><span class="line">    &quot;properties&quot;: &#123;</span><br><span class="line">      &quot;age&quot;:&#123;</span><br><span class="line">        &quot;type&quot;: &quot;integer&quot;,</span><br><span class="line">        &quot;index&quot;: false</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT users/_doc/1</span><br><span class="line">&#123;</span><br><span class="line">  &quot;age&quot;:99</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GET users/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;term&quot;: &#123;</span><br><span class="line">      &quot;age&quot;: 99</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果 index 为 false，则不能通过对应的字段搜索。</p>
]]></content>
      <tags>
        <tag>es</tag>
      </tags>
  </entry>
  <entry>
    <title>映射参数-index_options</title>
    <url>/2023/08/06/ES/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%98%A0%E5%B0%84%E5%8F%82%E6%95%B0-index_options/</url>
    <content><![CDATA[<p>index_options 控制索引时哪些信息被存储到倒排索引中（用在 text 字段中），有四种取值：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://note.youdao.com/yws/res/3354/B458E0FEA0404D61B870D2D63A40A888"
                      alt="image"
                ></p>
]]></content>
      <tags>
        <tag>es</tag>
      </tags>
  </entry>
  <entry>
    <title>映射参数-normalizer</title>
    <url>/2023/08/06/ES/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%98%A0%E5%B0%84%E5%8F%82%E6%95%B0-normalizer/</url>
    <content><![CDATA[<p>**# **normalizer<br>normalizer 参数用于解析前（索引或者查询）的标准化配置。</p>
<p>比如，<strong>在 es 中，对于一些我们不想切分的字符串，我们通常会将其设置为 keyword</strong>，搜索时候也是使用整个词进行搜索。如果在索引前没有做好数据清洗，导致大小写不一致，例如 javaboy 和 JAVABOY，此时，我们就可以使用 normalizer 在索引之前以及查询之前进行文档的标准化。</p>
<p>先来一个反例，创建一个名为 blog 的索引，设置 author 字段类型为 keyword：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PUT blog</span><br><span class="line">&#123;</span><br><span class="line">  &quot;mappings&quot;: &#123;</span><br><span class="line">    &quot;properties&quot;: &#123;</span><br><span class="line">      &quot;author&quot;:&#123;</span><br><span class="line">        &quot;type&quot;: &quot;keyword&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>添加两个文档：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PUT blog/_doc/1</span><br><span class="line">&#123;</span><br><span class="line">  &quot;author&quot;:&quot;javaboy&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT blog/_doc/2</span><br><span class="line">&#123;</span><br><span class="line">  &quot;author&quot;:&quot;JAVABOY&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后进行搜索：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET blog/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;term&quot;: &#123;</span><br><span class="line">      &quot;author&quot;: &quot;JAVABOY&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大写关键字可以搜到大写的文档，小写关键字可以搜到小写的文档。<br>如果使用了 normalizer，可以在索引和查询时，分别对文档进行预处理。</p>
<p>normalizer 定义方式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PUT blog</span><br><span class="line">&#123;</span><br><span class="line">  &quot;settings&quot;: &#123;</span><br><span class="line">    &quot;analysis&quot;: &#123;</span><br><span class="line">      &quot;normalizer&quot;:&#123;</span><br><span class="line">        &quot;my_normalizer&quot;:&#123;</span><br><span class="line">          &quot;type&quot;:&quot;custom&quot;,</span><br><span class="line">          &quot;filter&quot;:[&quot;lowercase&quot;]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, </span><br><span class="line">  &quot;mappings&quot;: &#123;</span><br><span class="line">    &quot;properties&quot;: &#123;</span><br><span class="line">      &quot;author&quot;:&#123;</span><br><span class="line">        &quot;type&quot;: &quot;keyword&quot;,</span><br><span class="line">        &quot;normalizer&quot;:&quot;my_normalizer&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 settings 中定义 normalizer，然后在 mappings 中引用。</p>
<p>测试方式和前面一致。此时查询的时候，大写关键字也可以查询到小写文档，因为无论是索引还是查询，都会将大写转为小写。</p>
]]></content>
      <tags>
        <tag>es</tag>
      </tags>
  </entry>
  <entry>
    <title>映射参数-norms</title>
    <url>/2023/08/06/ES/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%98%A0%E5%B0%84%E5%8F%82%E6%95%B0-norms/</url>
    <content><![CDATA[<p>norms 对字段评分有用，text 默认开启 norms，如果不是特别需要，不要开启 norms。</p>
]]></content>
      <tags>
        <tag>es</tag>
      </tags>
  </entry>
  <entry>
    <title>映射参数-search_analyzer</title>
    <url>/2023/08/06/ES/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%98%A0%E5%B0%84%E5%8F%82%E6%95%B0-search_analyzer/</url>
    <content><![CDATA[<h1 id="search-analyzer"><a href="#search-analyzer" class="headerlink" title="search_analyzer"></a>search_analyzer</h1><p>查询时候的分词器。默认情况下，如果没有配置 search_analyzer，则查询时，首先查看有没有 search_analyzer，有的话，就用 search_analyzer 来进行分词，如果没有，则看有没有 analyzer，如果有，则用 analyzer 来进行分词，否则使用 es 默认的分词器。</p>
<h2 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h2><blockquote>
<p>search_analyzer -&gt; analyzer -&gt;  es 默认的分词器</p>
</blockquote>
]]></content>
      <tags>
        <tag>es</tag>
      </tags>
  </entry>
  <entry>
    <title>映射参数-similarity</title>
    <url>/2023/08/06/ES/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%98%A0%E5%B0%84%E5%8F%82%E6%95%B0-similarity/</url>
    <content><![CDATA[<p>similarity 指定文档的评分模型，默认有三种：<br><img  
                     lazyload
                     alt="image"
                     data-src="https://note.youdao.com/yws/res/3379/7CE982CF426D4E18B60E4FC8CCB13BDF"
                      alt="image"
                ></p>
]]></content>
      <tags>
        <tag>es</tag>
      </tags>
  </entry>
  <entry>
    <title>映射参数-store</title>
    <url>/2023/08/06/ES/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%98%A0%E5%B0%84%E5%8F%82%E6%95%B0-store/</url>
    <content><![CDATA[<p>默认情况下，字段会被索引，也可以搜索，但是不会存储，虽然不会被存储的，但是 _source 中有一个字段的备份。如果想将字段存储下来，可以通过配置 store 来实现。</p>
]]></content>
      <tags>
        <tag>es</tag>
      </tags>
  </entry>
  <entry>
    <title>映射参数-term_vectors</title>
    <url>/2023/08/06/ES/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%98%A0%E5%B0%84%E5%8F%82%E6%95%B0-term_vectors/</url>
    <content><![CDATA[<p>term_vectors 是通过分词器产生的信息，包括：</p>
<ul>
<li>一组 terms</li>
<li>每个 term 的位置</li>
<li>term 的首字符&#x2F;尾字符与原始字符串原点的偏移量</li>
</ul>
<p>term_vectors 取值：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://note.youdao.com/yws/res/3390/F101A56AF9B045BFA2D3A1D03F6B3814"
                      alt="image"
                >
    </p>
]]></content>
      <tags>
        <tag>es</tag>
      </tags>
  </entry>
  <entry>
    <title>映射参数-position_increment_gap</title>
    <url>/2023/08/06/ES/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%98%A0%E5%B0%84%E5%8F%82%E6%95%B0-position_increment_gap/</url>
    <content><![CDATA[<p>被解析的 text 字段会将 term 的位置考虑进去，目的是为了支持近似查询和短语查询，当我们去索引一个含有多个值的 text 字段时，会在各个值之间添加一个假想的空间，将值隔开，这样就可以有效避免一些无意义的短语匹配，间隙大小通过 position_increment_gap 来控制，默认是 100。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PUT users</span><br><span class="line"></span><br><span class="line">PUT users/_doc/1</span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;:[&quot;zhang san&quot;,&quot;li si&quot;]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GET users/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match_phrase&quot;: &#123;</span><br><span class="line">      &quot;name&quot;: &#123;</span><br><span class="line">        &quot;query&quot;: &quot;sanli&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>sanli 搜索不到，因为两个短语之间有一个假想的空隙，为 100。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET users/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match_phrase&quot;: &#123;</span><br><span class="line">      &quot;name&quot;: &#123;</span><br><span class="line">        &quot;query&quot;: &quot;san li&quot;,</span><br><span class="line">        &quot;slop&quot;: 101</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以通过 slop 指定空隙大小。</p>
<p>也可以在定义索引的时候，指定空隙：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PUT users</span><br><span class="line">&#123;</span><br><span class="line">  &quot;mappings&quot;: &#123;</span><br><span class="line">    &quot;properties&quot;: &#123;</span><br><span class="line">      &quot;name&quot;:&#123;</span><br><span class="line">        &quot;type&quot;: &quot;text&quot;,</span><br><span class="line">        &quot;position_increment_gap&quot;: 0</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT users/_doc/1</span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;:[&quot;zhang san&quot;,&quot;li si&quot;]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GET users/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match_phrase&quot;: &#123;</span><br><span class="line">      &quot;name&quot;: &#123;</span><br><span class="line">        &quot;query&quot;: &quot;san li&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>不懂怎么用？</strong></p>
]]></content>
      <tags>
        <tag>es</tag>
      </tags>
  </entry>
  <entry>
    <title>更新索引</title>
    <url>/2023/08/06/ES/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%9B%B4%E6%96%B0%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<p>索引创建好之后，可以修改其属性。</p>
<h1 id="修改索引的副本数"><a href="#修改索引的副本数" class="headerlink" title="修改索引的副本数"></a>修改索引的副本数</h1><p>例如修改索引的副本数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PUT book/_settings</span><br><span class="line">&#123;</span><br><span class="line">  &quot;number_of_replicas&quot;: 2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="修改索引的读写权限"><a href="#修改索引的读写权限" class="headerlink" title="修改索引的读写权限"></a>修改索引的读写权限</h1><p>索引创建成功后，可以向索引中写入文档：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PUT test2/_doc/1</span><br><span class="line">&#123;</span><br><span class="line">  &quot;title&quot;:&quot;三国演义&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>写入成功后，可以在 head 插件中查看：<br><img  
                     lazyload
                     alt="image"
                     data-src="https://note.youdao.com/yws/res/2795/7EBD06C84C084675867569DBD9D1608D"
                      alt="image"
                ><br>默认情况下，索引是具备读写权限的，当然这个读写权限可以关闭。<br>例如，关闭索引的写权限：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PUT test2/_settings</span><br><span class="line">&#123;</span><br><span class="line">  &quot;blocks.write&quot;: true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关闭之后，就无法添加文档了。<br><img  
                     lazyload
                     alt="image"
                     data-src="https://note.youdao.com/yws/res/2804/0AC4B9B876E44081AC763BE19CD35237"
                      alt="image"
                ><br>关闭了写权限之后，如果想要再次打开，方式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PUT book/_settings</span><br><span class="line">&#123;</span><br><span class="line">  &quot;blocks.write&quot;: false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其他类似的权限有：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">blocks.write</span><br><span class="line">blocks.read</span><br><span class="line">blocks.read_only</span><br></pre></td></tr></table></figure>


]]></content>
      <tags>
        <tag>es</tag>
      </tags>
  </entry>
  <entry>
    <title>查看索引</title>
    <url>/2023/08/06/ES/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%9F%A5%E7%9C%8B%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<h1 id="查看索引"><a href="#查看索引" class="headerlink" title="查看索引"></a>查看索引</h1><h2 id="head-插件查看方式如下："><a href="#head-插件查看方式如下：" class="headerlink" title="head 插件查看方式如下："></a>head 插件查看方式如下：</h2><p> <img  
                     lazyload
                     alt="image"
                     data-src="https://note.youdao.com/yws/res/2813/D6140340447446C28D23EF14745409D0"
                      alt="image"
                ></p>
<h2 id="请求查看方式如下："><a href="#请求查看方式如下：" class="headerlink" title="请求查看方式如下："></a>请求查看方式如下：</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET book/_settings</span><br></pre></td></tr></table></figure>
<p>结果如下：<br><img  
                     lazyload
                     alt="image"
                     data-src="https://note.youdao.com/yws/res/2819/717A3F8891BB4C01A8C5062029DD7D52"
                      alt="image"
                ><br>也可以同时查看多个索引信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET test,test2/_settings</span><br></pre></td></tr></table></figure>
<p>结果如下：<br><img  
                     lazyload
                     alt="image"
                     data-src="https://note.youdao.com/yws/res/2828/A0AEA51685EE49EF9D48DF9CF95FD265"
                      alt="image"
                ><br>也可以查看所有索引信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET _all/_settings</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>es</tag>
      </tags>
  </entry>
  <entry>
    <title>索引的打开和关闭</title>
    <url>/2023/08/06/ES/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%B4%A2%E5%BC%95%E7%9A%84%E6%89%93%E5%BC%80%E5%92%8C%E5%85%B3%E9%97%AD/</url>
    <content><![CDATA[<p>关闭索引：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST book/_close</span><br></pre></td></tr></table></figure>
<p>打开索引：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST book/_open</span><br></pre></td></tr></table></figure>
<p>当然，可以同时关闭&#x2F;打开多个索引，多个索引用 , 隔开，或者直接使用 _all 代表所有索引。</p>
]]></content>
      <tags>
        <tag>es</tag>
      </tags>
  </entry>
  <entry>
    <title>索引别名</title>
    <url>/2023/08/06/ES/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%B4%A2%E5%BC%95%E5%88%AB%E5%90%8D/</url>
    <content><![CDATA[<h1 id="添加别名"><a href="#添加别名" class="headerlink" title="添加别名"></a>添加别名</h1><p>可以为索引创建别名，如果这个别名是唯一的，该别名可以代替索引名称。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST /_aliases</span><br><span class="line">&#123;</span><br><span class="line">  &quot;actions&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;add&quot;: &#123;</span><br><span class="line">        &quot;index&quot;: &quot;book&quot;,</span><br><span class="line">        &quot;alias&quot;: &quot;book_alias&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>添加结果如下：<br><img  
                     lazyload
                     alt="image"
                     data-src="https://note.youdao.com/yws/res/2860/84E93D788C2A4686BAFBE9113A8E56BB"
                      alt="image"
                ></p>
<h1 id="移除别名"><a href="#移除别名" class="headerlink" title="移除别名"></a>移除别名</h1><p>将 add 改为 remove 就表示移除别名：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST /_aliases</span><br><span class="line">&#123;</span><br><span class="line">  &quot;actions&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;remove&quot;: &#123;</span><br><span class="line">        &quot;index&quot;: &quot;book&quot;,</span><br><span class="line">        &quot;alias&quot;: &quot;book_alias&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="查看索引别名"><a href="#查看索引别名" class="headerlink" title="查看索引别名"></a>查看索引别名</h1><h2 id="查看某一个索引的别名："><a href="#查看某一个索引的别名：" class="headerlink" title="查看某一个索引的别名："></a>查看某一个索引的别名：</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /book/_alias</span><br></pre></td></tr></table></figure>
<h2 id="可以查看集群上所有可用别名"><a href="#可以查看集群上所有可用别名" class="headerlink" title="可以查看集群上所有可用别名"></a>可以查看集群上所有可用别名</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /_alias</span><br></pre></td></tr></table></figure>



]]></content>
      <tags>
        <tag>es</tag>
      </tags>
  </entry>
  <entry>
    <title>映射参数-null_value</title>
    <url>/2023/08/06/ES/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%98%A0%E5%B0%84%E5%8F%82%E6%95%B0-null_value/</url>
    <content><![CDATA[<p>在 es 中，值为 null 的字段不索引也不可以被搜索，null_value 可以让值为 null 的字段显式的可索引、可搜索：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PUT users</span><br><span class="line">&#123;</span><br><span class="line">  &quot;mappings&quot;: &#123;</span><br><span class="line">    &quot;properties&quot;: &#123;</span><br><span class="line">      &quot;name&quot;:&#123;</span><br><span class="line">        &quot;type&quot;: &quot;keyword&quot;,</span><br><span class="line">        &quot;null_value&quot;: &quot;javaboy_null&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT users/_doc/1</span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;:null,</span><br><span class="line">  &quot;age&quot;:99</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GET users/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;term&quot;: &#123;</span><br><span class="line">      &quot;name&quot;: &quot;javaboy_null&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>es</tag>
      </tags>
  </entry>
  <entry>
    <title>Cache Aside</title>
    <url>/2024/06/06/%E5%88%86%E5%B8%83%E5%BC%8F/%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7/Cache%20Aside/</url>
    <content><![CDATA[<h2 id="缓存策略"><a href="#缓存策略" class="headerlink" title="缓存策略"></a>缓存策略</h2><h3 id="读操作"><a href="#读操作" class="headerlink" title="读操作"></a>读操作</h3><ol>
<li>先读缓存</li>
<li>缓存没有读取数据库</li>
<li>更新缓存</li>
</ol>
<h3 id="写操作"><a href="#写操作" class="headerlink" title="写操作"></a>写操作</h3><ol>
<li>先更新数据库</li>
<li>再删除缓存</li>
</ol>
]]></content>
      <tags>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>多节点并发修改redis list中的元素，如何保证数据的一致性.md</title>
    <url>/2024/12/09/%E5%88%86%E5%B8%83%E5%BC%8F/%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7/%E5%A4%9A%E8%8A%82%E7%82%B9%E5%B9%B6%E5%8F%91%E4%BF%AE%E6%94%B9redis%20list%E4%B8%AD%E7%9A%84%E5%85%83%E7%B4%A0%EF%BC%8C%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7/</url>
    <content><![CDATA[<h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><p>多个服务节点对redis中的list元素的修改，可以理解为多线程下对共享的集合容器中的元素进行修改、</p>
<h2 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h2><ol>
<li><strong>使用分布式锁</strong>，控制某一个时间只有一个节点可以对list中的元素进行修改，<strong>使修改操作串行</strong></li>
<li>参考copyOnWriteArrayList，在进行写操作时进行加锁，拷贝一份数据副本，在数据副本上修改数据，<br>修改完成后覆盖原list，通知数据变更使服务节点中的缓存刷新，释放锁。期间对list的读不进行加锁，这样可以支撑更高的并发。</li>
</ol>
]]></content>
      <tags>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>延时双删策略</title>
    <url>/2024/05/06/%E5%88%86%E5%B8%83%E5%BC%8F/%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7/%E5%BB%B6%E6%97%B6%E5%8F%8C%E5%88%A0%E7%AD%96%E7%95%A5/</url>
    <content><![CDATA[<h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><p>在分布式系统中用于保持数据库存储和缓存数据一致性的常用方法</p>
<h2 id="策略思想"><a href="#策略思想" class="headerlink" title="策略思想"></a>策略思想</h2><p>有数据需要更新时，先删除缓存中的数据，再更新数据库，然后在一段时间后再次删除缓存</p>
<h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol>
<li>第一次删除缓存：在更新数据库之前，先删除对应的缓存数据，确保缓存中不会存在旧数据</li>
<li>更新数据库</li>
<li>延迟一段时间后，再次删除缓存：为了防止在数据库更新后立即有并发请求读到了旧缓存数据，延迟一定时间（比如1秒）后，再次删除缓存，确保缓存中不存在陈旧的数据</li>
</ol>
<h3 id="延迟删除的原因"><a href="#延迟删除的原因" class="headerlink" title="延迟删除的原因"></a>延迟删除的原因</h3><p>删除缓存和更新数据库不是原子操作，在高并发场景下，某个线程在读取缓存时发现缓存中没有数据，旧有可能会查询到数据库中还未更新的旧数据，从而导致缓存中的数据与数据库中的数据不一致</p>
<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><ul>
<li>可以避免高并发场景下脏数据回填缓存的问题</li>
<li>可以确保数据的最终一致性</li>
</ul>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ol>
<li>在缓存被删除和数据回填期间，所有读请求都会直接访问数据库，可能会增加数据库的压力。</li>
</ol>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>a. 延迟时间的选择： 确保在数据库更新操作完成后</p>
<p>b. 缓存删除后，缓存穿透问题</p>
<h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><ol>
<li>读多写少</li>
<li>对数据的实时性要求不高</li>
</ol>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>如果给缓存key设置了过期时间，那么在更新数据时，不再删除缓存、也不再延时删除缓存，是否也可以达到最终一致性的效果呢</p>
]]></content>
      <tags>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>延时双删策略和订阅mysql的binlog之间的比较.md</title>
    <url>/2024/11/19/%E5%88%86%E5%B8%83%E5%BC%8F/%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7/%E5%BB%B6%E6%97%B6%E5%8F%8C%E5%88%A0%E7%AD%96%E7%95%A5%E5%92%8C%E8%AE%A2%E9%98%85mysql%E7%9A%84binlog%E4%B9%8B%E9%97%B4%E7%9A%84%E6%AF%94%E8%BE%83/</url>
    <content><![CDATA[<h2 id="延时双删策略："><a href="#延时双删策略：" class="headerlink" title="延时双删策略："></a>延时双删策略：</h2><h3 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h3><p>在更新数据库之前先删除缓存，然后更新数据库，经过一个短暂的延时后再次删除缓存。</p>
<h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><p>相对简单，不需要依赖于数据库的binlog，适用于读多写少的场景。</p>
<h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><p>可能会因为延时设置不当而导致数据不一致，特别是在高并发场景下，延时期间内可能会有读请求读取到旧数据写回缓存，造成数据不一致。</p>
<h2 id="订阅MySQL的binlog："><a href="#订阅MySQL的binlog：" class="headerlink" title="订阅MySQL的binlog："></a>订阅MySQL的binlog：</h2><h2 id="原理：-1"><a href="#原理：-1" class="headerlink" title="原理："></a>原理：</h2><p>通过订阅MySQL的binlog，可以实时获取数据库的变更操作，然后根据这些变更来更新或删除缓存中的数据。</p>
<h3 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h3><p>能够实现数据的最终一致性，适用于对数据一致性要求较高的场景。通过binlog可以实现更细粒度的控制，比如只更新或删除特定操作影响的缓存数据。</p>
<h3 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h3><p>增加了系统的复杂度，需要额外的组件来处理binlog，并且需要考虑消息队列的可靠性和重试机制。</p>
<h2 id="区别："><a href="#区别：" class="headerlink" title="区别："></a>区别：</h2><ul>
<li><strong>实时性</strong>：订阅binlog可以实现更接近实时的数据同步，而延时双删策略存在一个固定的延时时间，可能会导致数据在这段时间内不一致。</li>
<li><strong>系统复杂度</strong>：订阅binlog需要引入额外的组件和机制，如消息队列和binlog处理工具（如Canal），而延时双删策略相对简单，不需要这些额外的组件。</li>
<li><strong>数据一致性</strong>：订阅binlog可以提供更强的数据一致性保证，尤其是在分布式系统中，而延时双删策略可能会因为延时设置不当而导致数据不一致。</li>
<li><strong>适用场景</strong>：延时双删策略适用于写操作较少，对数据一致性要求不是极高的场景；订阅binlog适用于写操作频繁，对数据一致性要求较高的场景。</li>
</ul>
]]></content>
      <tags>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>缓存穿透有哪些解决方法</title>
    <url>/2024/05/08/%E5%88%86%E5%B8%83%E5%BC%8F/%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7/%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E6%9C%89%E5%93%AA%E4%BA%9B%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h2 id="什么是缓存穿透"><a href="#什么是缓存穿透" class="headerlink" title="什么是缓存穿透"></a>什么是缓存穿透</h2><ol>
<li>热点数据缓存失效后，大量并发请求直接访问数据库，导致数据库压力剧增</li>
<li>查询本就不存在的数据，导致每次都要查询数据库</li>
</ol>
<h2 id="影响"><a href="#影响" class="headerlink" title="影响"></a>影响</h2><ol>
<li>数据库压力增大：由于每次请求都要访问数据库，导致数据库的压力增大。</li>
<li>系统性能降低：每次请求都要访问数据库，导致系统的响应时间增加，性能降低。</li>
</ol>
<h2 id="如何减少或避免"><a href="#如何减少或避免" class="headerlink" title="如何减少或避免"></a>如何减少或避免</h2><h3 id="1-增加缓存标志位"><a href="#1-增加缓存标志位" class="headerlink" title="1.增加缓存标志位"></a>1.增加缓存标志位</h3><h4 id="使用场景：应用层主动删除缓存时"><a href="#使用场景：应用层主动删除缓存时" class="headerlink" title="使用场景：应用层主动删除缓存时"></a>使用场景：应用层主动删除缓存时</h4><p>在删除缓存的同时，可以设置一个标志位，比如设置 loading &#x3D; true；高并发请求会检测到 loading 状态，直接从缓存返回或等待；等到数据更新并缓存后，将标志位重置，以此减少对数据库的直接请求。</p>
<h3 id="2-缓存null（缓存空结果）"><a href="#2-缓存null（缓存空结果）" class="headerlink" title="2.缓存null（缓存空结果）"></a>2.缓存null（缓存空结果）</h3><h4 id="使用场景：针对数据库也不存在数据的场景"><a href="#使用场景：针对数据库也不存在数据的场景" class="headerlink" title="使用场景：针对数据库也不存在数据的场景"></a>使用场景：针对数据库也不存在数据的场景</h4><p>设置合理的过期时间，避免每次查询数据库</p>
<h3 id="3-布隆过滤器"><a href="#3-布隆过滤器" class="headerlink" title="3.布隆过滤器"></a>3.布隆过滤器</h3><h4 id="使用场景：根据key判断元素是否存在"><a href="#使用场景：根据key判断元素是否存在" class="headerlink" title="使用场景：根据key判断元素是否存在"></a>使用场景：根据key判断元素是否存在</h4>]]></content>
      <tags>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>订阅MySQL的binlog</title>
    <url>/2024/06/18/%E5%88%86%E5%B8%83%E5%BC%8F/%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7/%E8%AE%A2%E9%98%85MySQL%E7%9A%84binlog/</url>
    <content><![CDATA[<h2 id="为什么要使用"><a href="#为什么要使用" class="headerlink" title="为什么要使用"></a>为什么要使用</h2>]]></content>
      <tags>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>消息堆积如何处理.md</title>
    <url>/2024/12/02/%E5%88%86%E5%B8%83%E5%BC%8F/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E6%B6%88%E6%81%AF%E5%A0%86%E7%A7%AF%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h2 id="产生的原因"><a href="#产生的原因" class="headerlink" title="产生的原因"></a>产生的原因</h2><ol>
<li>消费者消费能力不足</li>
<li>突发流量，如果消费能力够的话，会慢慢消解</li>
<li>消费者程序异常导致不消费</li>
<li>外部系统故障，如依赖服务、数据库或缓存服务故障，导致的性能下降</li>
</ol>
<h2 id="不同端的处理"><a href="#不同端的处理" class="headerlink" title="不同端的处理"></a>不同端的处理</h2><h3 id="生产端"><a href="#生产端" class="headerlink" title="生产端"></a>生产端</h3><ol>
<li>生产者进行限流处理，减少消息的产生</li>
<li>业务降级，关闭一下非核心业务，减少消息的产生</li>
</ol>
<h3 id="消费端"><a href="#消费端" class="headerlink" title="消费端"></a>消费端</h3><ol>
<li>重启消费者，有可能是内存泄露导致的性能下降问题，看能够恢复处理能力</li>
<li>增加消费者数量</li>
<li>提升单个消费者的处理能力</li>
<li>解决bug后重新发版</li>
</ol>
]]></content>
      <tags>
        <tag>消息队列</tag>
      </tags>
  </entry>
  <entry>
    <title>固定窗口限流.md</title>
    <url>/2024/11/19/%E5%88%86%E5%B8%83%E5%BC%8F/%E9%99%90%E6%B5%81/%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95/%E5%9B%BA%E5%AE%9A%E7%AA%97%E5%8F%A3%E9%99%90%E6%B5%81/</url>
    <content><![CDATA[<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ol>
<li>比计数限流多了一个时间窗口的概念，每过一个时间窗口后计数器就重置</li>
<li>请求数小于阈值，放行处理且计数器+1</li>
<li>请求数超过阈值，拒绝请求</li>
<li>时间窗口过后，重置计数器</li>
</ol>
<h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>全局来看，短时间可能出现瞬时的高负载，</p>
<h2 id="如何实现"><a href="#如何实现" class="headerlink" title="如何实现"></a>如何实现</h2><h3 id="单机"><a href="#单机" class="headerlink" title="单机"></a>单机</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 固定窗口限流</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> boolean</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">tryHandle2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">if</span> (now - lastHandleTime &gt; timeWindow) &#123;</span><br><span class="line">        handledRequestCount.set(<span class="number">0</span>);</span><br><span class="line">        lastHandleTime = now;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (handledRequestCount.get() &lt; maxRequestValue) &#123;</span><br><span class="line">        handledRequestCount.incrementAndGet();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="集群（分布式）"><a href="#集群（分布式）" class="headerlink" title="集群（分布式）"></a>集群（分布式）</h3>]]></content>
      <tags>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>令牌桶限流.md</title>
    <url>/2024/11/19/%E5%88%86%E5%B8%83%E5%BC%8F/%E9%99%90%E6%B5%81/%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95/%E4%BB%A4%E7%89%8C%E6%A1%B6%E9%99%90%E6%B5%81/</url>
    <content><![CDATA[<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><h2 id="如何实现"><a href="#如何实现" class="headerlink" title="如何实现"></a>如何实现</h2><h3 id="单机"><a href="#单机" class="headerlink" title="单机"></a>单机</h3><h3 id="集群（分布式）"><a href="#集群（分布式）" class="headerlink" title="集群（分布式）"></a>集群（分布式）</h3>]]></content>
      <tags>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>基于计数器限流.md</title>
    <url>/2024/11/19/%E5%88%86%E5%B8%83%E5%BC%8F/%E9%99%90%E6%B5%81/%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95/%E5%9F%BA%E4%BA%8E%E8%AE%A1%E6%95%B0%E5%99%A8%E9%99%90%E6%B5%81/</url>
    <content><![CDATA[<h2 id="什么是限流"><a href="#什么是限流" class="headerlink" title="什么是限流"></a>什么是限流</h2><ul>
<li>后端的处理能力是有限的，需要截掉超出处理能力之外的请求，提高系统的稳定性</li>
<li>均衡客户端对服务器资源的公平调用</li>
<li>目的是限制在指定时间间隔内的访问量</li>
</ul>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ol>
<li>维护一个计数器，处理一个请求后，计数器+1，请求处理完成后，计数器-1</li>
<li>请求过来后，先判断一下计数器的值是否超过处理阈值，超过则拒绝请求，否则放行并处理请求</li>
</ol>
<h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>比较简单，单机在java中可以使用Atomic等原子类，分布式环境可以使用Redis incr</p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>面对突发流量，处理不够丝滑，可能1s内计数器就达到阈值，不再处理请求</p>
<h2 id="如何实现"><a href="#如何实现" class="headerlink" title="如何实现"></a>如何实现</h2><h3 id="单机"><a href="#单机" class="headerlink" title="单机"></a>单机</h3><p>Atomic等原子类、guava包</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 系统最大能承载的请求数量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> maxRequestValue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 已处理的请求数（计数器）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> AtomicInteger handledRequestCount;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 计数限流</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> boolean</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">tryHandle1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (handledRequestCount.get() &lt; maxRequestValue) &#123;</span><br><span class="line">        handledRequestCount.incrementAndGet();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doHandle</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 处理后，计数器器减一</span></span><br><span class="line">    handledRequestCount.decrementAndGet();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="集群（分布式）"><a href="#集群（分布式）" class="headerlink" title="集群（分布式）"></a>集群（分布式）</h3><p>redis中维护计数器</p>
]]></content>
      <tags>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>滑动窗口限流.md</title>
    <url>/2024/11/19/%E5%88%86%E5%B8%83%E5%BC%8F/%E9%99%90%E6%B5%81/%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E9%99%90%E6%B5%81/</url>
    <content><![CDATA[<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>记录每个请求到达的时间点，可以保证在任意时间窗口中都不会超过阈值</p>
<ul>
<li>记录每次请求的时间</li>
<li>统计<strong>每次请求的时间</strong>至<strong>每次请求的时间-时间窗口</strong>内的请求数</li>
<li>统计的请求数小于阈值则记录请求的时间并放行，否则拒绝请求</li>
</ul>
<h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>可以保证在任意时间窗口中都不会超过阈值</p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>无法解决短时间内集中的流量攻击</p>
<h2 id="如何实现"><a href="#如何实现" class="headerlink" title="如何实现"></a>如何实现</h2><h3 id="单机"><a href="#单机" class="headerlink" title="单机"></a>单机</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 滑动窗口限流</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> boolean</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">tryHandle3</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 记录每次请求的时间</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="comment">// 统计时间窗口中的请求数</span></span><br><span class="line">    <span class="keyword">if</span> (countRequestInWindow(now) &lt; maxRequestValue) &#123;</span><br><span class="line">        lastHandledTimeList.add(now);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 统计时间窗口中的请求数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> currentTime 当前时间</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">countRequestInWindow</span><span class="params">(<span class="type">long</span> currentTime)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">long</span> <span class="variable">left</span> <span class="operator">=</span> currentTime - timeWindow;</span><br><span class="line">    <span class="type">long</span> <span class="variable">right</span> <span class="operator">=</span> currentTime;</span><br><span class="line">    <span class="keyword">for</span> (Long time : lastHandledTimeList) &#123;</span><br><span class="line">        <span class="keyword">if</span> (time &gt;= left &amp;&amp; time &lt;= right) &#123;</span><br><span class="line">            count ++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="集群（分布式）"><a href="#集群（分布式）" class="headerlink" title="集群（分布式）"></a>集群（分布式）</h3>]]></content>
      <tags>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>RocketMq与kafka的区别.md</title>
    <url>/2024/12/16/%E5%88%86%E5%B8%83%E5%BC%8F/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RocketMQ/RocketMq%E4%B8%8Ekafka%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[]]></content>
      <tags>
        <tag>消息队列</tag>
      </tags>
  </entry>
  <entry>
    <title>顺序消息是如何实现的.md</title>
    <url>/2024/12/16/%E5%88%86%E5%B8%83%E5%BC%8F/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RocketMQ/%E9%A1%BA%E5%BA%8F%E6%B6%88%E6%81%AF%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>漏斗法限流.md</title>
    <url>/2024/11/19/%E5%88%86%E5%B8%83%E5%BC%8F/%E9%99%90%E6%B5%81/%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95/%E6%BC%8F%E6%96%97%E6%B3%95%E9%99%90%E6%B5%81/</url>
    <content><![CDATA[<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ol>
<li>请求过来，先放入桶中</li>
<li>桶放满则拒绝请求</li>
<li>服务定速处理桶内的请求</li>
</ol>
<h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>按固定的速率处理请求，可以平滑的处理请求</p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>面对突发流量，处理能力和平时一样</p>
<h2 id="如何实现"><a href="#如何实现" class="headerlink" title="如何实现"></a>如何实现</h2><h3 id="单机"><a href="#单机" class="headerlink" title="单机"></a>单机</h3><h3 id="集群（分布式）"><a href="#集群（分布式）" class="headerlink" title="集群（分布式）"></a>集群（分布式）</h3>]]></content>
  </entry>
</search>
